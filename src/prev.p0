:fun(main){
	d = 1 # debug
	a = 5000 # stack pointer
	:call(readFile)
	b = m
	:call(tokenize)
	# c = condition, d = debug, so next var is e
	e = m
	:call(syntax)
	# f = flag
	g = m
	:if(d){
		:call(debug_printExpressions)
		:call(debug_printTypes)
	}
	:call(semantics)
	:exit(a)
}
#
# Phase 3 - Semantic analisys
#
:fun(semantics){
	:if(d){
		:raw("\nPhase 3 - Semantic analisys\n")
	}
	:call(semantics_nameResolver)
	m = g # the memory pointer can be reset to the initial position
	:call(semantics_typeResolver)
}
:fun(semantics_typeResolver){
	:call(semantics_typeResolver_validateStructsAndArrays)
	i = e
	y = i < g
	:while(y){
		:load(x,i)
		:call(semantics_typeResolver_checkVoid)
		y = x == 0 # declaration
		:if(y){
			x = i + 2
			:load(x,x)
			y = x =! -1 # initialization
			:if(y){
				x = i + 1 # type
				:load(s,x)
				x = s + 1
				:load(x,x)
				y = x == 4 # array
				:if(y){
					:raw("Cannot initialize array type ")
					x = i + 3 # ident
					:load(x,x)
					:call(printIdent)
					:raw(". ")
					x = x + 3 # line no.
					:load(x,x)
					:call(errorPrintLine)
				}
				:call(push)
				x = i + 2 # expression
				:load(x,x)
				:call(semantics_typeResolver_resolveExpression)
				:call(pop)
				x = s
				:call(pop)
				y = s
				:call(semantics_typeResolver_equals)
				y = y == 0
				:if(y){
					:raw("Types must be equal when initializing. ")
					x = l
					:call(errorPrintLine)
				}
			}
		} else {
			y = x == 3 # function
			:if(y){
				x = i + 3 # start/end/decl
				y = x == 0
				:if(y){
					x = i + 1
					:load(f,x) # load f with type of current function
				}
			} else {
				y = x == 5 # return
				:if(y){

				} else {
					y = x == 6 # expression statement
					:if(y){

					} else {
						y = x == 7 # assignment
						:if(y){

						} else {
							y = x == 8 # if
							:if(y){

							} else {
								y = x == 9 # while
								:if(y){

								} else {
									y = x == 10 # call
									:if(y){

									}
								}
							}
						}
					}
				}
			}
		}
		i = i + 4
		y = i < g
	}
	y = u == 3 # void
	:if(y){
	}
}
# x type, y basetype
:fun(semantics_typeResolver_createType){
	m = m + 1
	:store(x,m) # type id
	m = m - 1
	x = 2
	:store(x,m) # memory cell type (2)
	m = m + 2
	:store(y,m) # basetype
	m = m + 2 # skip one
}
:fun(semantics_typeResolver_resolveExpression){
	s = u
	:call(push)
	s = v
	:call(push)
	s = x
	:call(push)
	s = y
	:call(push)
	:load(u,x)
	y = u =! 2 # expression
	:if(y){
		:raw("[ResolveExpression] Invalid input. ")
		x = l
		:call(errorPrintLine)
	}
	u = x + 1
	:load(u,u)
	y = u => 0
	v = u =< 3
	y = y & v # postincrement, postdecrement, preincrement, predecrement
	:if(y){
		u = x + 2
		:load(x,u)
		:call(semantics_typeResolver_resolveExpression)
		u = m - 1
		:load(x,u) # load address of type
		x = x + 1
		:load(x,x) # load type type
		y = x =! 0 # int
		u = x =! 1 # char
		y = y & u
		u = x =! 5 # ptr
		y = y & u
		:if(y){
			:raw("Increment operator must have expression of type int, char or pointer. ")
			x = l
			:call(errorPrintLine)
		}
		# operator doesnt change the type
	} else {
		y = u == 4 # prefix +
		v = u == 5 # prefix -
		y = y | v
		v = u == 27 # prefix ~ (bitwise negation)
		y = y | v
		:if(y){
			u = x + 2
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			u = m - 1
			:load(x,u) # load address of type
			x = x + 1
			:load(x,x) # load type type
			y = x =! 0 # int
			:if(y){
				:raw("Prefix operator +,- or ~ must have expression of type int. ")
				x = l
				:call(errorPrintLine)
			}
			# operator doesnt change the type
		} else {
			y = u == 6 # boolean negate
			:if(y){
				u = x + 2
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				u = m - 1
				:load(x,u) # load address of type
				x = x + 1
				:load(x,x) # load type type
				y = x =! 2 # bool
				:if(y){
					:raw("Prefix operator ! must have expression of type bool. ")
					x = l
					:call(errorPrintLine)
				}
				# operator doesnt change the type
			} else {
				y = u => 7
				v = u =< 9
				y = y & v # *,/,%
				v = u == 18 # &
				y = y | v
				v = u == 19 # |
				y = y | v
				v = u == 26 # ^
				y = y | v
				:call(semantics_typeResolver_resolveExpression_extra_outer)
			}
		}
	}
	:call(pop)
	y = s
	:call(pop)
	x = s
	:call(pop)
	v = s
	:call(pop)
	u = s
}
:fun(semantics_typeResolver_resolveExpression_extra_outer){
	:if(y){
		u = x + 2
		v = x + 3
		:load(x,u)
		:call(semantics_typeResolver_resolveExpression)
		s = m - 1
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		u = m - 1
		:load(x,u) # load address of type2
		x = x + 1
		:load(x,x) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		y = y + 1
		:load(y,y) # load type1 type
		x = x =! y # same type
		y = y =! 0 # int
		y = y | x
		:if(y){
			:raw("Operators *,/,%,&,|,^ must have 2 expressions of type int. ")
			x = l
			:call(errorPrintLine)
		}
		# operator doesnt change the type
	} else {
		y = u == 10 # binop +
		v = u == 11 # binop -
		y = y | v
		:if(y){
			u = x + 2
			v = x + 3
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			s = m - 1
			:call(push)
			:load(x,v)
			:call(semantics_typeResolver_resolveExpression)
			u = m - 1
			:load(x,u) # load address of type2
			x = x + 1
			:load(x,x) # load type2 type
			:call(pop)
			:load(y,s) # load address of type
			y = y + 1
			:load(y,y) # load type1 type
			v = x == 0 # int
			:if(v){
				v = y =! 0 # int
				x = y =! 1 # char
				v = v & x
				x = y =! 5 # ptr
				v = v & x
				:if(v){
					:raw("For operators + and -, one of the expressions must be int, the other can be int, char or pointer. ")
					x = l
					:call(errorPrintLine)
				}
				# copy type of first expression, which carries over
				:store(s,m)
				m = m + 1
			} else {
				v = y == 0 # int
				:if(v){
					v = x =! 0 # int
					y = x =! 1 # char
					v = v & y
					y = x =! 5 # ptr
					v = v & y
					:if(v){
						:raw("For operators + and -, one of the expressions must be int, the other can be int, char or pointer. ")
						x = l
						:call(errorPrintLine)
					}
					# type ok, 2nd expression carries over
				} else {
					:raw("For operators + and -, one of the expressions must be int, the other can be int, char or pointer. ")
					x = l
					:call(errorPrintLine)
				}
			}
		} else {
			y = u => 12
			v = u =< 15 # binop >
			y = y & v # binop <,>,<=,>=
			:if(y){
				u = x + 2
				v = x + 3
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				s = m - 1
				:call(push)
				:load(x,v)
				:call(semantics_typeResolver_resolveExpression)
				u = m - 1
				:load(x,u) # load address of type2
				x = x + 1
				:load(x,x) # load type2 type
				:call(pop)
				:load(y,s) # load address of type
				y = y + 1
				:load(y,y) # load type1 type
				x = x =! y # same type
				:if(x){
					:raw("Operators <,>,<=,>= must have 2 expressions of same type (int, char, pointer). ")
					x = l
					:call(errorPrintLine)
				} else {
					x = y =! 0 # int
					v = y =! 1 # char
					x = x & v
					v = y =! 5 # pointer
					x = x & v
					:if(x){
						:raw("Operators <,>,<=,>= must have 2 expressions of same type (int, char, pointer). ")
						x = l
						:call(errorPrintLine)
					}
				}
				x = 2
				y = 0
				:call(semantics_typeResolver_createType)
				x = m - 4
				:store(x,m)
				m = m + 1
			} else {
				y = u == 16 # ==
				v = u == 17 # !=
				y = y | v
				:if(y){
					u = x + 2
					v = x + 3
					:load(x,u)
					:call(semantics_typeResolver_resolveExpression)
					s = m - 1
					:call(push)
					:load(x,v)
					:call(semantics_typeResolver_resolveExpression)
					u = m - 1
					:load(x,u) # load address of type2
					x = x + 1
					:load(x,x) # load type2 type
					:call(pop)
					:load(y,s) # load address of type
					y = y + 1
					:load(y,y) # load type1 type
					x = x =! y # same type
					u = y == 4 # array
					x = x | u
					u = y == 3 # void
					x = x | u
					u = y == 6 # struct
					x = x | u
					:if(y){
						:raw("Operators ==,!= must have 2 expressions of same type (int, bool, char, pointer). ")
						x = l
						:call(errorPrintLine)
					}
				} else {
					y = u == 20 # &&
					v = u == 21 # ||
					y = y | v
					:if(y){
						u = x + 2
						v = x + 3
						:load(x,u)
						:call(semantics_typeResolver_resolveExpression)
						s = m - 1
						:call(push)
						:load(x,v)
						:call(semantics_typeResolver_resolveExpression)
						u = m - 1
						:load(x,u) # load address of type2
						x = x + 1
						:load(x,x) # load type2 type
						:call(pop)
						:load(y,s) # load address of type
						y = y + 1
						:load(y,y) # load type1 type
						x = x =! y # same type
						y = y =! 2 # bool
						y = y | x
						:if(y){
							:raw("Operators &&,|| must have 2 expressions of type bool. ")
							x = l
							:call(errorPrintLine)
						}
						# type doesnt change
					} else {
						y = u == 22 # ident
						:if(y){
							u = x + 2 # ident token
							:load(u,u)
							u = u + 3 # line no.
							:load(u,u)
							l = u # keep l updated for error messages
							u = x + 3 # declaration location
							:load(u,u)
							u = u + 1 # type
							:load(u,u)
							:store(u,m)
							m = m + 1
						} else {
							y = u == 23 # const
							:call(semantics_typeResolver_resolveExpression_extra)
						}
					}
				}
			}
		}
	}
}
:fun(semantics_typeResolver_resolveExpression_extra){
	:if(y){
		u = x + 2 # const token
		:load(u,u)
		v = u + 3 # line no.
		:load(l,v) # keep current line updated
		v = u + 1
		y = v == 0 # int
		x = v == 1 # char
		y = y | x
		x = v == 2 # bool
		y = y | x
		:if(y){
			x = v
			y = 0
			:call(semantics_typeResolver_createType)
			x = m - 4
			:store(x,m)
			m = m + 1
		}  else {
			y = v == 3 # char*
			:if(y){
				x = 1
				y = 0
				:call(semantics_typeResolver_createType)
				x = 5
				y = m - 4
				:call(semantics_typeResolver_createType)
				x = m - 4
				:store(x,m)
				m = m + 1
			} else {
				y = v == 4 # void*
				:if(y){
					x = 3
					y = 0
					:call(semantics_typeResolver_createType)
					x = 5
					y = m - 4
					:call(semantics_typeResolver_createType)
					x = m - 4
					:store(x,m)
					m = m + 1
				}
			}
		}
	} else {
		y = u == 24 # array
		:if(y){
			u = x + 2
			v = x + 3
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			s = m - 1
			:call(push)
			:load(x,v)
			:call(semantics_typeResolver_resolveExpression)
			u = m - 1
			:load(x,u) # load address of type2
			x = x + 1
			:load(x,x) # load type2 type
			:call(pop)
			:load(y,s) # load address of type
			y = y + 1
			:load(y,y) # load type1 type
			v = y =! 4 # array
			x = x =! 0 # int
			v = v | x
			:if(v){
				:raw("Base expression must be of type array, index must be type int. ")
				x = l
				:call(errorPrintLine)
			}
			:load(y,s)
			y = y + 2 # basetype
			:load(y,y)
			:store(y,m)
			m = m + 1
		} else {
			y = u == 25 # component
			:if(y){
				u = x + 2
				v = x + 3
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				u = m - 1
				:load(x,u) # load address of type2
				x = x + 1
				:load(y,x) # load type2 type
				y = y == 6 # struct
				:if(y){
					x = x + 1
					:load(x,x) # struct declaration
					:load(u,v) # load address of ident
					j = x
					y = 1
					w = 1
					:while(y){
						j = j + 4
						:load(x,j)
						y = x == 4 # parameter
						:if(y){
							x = j + 2
							:load(x,x)
							y = u
							:call(identEquals)
							:if(y){
								w = 0
								x = j + 1
								:load(x,x)
								:store(x,m)
								m = m + 1
							}
						}
						y = x =! 12 # struct
					}
					:if(w){
						:raw("Struct does not contain component ")
						x = u
						:call(printIdent)
						:raw(". ")
						x = l
						:call(errorPrintLine)
					}
				} else {
					:raw("Base expression must be type struct. ")
					x = l
					:call(errorPrintLine)
				}
			} else {
				y = u == 28 # prefix & (pointer)
				:call(semantics_typeResolver_resolveExpression_extra_inner)
			}
		}
	}
}
:fun(semantics_typeResolver_resolveExpression_extra_inner){
	:if(y){
		u = x + 2
		:load(x,u)
		:call(semantics_typeResolver_resolveExpression)
		u = m - 1
		:load(y,u) # load as basetype
		x = 5 # pointer
		:call(semantics_typeResolver_createType)
		x = m - 4
		:store(x,m)
		m = m + 1
	} else {
		y = u == 29 # prefix * (dereference)
		:if(y){
			u = x + 2
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			u = m - 1
			:load(x,u)
			y = x + 1
			:load(y,y)
			y = y == 5 # pointer
			:if(y){
				y = x + 2 #basetype
				:load(y,y)
				:store(y,m)
				m = m + 1
			} else {
				:raw("Expression must be a pointer. ")
				x = l
				:call(errorPrintLine)
			}
		} else {
			y = u == 30 # cast
			:if(y){
				u = x + 2
				v = x + 3
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				u = m - 1
				:load(u,u) # load address of type
				u = u + 1
				:load(u,u) # load expression type
				:load(x,v) # load address of cast type
				y = x + 1
				:load(y,y) # load type1 type
				v = y == 2 # bool
				s = y == 3 # void
				v = v | s
				s = y == 4 # array
				v = v | s
				s = y == 6 # struct
				v = v | s
				s = u == 2 # bool
				v = v | s
				s = u == 3 # void
				v = v | s
				s = u == 4 # array
				v = v | s
				s = u == 6 # struct
				v = v | s
				:if(v){
					:raw("Cast expression can contain types int, char and pointer. ")
					x = l
					:call(errorPrintLine)
				}
				:store(x,m)
				m = m + 1
			} else {
				y = u == 31 # pointer component
				:if(y){
					u = x + 2
					v = x + 3
					:load(x,u)
					:call(semantics_typeResolver_resolveExpression)
					u = m - 1
					:load(x,u) # load address of type2
					x = x + 1
					:load(y,x) # load type2 type
					y = y == 5 # pointer
					s = x + 1 # basetype
					:load(x,s)
					s = x + 1 # type type
					:load(s,s)
					s = s == 6 # struct
					y = y & s
					:if(y){
						x = x + 2
						:load(x,x) # struct declaration
						:load(u,v) # load address of ident
						j = x
						y = 1
						w = 1
						:while(y){
							j = j + 4
							:load(x,j)
							y = x == 4 # parameter
							:if(y){
								x = j + 2
								:load(x,x)
								y = u
								:call(identEquals)
								:if(y){
									w = 0
									x = j + 1
									:load(x,x)
									:store(x,m)
									m = m + 1
								}
							}
							y = x =! 12 # struct
						}
						:if(w){
							:raw("Struct does not contain component ")
							x = u
							:call(printIdent)
							:raw(". ")
							x = l
							:call(errorPrintLine)
						}
					} else {
						:raw("Base expression must be type struct. ")
						x = l
						:call(errorPrintLine)
					}		
				}
			}
		}
	}
}
# input: x,y
:fun(semantics_typeResolver_equals){
	s = u
	:call(push)
	s = v
	:call(push)
	s = x
	:call(push)
	:load(u,x)
	:load(v,y)
	u = u =! 1
	v = v =! 1
	u = u | v
	:if(u){
		:raw("[TypeEquals] Invalid input")
		x = l
		:call(errorPrintLine)
	}
	u = x + 1
	:load(u,u)
	v = y + 1
	:load(v,v)
	u = u == v
	:if(u){ # are equal
		u = v == 4 # array
		:if(u){

		} else {
			u = v == 5 # ptr
			:if(u){

			} else {
				u = v == 6 # name
				:if(u){ # compare decls here

				}
			}
		}
	} else {
		y = 0
	}
	:call(pop)
	x = s
	:call(pop)
	v = s
	:call(pop)
	u = s
}
:fun(semantics_typeResolver_checkVoid){
	y = x == 0 # declaration
	:if(y){
		v = 3 # offset
	}
	u = x == 4 # parameter
	:if(u){
		v = 2 # offset
	}
	y = y | u
	:if(y){
		u = i + 1
		:load(u,u) # load type address
		u = u + 1 
		:load(u,u) # load type
		y = u == 3 # void
		:if(y){
			:raw("Variable or field ":)
			x = i + v # ident
			:load(x,x)
			:call(printIdent)
			:raw(" cannot be void. ")
			x = x + 3 # line no.
			:load(x,x)
			:call(errorPrintLine)
		}
	}
}
:fun(semantics_typeResolver_recursiveType){
	:load(u,x)
	y = u =! 1 # type
	:if(y){
		x = -20
		:call(errorPrintLine)
	}
	u = x + 1
	:load(u,u)
	y = u == 4 # array
	:while(y){ # resolve type as long as its an array
		x = x + 2
		:load(x,x)
		u = x + 1
		:load(u,u)
		y = u == 4 # array
	}
	y = u == 6 # nametype
	:if(y){
		u = x + 2 # basetype
		:load(u,u) # should be address of struct declaration
		j = g
		y = j < m
		:while(y){
			:load(x,j)
			y = x == u
			:if(y){
				:raw("Struct ")
				x = x + 2 # ident
				:load(x,x)
				:call(printIdent)
				:raw(" cannot be recursive (use pointers!). ")
				x = x + 3 # line no.
				:load(x,x)
				:call(errorPrintLine)
			}
			j = j + 1
			y = j < m
		}
		:store(u,m)
		m = m + 1
		y = 1
		:while(y){
			u = u + 4
			:load(x,u)
			y = x == 4 # parameter
			:if(y){
				x = u + 1 # parameter type
				:load(x,x)
				s = u
				:call(push)
				:call(semantics_typeResolver_recursiveType)
				:call(pop)
				u = s
				y = 1
			} else {
				y = x =! 12 # end of struct
			}
		}
	}
}
:fun(semantics_typeResolver_validateStructsAndArrays){
	i = e
	y = i < g
	:while(y){
		:load(x,i)
		y = x == 12 # struct
		:if(y){
			:store(i,m)
			m = m + 1
			f = 1 # parameter flag
			:while(y){
				i = i + 4
				:load(x,i)
				y = x == 4 # parameter (struct component)
				:if(y){
					f = 0
					x = i + 1 # parameter type
					:load(x,x)
					:call(semantics_typeResolver_recursiveType)
					y = 1
				} else {
					y = x =! 12 # end of struct
				}
			}
			:if(f){
				:raw("Struct ")
				x = m - 1
				:load(x,x)
				x = x + 2 # ident
				:load(x,x)
				x = x + 3 # line no.
				:call(printIdent)
				:raw(" cannot be empty. ")
				:load(x,x)
				:call(errorPrintLine)
			}
			m = m - 1
		} else {
			y = x == 1 # type
			u = i + 1
			:load(u,u)
			u = u == 4 # array
			y = y & u
			:if(y){
				x = i + 3 # const
				:load(x,x)
				u = x
				:load(x,u)
				x = u
				u = x + 1
				:load(u,u)
				u = u =! 0 # int
				:if(u){
					:raw("Array length must be an int. ")
					x = x + 3
					:load(x,x)
					:call(errorPrintLine)
				}
				u = x + 2 # value
				:load(u,u)
				u = u == 0
				:if(u){
					:raw("Array length cannot be 0. ")
					x = x + 3
					:load(x,x)
					:call(errorPrintLine)
				}
			}
		}
		i = i + 4
		y = i < g
	}
}
:fun(semantics_nameResolver){
	i = e
	y = i < g
	t = 0
	# First pass - global declarations
	:while(y){
		:load(x,i)
		y = x == 3 # function
		:if(y){
			x = i + 2
			:load(x,x)
			p = x
			:call(semantics_nameResolver_getDeclaration)
			y = y =! -1
			:if(y){
				:raw("Name ")
				x = p
				:call(printIdent)
				:raw(" already declared. ")
				x = p + 3
				:load(x,x)
				:call(errorPrintLine)
			}
			:store(i,m)
			m = m + 1
			:store(t,m)
			m = m + 1
			y = 1
			:while(y){
				i = i + 4
				:load(x,i)
				y = x =! 3 # skip function bodies on first pass
			}
		} else {
			:call(semantics_nameResolver_handleDeclaration)
		}
		i = i + 4
		y = i < g
	}
	:raw("FIRST PASS DONE \n")
	i = e
	y = i < g
	t = 0
	:while(y){
		:load(x,i)
		y = x == 3 # function
		:if(y){
			t = t + 1
			s = m
			:call(push)
			i = i + 4
			:load(x,i)
			y = x =! 3 # function end
			:while(y){
				y = x == 0 # declaration
				u = x == 12 # type declaration
				y = y | u
				u = x == 4 # parameter
				y = y | u
				:if(y){
					:call(semantics_nameResolver_handleDeclaration)
				} else {
					y = x == 8 # if
					u = x == 9 # while
					y = y | u
					:if(y){
						:call(semantics_nameResolver_recursive)
					} else {
						:call(semantics_nameResolver_resolveNames)
					}
				}
				i = i + 4
				:load(x,i)
				y = x =! 3 # function end
			}
			:call(pop)
			m = s
			t = t - 1
		} else {
			y = x == 1 # type
			u = i + 1
			:load(u,u)
			u = u == 6 # name
			y = y & u
			:if(y){
				x = i + 2 # ident
				:load(x,x)
				p = x
				:call(semantics_nameResolver_getTypeDeclaration)
				y = r == -1
				:if(y){
					:raw("Undeclared type ")
					x = p
					:call(printIdent)
					:raw(". ")
					x = p + 3
					:load(x,x)
					:call(errorPrintLine)
				}
				x = i + 2
				:store(r,x)
			}
		}
		i = i + 4
		y = i < g
	}
}
:fun(semantics_nameResolver_resolveNames){
	y = x == 2 # expression
	u = i + 1
	:load(u,u)
	u = u == 22 # ident expression
	y = y & u
	:if(y){
		x = i + 2 # ident
		:load(x,x)
		p = x
		:call(semantics_nameResolver_getDeclaration)
		y = r == -1
		:if(y){
			:raw("Undeclared name ")
			x = p
			:call(printIdent)
			:raw(". ")
			x = p + 3
			:load(x,x)
			:call(errorPrintLine)
		}
		x = i + 3 # declaration is in place of expr2
		:store(r,x)
	} else {
		y = x == 1 # type
		u = i + 1 # type id
		:load(u,u)
		u = u == 6 # named type
		y = y & u
		:if(y){
			x = i + 2 # ident
			:load(x,x)
			p = x
			:call(semantics_nameResolver_getTypeDeclaration)
			y = r == -1
			:if(y){
				:raw("Undeclared type ")
				x = p
				:call(printIdent)
				:raw(". ")
				x = p + 3
				:load(x,x)
				:call(errorPrintLine)
			}
			x = i + 2
			:store(r,x)
		} else {
			y = x == 10 # call
			u = i + 1 # start/end
			:load(u,u)
			u = u == 0 # start
			y = y & u
			:if(y){
				x = i + 2 # ident
				:load(x,x)
				p = x
				:call(semantics_nameResolver_getDeclaration)
				y = r == -1
				:if(y){
					:raw("Undeclared name ")
					x = p
					:call(printIdent)
					:raw(". ")
					x = p + 3
					:load(x,x)
					:call(errorPrintLine)
				}
				x = i + 2
				:store(r,x)
			}
		}
	}
}
:fun(semantics_nameResolver_recursive){
	t = t + 1
	s = m
	:call(push)
	y = x == 8 # if/else
	:if(y){
		y = i + 1
		:load(y,y)
		y = y == 0
		i = i + 4
		:load(x,i)
		:if(y){ # if
			y = x =! 8 # if/else
			u = i + 1
			:load(u,u)
			u = u =! 1 # else
			y = y | u
			:while(y){
				y = x == 0 # declaration
				u = x == 12 # type declaration
				y = y | u
				:if(y){
					:call(semantics_nameResolver_handleDeclaration)
				} else {
					y = x == 8 # if
					u = x == 9 # while
					y = y | u
					:if(y){
						:call(semantics_nameResolver_recursive)
					} else {
						:call(semantics_nameResolver_resolveNames)
					}
				}
				i = i + 4
				:load(x,i)
				y = x =! 8 # if/else
				u = i + 1
				:load(u,u)
				v = u == 0 # another start of if
				y = y | v
			}
			y = u == 1 # else
			:if(y){
				i = i - 4 # move one cell back so the else starts a new recursive resolver
			}
		} else { # else 
			y = x =! 8 # if/else
			u = i + 1
			:load(u,u)
			u = u =! 2 # end
			y = y | u
			:while(y){
				y = x == 0 # declaration
				u = x == 12 # type declaration
				y = y | u
				:if(y){
					:call(semantics_nameResolver_handleDeclaration)
				} else {
					y = x == 8 # if
					u = x == 9 # while
					y = y | u
					:if(y){
						:call(semantics_nameResolver_recursive)
					} else {
						:call(semantics_nameResolver_resolveNames)
					}
				}
				i = i + 4
				:load(x,i)
				y = x =! 8 # if/else
				u = i + 1
				:load(u,u)
				u = u =! 2 # end
				y = y | u
			}
		}
	} else { # while
		i = i + 4
		:load(x,i)
		y = x =! 9 # while
		u = i + 1
		:load(u,u)
		u = u =! 1 # end
		y = y | u
		:while(y){
			y = x == 0 # declaration
			u = x == 12 # type declaration
			y = y | u
			:if(y){
				:call(semantics_nameResolver_handleDeclaration)
			} else {
				y = x == 8 # if
				u = x == 9 # while
				y = y | u
				:if(y){
					:call(semantics_nameResolver_recursive)
				} else {
					:call(semantics_nameResolver_resolveNames)
				}
			}
			i = i + 4
			:load(x,i)
			y = x =! 9 # while
			u = i + 1
			:load(u,u)
			u = u =! 1 # end
			y = y | u
		}
	}
	:call(pop)
	m = s
	t = t - 1
}
:fun(semantics_nameResolver_handleDeclaration){
	y = x == 0 # declaration
	:if(y){
		x = i + 3
		:load(x,x)
		p = x
		:call(semantics_nameResolver_getDeclaration)
		y = y =! -1
		q = q == t
		y = y & q
		:if(y){
			:raw("Name ")
			x = p
			:call(printIdent)
			:raw(" already declared. ")
			x = p + 3
			:load(x,x)
			:call(errorPrintLine)
		}
		:store(i,m)
		m = m + 1
		:store(t,m)
		m = m + 1
	} else {
		y = x == 12 # struct
		:if(y){
			x = i + 2
			:load(x,x)
			p = x
			:call(semantics_nameResolver_getTypeDeclaration)
			y = y =! -1
			q = q == t
			y = y & q
			:if(y){
				:raw("Type ")
				x = p
				:call(printIdent)
				:raw(" already declared. ")
				x = p + 3
				:load(x,x)
				:call(errorPrintLine)
			}
			:store(i,m)
			m = m + 1
			:store(t,m)
			m = m + 1
			i = i + 4
			:load(x,i)
			y = x =! 12
			t = t + 1
			s = m
			:call(push)
			:while(y){
				i = i + 4
				:load(x,i)
				y = x =! 12
				:if(y){
					:call(semantics_nameResolver_handleDeclaration)
					y = 1
				}
			}
			t = t - 1
			:call(pop)
			m = s
		} else {
			y = x == 4 # parameter
			:if(y){
				x = i + 2
				:load(x,x)
				p = x
				:call(semantics_nameResolver_getDeclaration)
				y = y =! -1
				q = q == t
				y = y & q
				:if(y){
					:raw("Parameter ")
					x = p
					:call(printIdent)
					:raw(" already declared. ")
					x = p + 3
					:load(x,x)
					:call(errorPrintLine)
				}
				:store(i,m)
				m = m + 1
				:store(t,m)
				m = m + 1
			}
		}
	}
}
:fun(semantics_nameResolver_getDeclaration){
	j = m - 2
	r = -1
	q = -1
	y = j => g
	z = x # save search ident
	:while(y){
		:load(u,j) # load declaration address
		:load(v,u) # load declaration type
		y = v == 0 # variable
		:if(y){
			v = u + 3
			:load(y,v)
			x = z
			:call(identEquals)
			:if(y){
				r = u
				q = j + 1
				:load(q,q)
			}
		} else {
			y = v == 3 # function
			v = v == 4 # parameter
			y = y | v
			:if(y){
				v = u + 2
				:load(y,v)
				x = z
				:call(identEquals)
				:if(y){
					r = u
					q = j + 1
					:load(q,q)
				}
			}
		}
		j = j - 2
		y = j => g
		u = r == -1
		y = y & u
	}
	y = r
}
:fun(semantics_nameResolver_getTypeDeclaration){
	j = m - 2
	r = -1
	q = -1
	y = j => g
	z = x # save search ident
	:while(y){
		:load(u,j) # load declaration address
		:load(v,u) # load declaration type
		y = v == 12 # struct
		:if(y){
			v = u + 2
			:load(y,v)
			x = z
			:call(identEquals)
			:if(y){
				r = u
				q = j + 1
				:load(q,q)
			}
		}
		j = j - 2
		y = j => g
		u = r == -1
		y = y & u
	}
	y = r
}
#
# Phase 2 - Syntax analisys
#
:fun(syntax){
	:if(d){
		:raw("\nPhase 2 - Syntax analisys\n")
	}
	i = b
	g = e - 4 # dont count safety token
	c = i < g
	:while(c){
		f = 1
		w = i # save old place of token parsing
		o = m # save old memory pointer
		:call(syntax_isDeclaration)
		:if(f){
			# restore if matching changed anything
			i = w
			m = o
			:call(syntax_isTypeDeclaration)
			:if(f){
				i = w
				m = o
				:call(syntax_isFunction)
				:if(f){
					:call(errorUnmatchedToken)
				}
			}
		}
		c = i < g
	}
}
:fun(syntax_isParameter){
	:call(syntax_isType)
	y = f == 0 # match found
	:load(x,i)
	x = x == 2 # ident
	y = y & x
	:if(y){
		x = 4 # parameter
		:store(x,m)
		x = m - 4 # type was written in last cell
		m = m + 1
		:store(x,m)
		m = m + 1
		:store(i,m) # identifier is current token
		m = m + 2 # skip one
		i = i + 4
		:if(d){
			:raw("PAR ")
		}
	} else {
		f = 1
	}
}
:fun(syntax_isFunction){
	:call(syntax_isType)
	y = f == 0 # match found
	:load(x,i)
	x = x == 2 # ident
	y = y & x
	:if(y){ # type ident
		x = 3 # function
		:store(x,m)
		x = m - 4 # type was written in last cell
		m = m + 1
		:store(x,m)
		m = m + 1
		:store(i,m) # identifier is current token
		m = m + 1
		x = 0 # start of function block
		:store(x,m)
		z = m # save start of function memory location
		m = m + 1
		i = i + 4
		:load(x,i)
		y = x == 14 # (
		:if(y){
			i = i + 4
			:load(x,i)
			y = x =! 15 # )
			:if(y){ # undo first increment of while loop
				i = i - 4
			}
			:while(y){
				i = i + 4
				f = 1
				:call(syntax_isParameter)
				:if(f){
					:call(errorUnmatchedToken)
				}
				:load(x,i)
				y = x == 21 # ,
			}
			y = x =! 15 # )
			:if(y){
				x = 41  # )
				:call(errorExpectedX)
			}
			i = i + 4
			:load(x,i)
			y = x == 22 # ;
			:if(y){
				x = 2 # overwrite memory as function declaration start
				:store(x,z)
				:if(d){
					:raw("FUNDECL ")
				} 
			} else {
				y = x =! 16 # {
				:if(y){
					x = 123 # {
					:call(errorExpectedX)
				}
				i = i + 4
				:load(x,i)
				y = x =! 17 # }
				:while(y){
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
					y = x =! 17 # }
				}
				:if(d){
					:raw("FUN ")
				} 
			}
			i = i + 4
			x = 3 # function
			:store(x,m)
			x = 1 # function end block
			m = m + 3
			:store(x,m)
			m = m + 1
			f = 0 # set match flag
		} else {
			f = 1
		}
	} else {
		f = 1
	}
}
:fun(syntax_isStatement){
	s = w
	:call(push)
	s = o
	:call(push)
	w = i
	o = m
	:call(syntax_isDeclaration)
	:if(f){
		i = w
		m = o
		:call(syntax_isReturn)
		:if(f){
			i = w
			m = o
			:call(syntax_isAssign)
			:if(f){
				i = w
				m = o
				:call(syntax_isIf)
				:if(f){
					i = w
					m = o
					:call(syntax_isWhile)
					:if(f){
						i = w
						m = o
						:call(syntax_isExprStmt)
						:if(f){
							i = w
							m = o
							:call(syntax_isTypeDeclaration)
						}
					}
				}
			}
		}
	}
	:call(pop)
	o = s
	:call(pop)
	w = s
}
:fun(syntax_isReturn){
	:load(x,i)
	y = x == 27 # return
	:if(y){
		i = i + 4
		:load(x,i)
		y = x == 22 # ;
		:if(y){
			x = 5 # return
			:store(x,m)
			x = -1 # expression
			m = m + 1
			:store(x,m)
			m = m + 3 # skip two
			f = 0 # set match flag
			:if(d){
				:raw("RET ")
			}
		} else {
			:call(syntax_isExpression)
			y = f == 0
			:load(x,i)
			x = x == 22 # ;
			y = y & x
			:if(y){
				i = i + 4
				x = 5 # return
				:store(x,m)
				x = m - 4 # expression
				m = m + 1
				:store(x,m)
				m = m + 3 # skip two
				f = 0 # set match flag
				:if(d){
					:raw("RET ")
				}
			} else {
				f = 1
			}
		}
	}
}
:fun(syntax_isAssign){
	:call(syntax_isExpression)
	y = f == 0
	:load(x,i)
	x = x == 1 # any of the assignments
	y = y & x
	f = 1
	:if(y){
		z = i + 1
		:load(s,z)
		:call(push)
		s = m - 4
		:call(push)
		i = i + 4
		:call(syntax_isExpression)
		y = f == 0
		:load(x,i)
		x = x == 22 # ;
		y = y & x
		:call(pop) # expr1 mem
		z = s
		:call(pop) # assignment op
		:if(y){
			i = i + 4
			x = 7 # assignment
			:store(x,m)
			u = m - 4 # expression2
			m = m + 1
			:store(s,m) # assignment op
			m = m + 1
			:store(z,m) # expression1
			m = m + 1
			:store(u,m) # expression 2
			m = m + 1
			f = 0 # set match flag
			:if(d){
				:raw("ASS ")
			}
		} else {
			f = 1
		}
	}
}
:fun(syntax_isIf){
	:load(x,i)
	y = x == 11 # if
	:if(y){
		i = i + 4
		:load(x,i)
		y = x == 14 # (
		:if(y){
			i = i + 4
			f = 1
			:call(syntax_isExpression)
			y = f == 0
			:load(x,i)
			x = x == 15 # )
			y = y & x
			:if(y){
				i = i + 4
				x = 8 # if/else
				:store(x,m)
				u = m - 4 # expression is last cell
				m = m + 1
				x = 0 # if
				:store(x,m)
				m = m + 1
				:store(u,m) # expression
				m = m + 2 # skip one
				:load(x,i)
				y = x == 16 # {
				:if(y){
					i = i + 4
					:load(x,i)
					y = x =! 17 # }
					:while(y){
						f = 1
						:call(syntax_isStatement)
						:if(f){
							:call(errorUnmatchedToken)
						}
						:load(x,i)
						y = x =! 17 # }
					}
					i = i + 4
				} else {
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
				}
				:load(x,i)
				y = x == 12 # else
				:if(y){
					:if(d){
						:raw("IF ")
					}
					x = 8 # if/else
					:store(x,m)
					m = m + 1
					x = 1 # else
					:store(x,m)
					m = m + 3 # skip two
					i = i + 4
					:load(x,i)
					y = x == 16 # {
					:if(y){
						i = i + 4
						:load(x,i)
						y = x =! 17 # }
						:while(y){
							f = 1
							:call(syntax_isStatement)
							:if(f){
								:call(errorUnmatchedToken)
							}
							:load(x,i)
							y = x =! 17 # }
						}
						i = i + 4
					} else {
						f = 1
						:call(syntax_isStatement)
						:if(f){
							:call(errorUnmatchedToken)
						}
					}
					x = 8 # if/else
					:store(x,m)
					m = m + 1
					x = 2 # end
					:store(x,m)
					m = m + 3 # skip two
					:if(d){
						:raw("ELSE ")
					}
				} else {
					x = 8 # if/else
					:store(x,m)
					m = m + 1
					x = 2 # end
					:store(x,m)
					m = m + 3 # skip two
					:if(d){
						:raw("IF ")
					}
				}
			} else {
				f = 1
			}
		}
	}
}
:fun(syntax_isWhile){
	:load(x,i)
	y = x == 13 # while
	z = i + 4
	:load(x,z)
	u = x == 14 # (
	y = y & u
	:if(y){
		i = z + 4
		:call(syntax_isExpression)
		y = f == 0
		:load(x,i)
		x = x == 15 # )
		:if(y){
			i = i + 4
			x = 9 # while
			:store(x,m)
			u = m - 4 # expression is last cell
			m = m + 1
			x = 0 # start
			:store(x,m)
			m = m + 1
			:store(u,m) # expression
			m = m + 2 # skip one
			:load(x,i)
			y = x == 16 # {
			:if(y){
				i = i + 4
				:load(x,i)
				y = x =! 17 # }
				:while(y){
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
					y = x =! 17 # }
				}
				i = i + 4
			} else {
				f = 1
				:call(syntax_isStatement)
				:if(f){
					:call(errorUnmatchedToken)
				}
			}
			x = 9 # while
			:store(x,m)
			m = m + 1
			x = 1 # end
			:store(x,m)
			m = m + 3 # skip two
			:if(d){
				:raw("WHILE ")
			}
		}
	}
}
:fun(syntax_isExprStmt){
	:call(syntax_isExpression)
	y = f == 0
	:load(x,i)
	x = x == 22 # ;
	y = y & x
	:if(y){
		i = i + 4
		x = 6 # expr stmt
		:store(x,m)
		x = m - 4 # expression
		m = m + 1
		:store(x,m)
		m = m + 3 # skip two
		f = 0 # set match flag
		:if(d){
			:raw("EXP ")
		}
	} else {
		f = 1
	}
}
:fun(syntax_isExpression){
	:call(syntax_isExpression_f)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_ee)
	}
}
:fun(syntax_isExpression_ee){
	:load(x,i)
	y = x == 42 # ||
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		:call(syntax_isExpression_f)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		x = 21 # ||
		:store(x,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_ee)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_f){
	:call(syntax_isExpression_g)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_ff)
	}
}
:fun(syntax_isExpression_ff){
	:load(x,i)
	y = x == 41 # &&
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		:call(syntax_isExpression_g)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		x = 20 # &&
		:store(x,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_ff)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_g){
	:call(syntax_isExpression_x)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_gg)
	}
}
:fun(syntax_isExpression_gg){
	:load(x,i)
	y = x == 29 # |
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		:call(syntax_isExpression_x)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		x = 19 # |
		:store(x,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_gg)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_x){
	:call(syntax_isExpression_h)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_xx)
	}
}
:fun(syntax_isExpression_xx){
	:load(x,i)
	y = x == 44 # ^
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		:call(syntax_isExpression_h)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		x = 26 # ^
		:store(x,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_xx)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_h){
	:call(syntax_isExpression_i)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_hh)
	}
}
:fun(syntax_isExpression_hh){
	:load(x,i)
	y = x == 28 # &
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		:call(syntax_isExpression_i)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		x = 18 # &
		:store(x,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_hh)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_i){
	:call(syntax_isExpression_j)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_ii)
	}
}
:fun(syntax_isExpression_ii){
	:load(x,i)
	y = x == 30 # ==
	z = x == 31 # !=
	y = y | z
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		y = x == 30
		:if(y){
			s = 16 # ==
		} else {
			s = 17 # !=
		}
		:call(push) # op
		:call(syntax_isExpression_j)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		:call(pop) # op
		:store(s,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_ii)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_j){
	:call(syntax_isExpression_k)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_jj)
	}
}
:fun(syntax_isExpression_jj){
	:load(x,i)
	y = x == 32 # <
	z = x == 33 # >
	y = y | z
	z = x == 34 # <=
	y = y | z
	z = x == 35 # >=
	y = y | z
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		s = x - 20 # offset of new codes
		:call(push) # op
		:call(syntax_isExpression_k)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		:call(pop) # op
		:store(s,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_jj)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_k){
	:call(syntax_isExpression_l)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_kk)
	}
}
:fun(syntax_isExpression_kk){
	:load(x,i)
	y = x == 39 # +
	z = x == 40 # -
	y = y | z
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		s = x - 29
		:call(push) # op
		:call(syntax_isExpression_l)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		:call(pop) # op
		:store(s,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_kk)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_l){
	:call(syntax_isExpression_m)
	y = f == 0
	:if(y){
		f = 1
		:call(syntax_isExpression_ll)
	}
}
:fun(syntax_isExpression_ll){
	:load(x,i)
	y = x == 36 # *
	z = x == 37 # /
	y = y | z
	z = x == 38 # %
	y = y | z
	:if(y){
		i = i + 4
		s = m - 4
		:call(push) # expr1
		s = x - 29
		:call(push) # op
		:call(syntax_isExpression_m)
		u = m - 4
		x = 2 # expression
		:store(x,m)
		m = m + 1
		:call(pop) # op
		:store(s,m) # type
		m = m + 1
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m + 1
		:store(u,m) #expr2
		m = m + 1
		y = f == 0
		:if(y){
			f = 1
			:call(syntax_isExpression_ll)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_m){
	:load(x,i)
	y = x == 25 # ++
	:if(y){
		s = 2 # pref ++
	}
	z = x == 26 # --
	:if(z){
		s = 3 # pref --
	}
	y = y | z
	z = x == 39 # +
	:if(z){
		s = 4 # pref +
	}
	y = y | z
	z = x == 40 # -
	:if(z){
		s = 5 # pref -
	}
	y = y | z
	z = x == 24 # !
	:if(z){
		s = 6 # pref !
	}
	y = y | z
	z = x == 43 # ~
	:if(z){
		s = 27 # pref ~
	}
	y = y | z
	z = x == 28 # &
	:if(z){
		s = 28 # &
	}
	y = y | z
	z = x == 36 # *
	:if(z){
		s = 29 # *
	}
	y = y | z
	z = x == 14 # (
	:if(z){
		i = i + 4
		f = 1
		:call(syntax_isType)
		u = f == 0
		:load(x,i)
		v = x == 15 # )
		u = u & v
		:if(u){
			s = m - 4
			:call(push)
			s = 30
			y = y | 1
		} else {
			i = i - 8
		}
	}
	:if(y){
		i = i + 4
		:call(push)
		:call(syntax_isExpression_m)
		u = 2 # expression
		:store(u,m)
		u = m - 4
		m = m + 1
		:call(pop)
		:store(s,m) # type
		m = m + 1
		:store(u,m) # inner expression
		m = m + 1
		y = s == 30 # cast expression
		:if(y){
			:call(pop)
			:store(s, m) # type is in expr2
		}
		m = m + 1
	} else {
		:call(syntax_isExpression_n)
	}
}
:fun(syntax_isExpression_n){
	:call(syntax_isExpression_o)
	:call(syntax_isExpression_nn)
}
:fun(syntax_isExpression_nn){
	:load(x,i)
	y = x == 25 # ++
	z = x == 26 # --
	y = y | z
	:if(y){
		u = 2 # expression
		:store(u,m)
		u = m - 4 # save last cell
		x = x == 25
		:if(x){
			x = 0 # ++
		} else {
			x = 1 # --
		}
		m = m + 1
		:store(x,m) # type
		m = m + 1
		:store(u,m) # token
		m = m + 2 # skip one
		i = i + 4
		:call(syntax_isExpression_nn)
	} else {
		y = x == 18 # [
		:if(y){
			s = m - 4
			:call(push)
			i = i + 4
			f = 1
			:call(syntax_isExpression)
			y = f == 0
			:call(pop)
			:load(x,i)
			x = x == 19 # ]
			y = y & x
			:if(y){
				u = 2 # expression
				:store(u,m)
				u = m - 4 # save last cell
				x = 24 # array access 
				m = m + 1
				:store(x,m) # type
				m = m + 1
				:store(s,m) # base expression
				m = m + 1
				:store(u,m) # offset
				m = m + 1
				i = i + 4
				:call(syntax_isExpression_nn)
			}
		} else {
			y = x == 20 # .
			:if(y){
				i = i + 4
				:load(x,i)
				y = x == 2 # ident
				:if(y){
					u = m - 4 # last expression
					x = 2 # expression
					:store(x,m)
					m = m + 1
					x = 25 # comp acess
					:store(x,m) # type
					m = m + 1
					:store(u,m) # base expression
					m = m + 1
					:store(i,m) # token (component)
					m = m + 1
					i = i + 4
					:call(syntax_isExpression_nn)
				} else {
					f = 1
				}
			} else {
				y = x == 46 # ->
				:if(y){
					i = i + 4
					:load(x,i)
					y = x == 2 # ident
					:if(y){
						u = m - 4 # last expression
						x = 2 # expression
						:store(x,m)
						m = m + 1
						x = 31 # comp acess (from pointer)
						:store(x,m) # type
						m = m + 1
						:store(u,m) # base expression
						m = m + 1
						:store(i,m) # token (component)
						m = m + 1
						i = i + 4
						:call(syntax_isExpression_nn)
					} else {
						f = 1
					}
				}
			}
		}
	}
}
:fun(syntax_isExpression_o){
	:load(x,i)
	y = x == 2 # ident
	:if(y){
		z = i + 4
		:load(x,z)
		y = x == 14 # (
		:if(y){ # function call
			# Starting memory entry for call
			x = 10 # call
			:store(x,m)
			m = m + 1
			x = 0 # start
			:store(x,m)
			m = m + 1
			:store(i,m) # ident
			m = m + 2 # skip one
			# Finish writing memory
			i = z + 4
			:load(x,i)
			y = x =! 15 # )
			:if(y){ # undo first increment of while loop
				i = i - 4
			}
			:while(y){
				i = i + 4
				f = 1
				:call(syntax_isExpression)
				:if(f){
					:call(errorUnmatchedToken)
				}
				x = 11 # argument
				:store(x,m)
				u = m - 4
				m = m + 1
				:store(u,m)
				m = m + 3 # skip two
				:load(x,i)
				y = x == 21 # ,
			}
			y = x =! 15 # )
			:if(y){
				x = 41 # )
				:call(errorExpectedX)
			}
			# Ending memory entry for call
			x = 10 # call
			:store(x,m)
			m = m + 1
			x = 1 # end
			:store(x,m)
			m = m + 3 # skip two
		} else { # ident
			x = 2 # expression
			:store(x,m)
			m = m + 1
			x = 22 # ident
			:store(x,m) # type
			m = m + 1
			:store(i,m) # token
			m = m + 2 # skip one
		}
		i = i + 4
		f = 0
	} else {
		y = x == 3 # const
		:if(y){
			x = 2 # expression
			:store(x,m)
			m = m + 1
			x = 23
			:store(x,m) # type
			m = m + 1
			:store(i,m) # token
			m = m + 2 # skip one
			i = i + 4
			f = 0
		} else {
			y = x == 14 # (
			:if(y){
				i = i + 4
				:if(d){
					d = 0
					:call(syntax_isExpression)
					d = 1
				} else {
					:call(syntax_isExpression)
				}
				:load(x,i)
				y = x =! 15 # )
				:if(y){
					x = 41 # )
					:call(errorExpectedX)
				}
				i = i + 4
			}
		}
	}
}
:fun(syntax_isType){
	:load(x,i)
	y = x == 0 # type token
	f = 1
	:if(y){
		x = 1 # type
		:store(x,m)
		m = m + 1
		x = i + 1
		:load(x,x)
		:store(x,m) # type id
		m = m + 3 # skip one
		i = i + 4
		:load(x,i)
		f = 0 # set match flag
	} else {
		y = x == 2 # ident token
		:if(y){
			x = 1 # type
			:store(x,m)
			m = m + 1
			x = 6 # name type
			:store(x,m) # type id
			m = m + 1
			:store(i,m) # basetype is the ident
			m = m + 2 # skip one
			i = i + 4
			f = 0 # set match flag
		}
	}
	y = f == 0
	:while(y){
		:load(x,i)
		u = x == 36 # *
		:if(u){
			x = 1 # type
			:store(x,m)
			u = m - 4
			m = m + 1
			x = 5 # pointer type
			:store(x,m) # type id
			m = m + 1
			:store(u,m) # basetype is last type
			m = m + 2 # skip one
			i = i + 4
		} else {
			u = x == 18 # [
			z = i + 4
			:load(x,z)
			v = x == 3 # const
			u = u & v
			k = z
			z = z + 4
			:load(x,z)
			v = x == 19 # ]
			u = u & v
			:if(u){
				x = 1 # type
				:store(x,m)
				u = m - 4
				m = m + 1
				x = 4 # array type
				:store(x,m) # type id
				m = m + 1
				:store(u,m) # basetype is last type
				m = m + 1
				:store(k,m) # length is the const token
				m = m + 1
				i = z + 4
			} else {
				y = 0
			}
		}
	}
}
:fun(syntax_isDeclaration){
	:call(syntax_isType)
	y = f == 0 # match found
	:load(x,i)
	x = x == 2
	l = i # save identifier location
	y = y & x
	:if(y){ # type ident
		i = i + 4
		:load(x,i)
		y = x == 22 # ;
		:if(y){ # type ident;
			i = i + 4
			x = 0
			:store(x,m)
			x = m - 4 # type was written in last cell
			m = m + 1
			:store(x,m)
			m = m + 1
			x = -1
			:store(x,m)
			m = m + 1
			:store(l,m)
			m = m + 1
			f = 0 # set match flag
			:if(d){
				:raw("DECL ")
			}
		} else {
			y = x == 1 # any assignment
			z = i + 1
			:load(x,z) # load id
			x = x == 0 # =
			y = y & x
			:if(y){ # type ident = 
				i = i + 4
				n = m - 4 # save type location
				f = 1
				:call(syntax_isExpression)
				y = f == 0 # match found
				:load(x,i)
				x = x == 22 # ;
				y = y & x
				:if(y){ # type ident = expr ;
					i = i + 4
					x = 0
					:store(x,m)
					m = m + 1
					:store(n,m) # type location was saved in n
					m = m + 1
					x = m - 6 # last cell (4) and the 2 we just added
					:store(x,m)
					m = m + 1
					:store(l,m)
					m = m + 1
					:if(d){
						:raw("INIT ")
					}
				} else {
					f = 1 # no match
				}
			} else {
				f = 1 # no match
			}
		}
	} else {
		f = 1 # no match
	}
}
:fun(syntax_isTypeDeclaration){
	:load(x,i)
	y = x == 45 # struct
	:if(y){
		i = i + 4
		:load(x,i)
		y = x == 2 # ident
		:if(y){
			x = 12 # struct
			:store(x,m)
			m = m + 1
			x = 0 # start
			:store(x,m)
			m = m + 1
			:store(i,m)
			m = m + 2 # skip one
			i = i + 4
			:load(x,i)
			y = x == 16 # {
			:if(y){
				i = i + 4
				:load(x,i)
				y = x =! 17 # }
				:while(y){
					f = 1
					:call(syntax_isParameter)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
					y = x =! 22 # ;
					:if(y){
						x = 59 # ;
						:call(errorExpectedX)
					}
					y = x == -1 # EOF
					:if(y){
						:raw("End of file reached while parsing struct.")
						x = 1
						:exit(x)
					}
					i = i + 4
					:load(x,i)
					y = x =! 17 # }
				}
				x = 12 # struct
				:store(x,m)
				m = m + 1
				x = 1 # end
				:store(x,m)
				m = m + 3 # skip two
				i = i + 4
				:load(x,i)
				y = x =! 22 # ;
				:if(y){
					x = 59 # ;
					:call(errorExpectedX)
				} 
				i = i + 4
				f = 0
				:if(d){
					:raw("TYPEDECL ")
				}
			} else {
				x = 123 # {
				:call(errorExpectedX)
			}
		} else {
			:raw("Expected identifier. ")
			x = i + 3
			:load(x,x)
			:call(errorPrintLine)
		}
	}
}
#
# Phase 1 - Tokenize
#
:fun(tokenize){
	:if(d){
		:raw("Phase 1 - Tokenization\n")
	}
	l = 1 # line count
	i = 0 # file index
	c = i < b # read through the file
	:while(c){
		f = 1 # flag for matches ( 0 => stop trying to match)
		:call(tokenize_isComment)
		:if(f){
			:call(tokenize_isWhitespace)
			:if(f){
				:call(tokenize_isKeyword)
				:if(f){
					:call(tokenize_isConstant)
					:if(f){
						:call(tokenize_isSymbol)
						:if(f){
							:call(tokenize_isIdentifier)
							:if(f){
								:call(errorUnmatchedChar)
							}
						}
					}
				}
			}
		}
		c = i < b # Update condition
	}
	# End of tokens
	x = -1
	:store(x,m)
	m = m + 1
	:store(x,m)
	m = m + 1
	:store(x,m)
	m = m + 1
	:store(x,m)
	m = m + 1
}
# Match comment
:fun(tokenize_isComment){
	:load(x,i)
	y = x == 47 # '/'
	:if(y){
		z = i + 1
		:load(x,z)
		y = x == 47 # '/'
		u = z < b
		y = y & u
		:if(y){
			f = 0 # set match flag
			i = z + 1 # increment file index
			:load(x,i)
			y = x =! 10 # skip characters until end of line
			u = i < b
			y = y & u
			:while(y){
				i = i + 1 # increment file index
				:load(x,i)
				y = x =! 10 # newline
				u = i < b
				y = y & u
			}
		} else {
			y = x == 42 # '*'
			:if(y){
				v = 0
				i = i + 1
				:while(y){
					u = i => b
					:if(u){
						:call(errorEOFcomment)
					}
					:load(x,i)
					i = i + 1
					u = x == 42 # '*'
					:if(u){
						v = 1
					} else {
						u = x == 47 # /
						u = u & v
						:if(u){
							y = 0
						}
						v = 0
						u = x == 10 # \n
						:if(u){
							l = l + 1
						}
					}
				}
			}
		}
	}
}
# Match whitespace
:fun(tokenize_isWhitespace){
	:load(x,i)
	y = x == 10 # \n
	:if(y){
		l = l + 1 # increment line counter
	}
	z = x == 9 # \t
	y = y | z
	z = x == 32 # space
	y = y | z
	:if(y){
		f = 0 # set match flag
		:while(y){
			i = i + 1
			:load(x,i)
			y = x == 10 # \n
			:if(y){
				l = l + 1 # increment line counter
			}
			z = x == 9 # \t
			y = y | z
			z = x == 32 # space
			y = y | z
		}
	}
}
# Match keywords
:fun(tokenize_isKeyword){
	w = i # save file index if match fails
	# Preload 4 characters in t,u,v,z
	:load(p,i)
	i = i + 1
	:load(q,i)
	i = i + 1
	:load(r,i)
	i = i + 1
	:load(s,i)
	i = i + 1
	:load(t,i)
	i = i + 1
	:call(tokenize_isKeyword_bool)
	:if(f){
		:call(tokenize_isKeyword_char)
		:if(f){
			:call(tokenize_isKeyword_int)
			:if(f){
				:call(tokenize_isKeyword_void)
				:if(f){
					:call(tokenize_isKeyword_if)
					:if(f){
						:call(tokenize_isKeyword_else)
						:if(f){
							:call(tokenize_isKeyword_while)
							:if(f){
								:call(tokenize_isKeyword_return)
								:if(f){
									:call(tokenize_isKeyword_struct)
								}
							}
						}
					}
				}
			}
		}
	}
	:if(f){
		i = w # restore file index if no match was found
	}
}
# input x
# output y
# writes: u,v,y
:fun(tokenize_isKeyword_helper){ # check if char is not identifier
	y = x < 48 # 0
	u = x > 57 # 9
	v = x < 65 # A
	u = u & v
	y = y | u
	u = x > 90 # Z
	v = x < 97 # a
	u = u & v
	v = x =! 95 # _
	u = u & v
	y = y | u
	u = x > 122 # z
	y = y | u
}
# input: loaded p,q,r,s,t
# output: sets r, writes memory
# write: x,y,m
# calls: tokenize_isKeyword_helper
:fun(tokenize_isKeyword_bool){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 98 # b
	y = y & x
	x = q == 111 # o
	y = y & x
	x = r == 111 # o
	y = y & x
	x = s == 108 # l
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (bool)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1 
		i = i - 1
		:if(d){
			:raw("BOOL ")
		}
	}
}
:fun(tokenize_isKeyword_char){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 99 # c
	y = y & x
	x = q == 104 # h
	y = y & x
	x = r == 97 # a
	y = y & x
	x = s == 114 # r
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 1 # id 1 (char)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		i = i - 1
		:if(d){
			:raw("CHAR ")
		}
	}
}
:fun(tokenize_isKeyword_int){
	x = s # 4th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 105 # i
	y = y & x
	x = q == 110 # n
	y = y & x
	x = r == 116 # t
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 0 # id 0 (int)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		# i is too far
		i = i - 2
		:if(d){
			:raw("INT ")
		}
	}
}
:fun(tokenize_isKeyword_void){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 118 # v
	y = y & x
	x = q == 111 # o
	y = y & x
	x = r == 105 # i
	y = y & x
	x = s == 100 # d
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 3 # id 3 (void)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		i = i - 1
		:if(d){
			:raw("VOID ")
		}
	}
}
:fun(tokenize_isKeyword_if){
	x = r # 3rd character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 105 # i
	y = y & x
	x = q == 102 # f
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 11 # type 11
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		# i is too far since most keywords are 4 chars long
		i = i - 3
		:if(d){
			:raw("IF ")
		}
	}
}
:fun(tokenize_isKeyword_else){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 101 # e
	y = y & x
	x = q == 108 # l
	y = y & x
	x = r == 115 # s
	y = y & x
	x = s == 101 # e
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 12 # type 1
		:store(x,m)
		m = m + 3 # skip optional field
		x = l
		:store(x,m)
		m = m + 1
		i = i - 1
		:if(d){
			:raw("ELSE ")
		}
	}
}
:fun(tokenize_isKeyword_while){
	:load(x,i) # 6th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 119 # w
	y = y & x
	x = q == 104 # h
	y = y & x
	x = r == 105 # i
	y = y & x
	x = s == 108 # l
	y = y & x
	x = t == 101 # e
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 13 # type 1
		:store(x,m)
		m = m + 3 # skip optional field
		x = l
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("WHILE ")
		}
	}
}
:fun(tokenize_isKeyword_return){
	:load(z,i) # 6th character
	i = i + 1
	:load(x,i) # 7th character should be non-identifier
	i = i - 1
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 114 # r
	y = y & x
	x = q == 101 # e
	y = y & x
	x = r == 116 # t
	y = y & x
	x = s == 117 # u
	y = y & x
	x = t == 114 # r
	y = y & x
	x = z == 110 # n
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 27 # type 27
		:store(x,m)
		m = m + 3 # skip optional field
		x = l
		:store(x,m)
		m = m + 1
		i = i + 1 # increment file (we loaded but didnt increment)
		:if(d){
			:raw("RETURN ")
		}
	}
}
:fun(tokenize_isKeyword_struct){
	:load(z,i) # 6th character
	i = i + 1
	:load(x,i) # 7th character should be non-identifier
	i = i - 1
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 115 # s
	y = y & x
	x = q == 116 # t
	y = y & x
	x = r == 114 # r
	y = y & x
	x = s == 117 # u
	y = y & x
	x = t == 99 # c
	y = y & x
	x = z == 116 # t
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 45 # type 45
		:store(x,m)
		m = m + 3 # skip optional field
		x = l
		:store(x,m)
		m = m + 1
		i = i + 1 # increment file (we loaded but didnt increment)
		:if(d){
			:raw("STRUCT ")
		}
	}
}
:fun(tokenize_isSymbol){
	:load(x,i)
	:call(tokenize_isSymbol_ADDEQ)
	:if(f){
		:call(tokenize_isSymbol_SUBEQ)
		:if(f){
			:call(tokenize_isSymbol_DIVEQ)
			:if(f){
				:call(tokenize_isSymbol_MULEQ)
				:if(f){
					:call(tokenize_isSymbol_INC)
					:if(f){
						:call(tokenize_isSymbol_DEC)
						:if(f){
							:call(tokenize_isSymbol_EQ)
							:if(f){
								:call(tokenize_isSymbol_NEQ)
								:if(f){
									:call(tokenize_isSymbol_LEQ)
									:if(f){
										:call(tokenize_isSymbol_GEQ)
										:if(f){
											:call(tokenize_isSymbol_AND)
											:if(f){
												:call(tokenize_isSymbol_OR)
												:if(f){
													:call(tokenize_isSymbol_ARROW)
													:if(f){
														:call(tokenize_isSymbol_LPARENT)
														:if(f){
															:call(tokenize_isSymbol_RPARENT)
															:if(f){
																:call(tokenize_isSymbol_LCURLY)
																:if(f){
																	:call(tokenize_isSymbol_RCURLY)
																	:if(f){
																		:call(tokenize_isSymbol_LBRACK)
																		:if(f){
																			:call(tokenize_isSymbol_RBRACK)
																			:if(f){
																				:call(tokenize_isSymbol_PERIOD)
																				:if(f){
																					:call(tokenize_isSymbol_COMMA)
																					:if(f){
																						:call(tokenize_isSymbol_SEMICOLON)
																						:if(f){
																							:call(tokenize_isSymbol_COLON)
																							:if(f){
																								:call(tokenize_isSymbol_EXCL)
																								:if(f){
																									:call(tokenize_isSymbol_ASSIGN)
																									:if(f){
																										:call(tokenize_isSymbol_BITAND)
																										:if(f){
																											:call(tokenize_isSymbol_BITOR)
																											:if(f){
																												:call(tokenize_isSymbol_LT)
																												:if(f){
																													:call(tokenize_isSymbol_GT)
																													:if(f){
																														:call(tokenize_isSymbol_MUL)
																														:if(f){
																															:call(tokenize_isSymbol_DIV)
																															:if(f){
																																:call(tokenize_isSymbol_MOD)
																																:if(f){
																																	:call(tokenize_isSymbol_ADD)
																																	:if(f){
																																		:call(tokenize_isSymbol_SUB)
																																		:if(f){
																																			:call(tokenize_isSymbol_BITXOR)
																																			:if(f){
																																				:call(tokenize_isSymbol_BITNOT)
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(tokenize_isSymbol_ADDEQ){
	y = x == 43 # +
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 4
		:store(x,m)
		m = m + 1
		x = 1 # id 1 (+=)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("ADDEQ ")
		}
	}
}
:fun(tokenize_isSymbol_SUBEQ){
	y = x == 45 # -
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (-=)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("SUBEQ ")
		}
	}
}
:fun(tokenize_isSymbol_DIVEQ){
	y = x == 47 # /
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 3 # id 3 (/=)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("DIVEQ ")
		}
	}
}
:fun(tokenize_isSymbol_MULEQ){
	y = x == 42 # *
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 4 # id 4 (*=)
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("MULEQ ")
		}
	}
}
:fun(tokenize_isSymbol_INC){
	y = x == 43 # +
	z = i + 1
	:load(z,z)
	z = z == 43 # +
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 25 # type 25
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("INC ")
		}
	}
}
:fun(tokenize_isSymbol_DEC){
	y = x == 45 # -
	z = i + 1
	:load(z,z)
	z = z == 45 # -
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 26 # type 26
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("DEC ")
		}
	}
}
:fun(tokenize_isSymbol_EQ){
	y = x == 61 # =
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 30 # type 30
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("EQ ")
		}
	}
}
:fun(tokenize_isSymbol_NEQ){
	y = x == 33 # !
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 31 # type 31
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("NEQ ")
		}
	}
}
:fun(tokenize_isSymbol_LEQ){
	y = x == 60 # <
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 34 # type 34
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("LEQ ")
		}
	}
}
:fun(tokenize_isSymbol_GEQ){
	y = x == 62 # >
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 35 # type 35
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("GEQ ")
		}
	}
}
:fun(tokenize_isSymbol_AND){
	y = x == 38 # &
	z = i + 1
	:load(z,z)
	z = z == 38 # &
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 41 # type 41
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("AND ")
		}
	}
}
:fun(tokenize_isSymbol_OR){
	y = x == 124 # |
	z = i + 1
	:load(z,z)
	z = z == 124 # |
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 42 # type 42
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("OR ")
		}
	}
}
:fun(tokenize_isSymbol_ARROW){
	y = x == 45 # -
	z = i + 1
	:load(z,z)
	z = z == 62 # >
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 46 # type 46
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("ARROW ")
		}
	}
}
:fun(tokenize_isSymbol_LPARENT){
	y = x == 40 # (
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 14 # type 14
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("LPARENT ")
		}
	}
}
:fun(tokenize_isSymbol_RPARENT){
	y = x == 41 # )
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 15 # type 15
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("RPARENT ")
		}
	}
}
:fun(tokenize_isSymbol_LCURLY){
	y = x == 123 # {
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 16 # type 16
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("LCURLY ")
		}
	}
}
:fun(tokenize_isSymbol_RCURLY){
	y = x == 125 # {
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 17 # type 17
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("RCURLY ")
		}
	}
}
:fun(tokenize_isSymbol_LBRACK){
	y = x == 91 # [
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 18 # type 18
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("LBRACK ")
		}
	}
}
:fun(tokenize_isSymbol_RBRACK){
	y = x == 93 # ]
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 19 # type 19
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("RBRACK ")
		}
	}
}
:fun(tokenize_isSymbol_PERIOD){
	y = x == 46 # .
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 20 # type 20
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("PERIOD ")
		}
	}
}
:fun(tokenize_isSymbol_COMMA){
	y = x == 44 # ,
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 21 # type 16
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("COMMA ")
		}
	}
}
:fun(tokenize_isSymbol_SEMICOLON){
	y = x == 59 # ;
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 22 # type 22
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("SEMICOLON ")
		}
	}
}
:fun(tokenize_isSymbol_COLON){
	y = x == 58 # :
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 23 # type 23
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("COLON ")
		}
	}
}
:fun(tokenize_isSymbol_ASSIGN){
	y = x == 61 # =
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 0 # id 0
		:store(x,m)
		m = m + 2 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("ASSIGN ")
		}
	}
}
:fun(tokenize_isSymbol_EXCL){
	y = x == 33 # !
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 24 # type 24
		:store(x,m)
		m = m + 3 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("EXCL ")
		}
	}
}
:fun(tokenize_isSymbol_BITAND){
	y = x == 38 # &
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 28 # type 28
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("BITAND ")
		}
	}
}
:fun(tokenize_isSymbol_BITOR){
	y = x == 124 # |
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 29 # type 29
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("BITOR ")
		}
	}
}
:fun(tokenize_isSymbol_LT){
	y = x == 60 # <
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 32 # type 32
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("LT ")
		}
	}
}
:fun(tokenize_isSymbol_GT){
	y = x == 62 # >
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 33 # type 33
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("GT ")
		}
	}
}
:fun(tokenize_isSymbol_MUL){
	y = x == 42 # *
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 36 # type 36
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("MUL ")
		}
	}
}
:fun(tokenize_isSymbol_DIV){
	y = x == 47 # /
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 37 # type 37
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("DIV ")
		}
	}
}
:fun(tokenize_isSymbol_MOD){
	y = x == 37 # %
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 38 # type 38
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("MOD ")
		}
	}
}
:fun(tokenize_isSymbol_ADD){
	y = x == 43 # +
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 39 # type 39
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("ADD ")
		}
	}
}
:fun(tokenize_isSymbol_SUB){
	y = x == 45 # -
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 40 # type 40
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("SUB ")
		}
	}
}
:fun(tokenize_isSymbol_BITNOT){
	y = x == 126 # ~
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 43 # type 43
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("BITNOT ")
		}
	}
}
:fun(tokenize_isSymbol_BITXOR){
	y = x == 94 # ^
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 44 # type 44
		:store(x,m)
		m = m + 3 # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("BITXOR ")
		}
	}
}
:fun(tokenize_isConstant){
	:call(tokenize_isConstant_false)
	:if(f){
		:call(tokenize_isConstant_true)
		:if(f){
			:call(tokenize_isConstant_char)
			:if(f){
				:call(tokenize_isConstant_int)
				:if(f){
					:call(tokenize_isConstant_string)
					:if(f){
						:call(tokenize_isConstant_null)
					}
				}
			}
		}
	}
}
:fun(tokenize_isConstant_true){
	:load(p,i)
	z = i + 1
	:load(q,z)
	z = z + 1
	:load(r,z)
	z = z + 1
	:load(s,z)
	z = z + 1
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	z = p == 116 # t 
	y = y & z
	z = q == 114 # r
	y = y & z
	z = r == 117 # u
	y = y & z
	z = s == 101 # e
	y = y & z
	:if(y){
		i = i + 4
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (constant(bool))
		:store(x,m)
		m = m + 1
		x = 1
		:store(x,m)
		m = m + 1 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("CBOOL(1) ")
		}
	}
}
:fun(tokenize_isConstant_null){
	:load(p,i)
	z = i + 1
	:load(q,z)
	z = z + 1
	:load(r,z)
	z = z + 1
	:load(s,z)
	z = z + 1
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	z = p == 110 # n
	y = y & z
	z = q == 117 # u
	y = y & z
	z = r == 108 # l
	y = y & z
	z = s == 108 # l
	y = y & z
	:if(y){
		i = i + 4
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 4 # id 4 (constant(voidptr))
		:store(x,m)
		m = m + 1
		x = 0
		:store(x,m)
		m = m + 1
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("NULL ")
		}
	}
}
:fun(tokenize_isConstant_false){
	:load(p,i)
	z = i + 1
	:load(q,z)
	z = z + 1
	:load(r,z)
	z = z + 1
	:load(s,z)
	z = z + 1
	:load(t,z)
	z = z + 1
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	z = p == 102 # f 
	y = y & z
	z = q == 97 # a
	y = y & z
	z = r == 108 # l
	y = y & z
	z = s == 115 # s
	y = y & z
	z = t == 101 # e
	y = y & z
	:if(y){
		i = i + 5
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (constant(bool))
		:store(x,m)
		m = m + 1
		x = 0
		:store(x,m)
		m = m + 1 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("CBOOL(0) ")
		}
	}
}
:fun(tokenize_isConstant_char){
	:load(p,i)
	z = i + 1
	:load(q,z)
	x = q
	:call(isValidChar)
	x = p == 39 # '
	y = y & x
	:if(y){
		z = z + 1
		y = q == 92 # \
		:if(y){
			:load(x,z)
			:call(convertEscapableChar)
			w = y
			z = z + 1
			:load(p,z)
			y = p == 39 # '
			:if(y){
				i = i + 4
				f = 0 # set flag
				x = 3 # type 3
				:store(x,m)
				m = m + 1
				x = 1 # id 1 (constant(char))
				:store(x,m)
				m = m + 1
				x = w
				:store(x,m)
				m = m + 1 # skip optional field
				x = l # line number
				:store(x,m)
				m = m + 1
				:if(d){
					:raw("CCHAR(")
					:call(putint)
					:raw(") ")
				}
			} else {
				:call(errorInvalidCharConstant)
			}
		} else {
			:load(r,z)
			y = r == 39 # '
			:if(y){
				i = i + 3
				f = 0 # set flag
				x = 3 # type 0
				:store(x,m)
				m = m + 1
				x = 1 # id 1 (constant(char))
				:store(x,m)
				m = m + 1
				x = q
				:store(x,m)
				m = m + 1 # skip optional field
				x = l # line number
				:store(x,m)
				m = m + 1
				:if(d){
					:raw("CCHAR(")
					:call(putint)
					:raw(") ")
				}
			} else {
				:call(errorInvalidCharConstant)
			}
		}
	}
}
:fun(tokenize_isConstant_int){
	w = i
	:load(x,i)
	y = x => 48 # 0
	u = x =< 57 # 9
	y = y & u
	v = x == 48 # 0
	:if(y){
		z = 0
		:while(y){
			z = z * 10
			y = z < 0
			:if(y){
				:call(errorConstantTooBig)
			}
			x = x - 48
			z = z + x
			i = i + 1
			:load(x,i)
			y = x => 48 # 0
			u = x =< 57 # 9
			y = y & u
			v = v & y
			:if(v){
				:call(errorLeadingZero)
			}
		}
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 0 # id 0 (constant(int))
		:store(x,m)
		m = m + 1
		x = z
		:store(x,m)
		m = m + 1 # skip optional field
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("CINT(")
			x = z
			:call(putint)
			:raw(") ")
		}
	} else {
		i = w
	}
}
:fun(tokenize_isConstant_string){
	:load(x,i)
	y = x == 34 # "
	:if(y){
		z = i
		:while(y){
			i = i + 1
			:load(x,i)
			y = x == 92 # \
			:if(y){
				i = i + 1
				:load(x,i)
				:call(convertEscapableChar)
				y = 1
			} else {
				:call(isValidChar)
				y = 1 - y
				:if(y){
					:call(errorInvalidCharInString)
				}
				y = x =! 34 # "
			}
		}
		i = i + 1 # move past "
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 3 # id 3 (constant(int))
		:store(x,m)
		m = m + 1
		x = z
		:store(x,m)
		m = m + 1
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("CSTRING(")
			:load(x,z)
			:putchar(x)
			z = z + 1
			y = 1
			:while(y){
				:load(x,z)
				z = z + 1
				:putchar(x)
				w = x == 92 # \
				:if(w){
					:load(x,z)
					z = z + 1
					:putchar(x)
				} else {
					w = x == 34 # "
					:if(w){
						y = 0
					}
				}
			}
			:raw(") ")
		}
	}
}
:fun(tokenize_isIdentifier){
	:load(x,i)
	z = i
	w = 0 # length
	y = x == 95 # _
	u = x => 65 # A
	v = x =< 90 # Z
	u = u & v
	y = y | u
	u = x => 97 # a
	v = x =< 122 # z
	u = u & v
	y = y | u
	:if(y){
		f = 0 # set match flag
		:while(y){
			w = w + 1
			i = i + 1
			:load(x,i)
			:call(tokenize_isKeyword_helper) # returns 1 in y if its NOT an identifier char
			y = 1 - y
		}
		f = 0 # set flag
		x = 2 # type 2
		:store(x,m)
		m = m + 1
		x = z # start of identifier
		:store(x,m)
		m = m + 1
		x = w # length of identifier
		:store(x,m)
		m = m + 1
		x = l # line number
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("IDENT(")
			w = z + w # end
			y = z < w
			:while(y){
				:load(x,z)
				:putchar(x)
				z = z + 1
				y = z < w
			}
			:raw(") ")
		}
	}
}
#
# Phase 0 - Read file
#
:fun(readFile){
	:getchar(x)
	:while(x){
		:store(x,m)
		m = m + 1
		:getchar(x)
	}
}
#
# Utility functions
#
:fun(push){
	:store(s,a)
	a = a - 1
}
:fun(pop){
	a = a + 1
	:load(s,a)
}
:fun(putint){
	s = y
	:call(push) # save y
	s = w
	:call(push) # save w
	s = z
	:call(push) # save z
	s = x
	:call(push) # save x
	y = x < 0
	:if(y){
		:raw("-")
		w = x * -1
	} else {
		w = x
	}
	y = 10
	x = w / y
	z = x > 0
	:while(z){
		y = y * 10
		x = w / y
		z = x > 0
	}
	y = y / 10
	:while(y){
		x = w / y
		x = x % 10
		x = x + 48
		:putchar(x)
		y = y / 10
	}
	:call(pop) # restore x
	x = s
	:call(pop) # restore z
	z = s
	:call(pop) # restore w
	w = s
	:call(pop) # restore y
	y = s
}
# input: x
# writes: y
:fun(convertEscapableChar){
	y = x == 110 # n
	:if(y){
		y = 10 # newline
	} else {
		y = x == 116 # t
		:if(y){
			y = 9 # tab
		} else {
			y = x == 39 # '
			:if(y){
				y = 39
			} else {
				y = x == 34 # "
				:if(y){
					y = 34
				} else {
					y = x == 92 # \
					:if(y){
						y = 92
					} else {
						:raw("Invalid escape sequence. Line ")
						x = l
						:call(putint)
						:raw("\n")
						x = 1
						:exit(x)
					}
				}
			}
		}
	}
}
:fun(isValidChar){
	y = x => 32 # space
	u = x =< 126 # ~
	y = y & u
}
:fun(debug_printTokenIds){
	i = b
	c = i < e
	:while(c){
		:load(x,i)
		:call(putint)
		:raw(" ")
		i = i + 4
		c = i < e
	}
}
:fun(debug_printType){
	:load(u,x)
	y = u =! 1
	:if(y){
		x = u
		:call(putint)
		x = -30
		:call(errorPrintLine)
	}
	u = x + 1
	:load(u,u)
	y = u == 0 # int
	:if(y){
		:raw("int")
	} else {
		y = u == 1 # char
		:if(y){
			:raw("char")
		} else {
			y = u == 2 # bool
			:if(y){
				:raw("bool")
			} else {
				y = u == 3 # void
				:if(y){
					:raw("void")
				} else {
					y = u == 4 # array
					:if(y){
						:raw("arr(")
						u = x + 3
						:load(u,u) # load token addr
						u = u + 2
						:load(u,u) # load const value
						v = x
						x = u
						:call(putint)
						:raw(", ")
						x = v
						u = x + 2 # basetype
						:load(x,u)
						:call(debug_printType)
						:raw(")")
					} else {
						y = u == 5
						:if(y){
							:raw("ptr(")
							u = x + 2 # basetype
							:load(x,u)
							:call(debug_printType)
							:raw(")")
						} else {
							y = u == 6
							:if(y){
								u = x + 2 # basetype
								:load(u,u)
								v = u + 2 # length
								:load(v,v)
								u = u + 1 # start
								:load(u,u)
								v = u + v
								y = u < v
								:while(y){
									:load(x,u)
									:putchar(x)
									u = u + 1
									y = u < v
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(debug_printTypes){
	:raw("\nTypes:\n")
	i = e
	c = i < g
	:while(c){
		:load(x,i)
		y = x == 0 # declaration
		:if(y){
			:raw("DECL [ ")
		}
		u = x == 3 # function
		:if(u){
			v = i + 3
			:load(v,v)
			v = v =! 1 # end
			u = u & v
		}
		:if(u){
			:raw("FUN [ ")
		}
		y = y | u
		u = x == 4 # parameter
		:if(u){
			:raw("PAR [ ")
		}
		y = y | u
		:if(y){
			z = i + 1
			:load(x,z)
			:call(debug_printType)
			:raw(" ] ")
		} else {
			y = x == 2 # expression
			z = i + 1
			:load(x,z)
			y = x == 30 # cast expression
			:if(y){
				:raw("CAST [ ")
				z = i + 3
				:load(x,z)
				:call(debug_printType)
				:raw(" ] ")
			}
		}
		i = i + 4
		c = i < g
	}
}
:fun(debug_printExpressions){
	:raw("\nExpressions:\n")
	i = e
	c = e < g
	:while(c){
		:load(x,i)
		y = x == 0
		:if(y){ # declaration
			x = i + 2
			:load(x,x)
			y = x =! -1
			:if(y){
				:raw("INIT[ ")
				:call(debug_printExpression)
				:raw(" ] ")
			}
		} else {
			y = x == 5
			:if(y){ # return
				x = i + 1
				:load(x,x)
				:raw("RET[ ")
				:call(debug_printExpression)
				:raw(" ] ")
			} else {
				y = x == 6
				:if(y){ # expression stmt
					x = i + 1
					:load(x,x)
					:raw("EXP[ ")
					:call(debug_printExpression)
					:raw(" ] ")
				} else {
					y = x == 7
					:if(y){ # assign
						x = i + 2
						:load(x,x)
						:raw("ASS[ ")
						:call(debug_printExpression)
						:raw(" ]=[ ")
						x = i + 3
						:load(x,x)
						:call(debug_printExpression)
						:raw(" ] ")
					} else {
						y = x == 8
						:if(y){
							x = i + 1
							:load(x,x)
							y = x == 0 # if
							:if(y){
								x = i + 2
								:load(x,x)
								:raw("IF[ ")
								:call(debug_printExpression)
								:raw(" ] ")
							}
						} else {
							y = x == 9
							:if(y){
								x = i + 1
								:load(x,x)
								y = x == 0 # start
								:if(y){
									x = i + 2
									:load(x,x)
									:raw("WHILE[ ")
									:call(debug_printExpression)
									:raw(" ] ")
								}
							}
						}
					}
				}
			}
		}
		i = i + 4
		c = i < g
	}
}
:fun(debug_printExpressionExtra){
	y = u == 10 # call expression
	:if(y){
		u = 1
		:while(u){
			x = x - 4
			:load(y,x)
			y = y == 10
			:if(y){
				y = x + 1
				:load(y,y)
				:if(y){ # y : 0start, 1end
					u = u + 1
				} else {
					u = u - 1
				}
			}
		}
		:raw("CALL(")
		u = x + 2 # expr1 (token)
		:load(u,u) # load token addr
		:load(y,u) # check if its an ident
		y = y =! 2
		:if(y){
			x = -44
			:call(errorPrintLine)
		}
		v = x
		x = u
		:call(printIdent)
		x = v
		:raw(")[ ")
		u = 1
		v = 0
		:while(u){
			x = x + 4
			:load(z,x)
			y = z == 10
			:if(y){
				y = x + 1
				:load(y,y)
				:if(y){ # y : 0start, 1end
					:if(v){
						v = v - 1
					} else {
						u = 0
					}
				} else {
					v = v + 1
				}
			} else {
				y = z == 11
				z = v == 0
				y = y & z
				:if(y){
					s = x
					:call(push)
					x = x + 1
					:load(x,x)
					:call(debug_printExpression)
					:call(pop)
					x = s
					:raw(", ")
				}
			}
		}
		:raw(" ]")
	} else {
		y = u == 11 # argument
		:if(y){

		} else {			
			x = -40
			:call(errorPrintLine)
		}
	}
}
:fun(debug_printPrefix){
	y = u == 2
	:if(y){
		:raw("++")
	} else {
		y = u == 3
		:if(y){
			:raw("--")
		} else {
			y = u == 4
			:if(y){
				:raw("+")
			} else {
				y = u == 5
				:if(y){
					:raw("-")
				} else {
					y = u == 27
					:if(y){
						:raw("~")
					} else {
						y = u == 28
						:if(y){
							:raw("&")
						} else {
							y = u == 29
							:if(y){
								:raw("*")
							} else {
								y = u == 30
								:if(y){
									:raw("cast")
								} else {
									:raw("!")
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(debug_printExpression){
	:load(u,x)
	y = u =! 2 # check if its an expression
	:if(y){
		:call(debug_printExpressionExtra)
	} else {
		u = x + 1
		:load(u,u)
		y = u == 0
		:if(y){ # postfix ++
			:raw("(")
			x = x + 2 # expr1
			:load(x,x)
			:call(debug_printExpression)
			:raw("++")
			:raw(")")
		} else {
			y = u == 1
			:if(y){ # postfix --
				:raw("(")
				x = x + 2 # expr1
				:load(x,x)
				:call(debug_printExpression)
				:raw("--")
				:raw(")")
			} else {
				y = u => 2
				v = u =< 6
				y = y & v
				v = u => 27
				z = u =< 30
				v = v & z
				y = y | v
				:if(y){ # prefix
					:raw("(")
					x = x + 2 # expr1
					:load(x,x)
					:call(debug_printPrefix)
					:call(debug_printExpression)
					:raw(")")
				} else {
					y = u => 7
					v = u =< 21
					y = y & v
					v = u == 26
					y = y | v
					:if(y){ # binop
						:raw("(")
						x = x + 2 # expr1
						s = x + 1 # expr2
						:call(push) # push expr2
						s = u # op
						:call(push) # push op
						:load(x,x)
						:call(debug_printExpression)
						:call(pop) # pop op
						y = s == 7
						:if(y){
							:raw("*")
						} else {
							y = s == 8
							:if(y){
								:raw("/")
							} else {
								y = s == 9
								:if(y){
									:raw("%")
								} else {
									y = s == 10
									:if(y){
										:raw("+")
									} else {
										y = s == 11
										:if(y){
											:raw("-")
										} else {
											y = s == 12
											:if(y){
												:raw("<")
											} else {
												y = s == 13
												:if(y){
													:raw(">")
												} else {
													y = s == 14
													:if(y){
														:raw("<=")
													} else {
														y = s == 15
														:if(y){
															:raw(">=")
														} else {
															y = s == 16
															:if(y){
																:raw("==")
															} else {
																y = s == 17
																:if(y){
																	:raw("!=")
																} else {
																	y = s == 18
																	:if(y){
																		:raw("&")
																	} else {
																		y = s == 19
																		:if(y){
																			:raw("|")
																		} else {
																			y = s == 20
																			:if(y){
																				:raw("&&")
																			} else {
																				y = s == 26
																				:if(y){
																					:raw("^")
																				} else {
																					:raw("||")
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
						:call(pop) # pop expr2
						:load(x,s)
						:call(debug_printExpression)
						:raw(")")
					} else {
						y = u == 22
						:if(y){ # ident
							u = x + 2 # expr1 (token)
							:load(x,u) # load token addr
							:load(u,x)
							y = u =! 2
							:if(y){
								x = -42
								:call(errorPrintLine)
							}
							:call(printIdent)
						} else {
							y = u == 23
							:if(y){ # const
								u = x + 2 # expr1 (token)
								:load(x,u) # load token addr
								:load(u,x)
								y = u =! 3
								:if(y){
									x = -43
									:call(errorPrintLine)
								}
								u = x + 2
								:load(x,u)
								:call(putint)
							} else {
								y = u == 24
								:if(y){ # array
									:raw("(")
									x = x + 2 # expr1
									s = x + 1 # expr2
									:call(push)
									:load(x,x)
									:call(debug_printExpression)
									:raw("[")
									:call(pop)
									:load(x,s)
									:call(debug_printExpression)
									:raw("])")
								} else {
									y = u == 25
									:if(y){ # component
										:raw("(")
										x = x + 2 # expr1
										s = x + 1 # expr2
										:call(push)
										:load(x,x)
										:call(debug_printExpression)
										:raw(".")
										:call(pop)
										:load(x,s)
										:call(printIdent)
										:raw(")")
									} else {
										y = u == 31 # pointer component
										:if(y){
											:raw("(")
											x = x + 2 # expr1
											s = x + 1 # expr2
											:call(push)
											:load(x,x)
											:call(debug_printExpression)
											:raw("->")
											:call(pop)
											:load(x,s)
											:call(printIdent)
											:raw(")")
										}
									}
								}
							}
						}
					}
				}
			}
		}	
	}
}
:fun(printIdent){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = y
	:call(push)
	u = x + 1
	:load(u,u) # start
	v = x + 2
	:load(v,v) # length
	v = u + v
	y = u < v
	:while(y){
		:load(x,u)
		:putchar(x)
		u = u + 1
		y = u < v
	}
	:call(pop)
	y = s
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
# input: x,y
# output: y
:fun(identEquals){
	s = t
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = z
	:call(push)
	##
	z = 0
	:if(z){
		z = x
		:raw(" ( ")
		:call(printIdent)
		:raw(" ")
		x = y
		:call(printIdent)
		:raw(" ) ")
		x = z
	}
	##
	u = x + 2 # ident1 length
	:load(u,u)
	v = y + 2 # ident2 length
	:load(v,v)
	z = u == v
	:if(z){
		x = x + 1 # ident1 start
		:load(x,x)
		y = y + 1 # ident2 start
		:load(y,y)
		t = 0 # counter
		z = u # length
		u = t < z
		:while(u){
			u = x + t
			:load(u,u)
			v = y + t
			:load(v,v)
			u = u == v
			:if(u){
				t = t + 1
				u = t < z
			}
		}
		y = t == z
	} else {
		y = 0
	}
	:call(pop)
	z = s
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	t = s
}
#
# Errors
#
:fun(errorExpectedX){
	:raw("Expected ")
	:putchar(x)
	:raw(", found token type ")
	:load(x,i)
	:call(putint)
	:raw(". ")
	x = i + 3
	:load(x,x)
	:call(errorPrintLine)
}
:fun(errorUnmatchedToken){
	:raw("Unmatched token (type ")
	:load(x,i)
	:call(putint)
	:raw("). ")
	x = i + 3
	:load(x,x)
	:call(errorPrintLine)
}
:fun(errorEOFcomment){
	:raw("EOF reached while parsing comment.")
	x = 1
	:exit(x)
}
:fun(errorInvalidCharConstant){
	:raw("Invalid char constant. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorLeadingZero){
	:raw("Invalid int constant (leading zeros). ")
	x = l
	:call(errorPrintLine)
}
:fun(errorConstantTooBig){
	:raw("Invalid int constant (too big). ")
	x = l
	:call(errorPrintLine)
}
:fun(errorInvalidCharInString){
	:raw("Invalid char encountered in string literal. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorUnmatchedChar){
	:raw("Unmatched char '")
	:load(x,i)
	:putchar(x)
	:raw("' in file. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorPrintLine){
	:raw("Line ")
	:call(putint)
	:raw("\n")
	x = 1
	:exit(x)
}
