:fun(main){
	d = 1 # debug
	:if(d){
		:raw("/*\n")
	}
	a = 20000 # stack pointer
	:call(readFile)
	b = m
	:call(tokenize)
	# c = condition, d = debug, so next var is e
	e = m
	:call(syntax)
	# f = flag
	g = m
	:if(d){
		:call(debug_printExpressions)
		:call(debug_printTypes)
	}
	:call(semantics)
	h = m
	:call(memory)
	j = m
	:if(d){
		:raw("\nPhase 5 - Code generation\n*/\n")
	}
	:call(codegen)
}
#
# Phase 5 - Code generation
#
:fun(codegen){
	i = e
	y = i g <
	c = 0
	q = 0 # function flag
	f = 0 1 - # current function ident
	:raw(".syntax\tunified\n\n.text\n.align\t1\n\n")
	:while(y){
		:load(x,i)
		y = x 5 == # return
		:if(y){
			x = i 1 +
			:load(x,x)
			y = x 0 1 - =!
			:if(y){
				y = 1
				:call(codegen_expression)
			}
			:raw("\tb\tFE")
			x = f
			:call(printIdent)
			:raw("\n")
		} else {
			y = x 6 == # expression statement
			:if(y){
				x = i 1 +
				:load(x,x)
				y = 1
				:call(codegen_expression)
			} else {
				y = x 7 == # assignment
				:if(y){
					:call(codegen_assign)
				} else {
					y = x 8 == # if/else
					:if(y){
						x = i 1 +
						:load(x,x)
						y = x 0 == # if
						:if(y){
							#:raw("IF")
							x = i 2 + # expr
							:load(x,x)
							:call(codegen_expression)
							:raw("\tcmp\tr0,#0\n\tbeq\tLneg_")
							x = c
							:call(putint)
							:raw("\n")
							s = c
							:call(push)
							c = c 1 +
							s = 1 # flag to print neg label
							:call(push)
						} else {
							y = x 1 == # else
							:if(y){
								#:raw("ELSE")
								:call(pop)
								:call(pop)
								x = s
								:raw("\tb\tLend_")
								:call(putint)
								:raw("\nLneg_")
								:call(putint)
								:raw(":\n")
								s = x
								:call(push)
								s = 0
								:call(push)
							} else {
								#:raw("ENDIF")
								:call(pop)
								y = s
								:call(pop)
								x = s
								:if(y){
									:raw("Lneg_")
									:call(putint)
									:raw(":\n")
								}
								:raw("Lend_")
								:call(putint)
								:raw(":\n")
							}
						}
					} else {
						y = x 9 == # while
						:if(y){
							x = i 1 +
							:load(x,x)
							y = x 0 == # start
							:if(y){
								:raw("Lcond_")
								x = c
								c = c 1 +
								:call(putint)
								:raw(":\n")
								s = x
								:call(push)
								x = i 2 + # cond
								:load(x,x)
								:call(codegen_expression)
								:raw("\tcmp\tr0,#0\n\tbeq\tLend_")
								x = a 1 +
								:load(x,x)
								:call(putint)
								:raw("\n")
							} else {
								:raw("\tb\tLcond_")
								:call(pop)
								x = s
								:call(putint)
								:raw("\nLend_")
								:call(putint)
								:raw(":\n")
							}
						} else {
							y = x 3 == # function
							:if(y){
								x = i 3 +
								:load(x,x)
								y = x 0 == # start
								:if(y){
									q = 1
									x = i 2 +
									:load(x,x)
									:call(codegen_isMain)
									:if(y){
										:raw(".global\t_start\n_start:\n\tadd\tr2,sp,#4\n\tstr\tr2,[sp,#-4]\n\tsub\tsp,sp,#4\n\tbl\tFmain\n\tmov\tr7,#1\n\tsvc\t0\n")
									}
									:raw("\n.global F")
									:call(printIdent)
									:raw("\nF")
									:call(printIdent)
									f = x
									:raw(":\n")
									x = i 4 + # function end pointer
									:load(x,x)
									u = x 2 + # frame size
									:load(u,u)
									v = x 4 + # params size
									:load(v,v)
									v = u v -
									:raw("\tldr\tr1,=")
									x = v
									:call(putint)
									:raw("\n\tsub\tsp,sp,r1\n\tstr\tfp,[sp,#4]\n\tstr\tlr,[sp]\n\tldr\tr1,=")
									x = u
									:call(putint)
									:raw("\n\tadd\tfp,sp,r1\n")
								} else {
									y = x 1 == # end
									y = y q &
									:if(y){
										:raw("\tmov\tr0,#0\nFE")
										x = f
										:call(printIdent)
										:raw(":\n\tldr\tfp,[sp,#4]\n\tldr\tlr,[sp]\n")
										x = i 2 + # frame size
										:load(x,x)
										:raw("\tldr\tr1,=")
										:call(putint)
										:raw("\n\tadd\tsp,sp,r1\n\tbx\tlr\n")
										q = 0
									}
								}
							} else {
								:call(codegen_extra)
							}
						}
					}
				}
			}
		}
		i = i 5 +
		y = i g <
	}
	:call(codegen_dataseg)
}
:fun(codegen_extra){
	y = x 0 == # declaration
	u = i 2 + # expr
	:load(x,u)
	y = y x 0 1 - =! & # declaration has expression (x != -1)
	:if(y){
		y = 1
		:call(codegen_expression)
		x = i 4 +
		:load(x,x)
		y = x 0 =!
		:if(y){
			:raw("\tldr\tr1,=")
			:call(putint)
			:raw("\n\tsub\tr1,fp,r1\n")
		} else {
			:raw("\tldr\tr1,=V")
			x = i 3 + # ident
			:load(x,x)
			:call(printIdent)
			:raw("\n")
		}
		x = i 1 +
		:load(x,x)
		:call(memory_getTypeSize)
		u = y 1 ==
		:if(u){
			:raw("\tstrb\tr0,[r1]\n")
		} else {
			u = y 4 ==
			:if(u){
				:raw("\tstr\tr0,[r1]\n")
			} else {
				:throw("Internal error.\n")
				x = 1
				:exit(x)
			}
		}
	}
}
:fun(codegen_assign){
	x = i 2 + # expr1
	:load(v,x)
	x = v
	y = 0
	:call(codegen_expression)
	:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
	x = i 3 + # expr2
	:load(x,x)
	y = 1
	:call(codegen_expression)
	x = v 4 + # expression type
	:load(x,x)
	:call(memory_getTypeSize)
	v = y
	x = i 1 + # type of assignment
	:load(x,x)
	y = x 0 ==
	:raw("\tldr\tr1,[sp],#4\n")
	:if(y){
		y = v 1 ==
		:if(y){
			:raw("\tstrb\tr0,[r1]\n")
		} else {
			y = v 4 ==
			:if(y){
				:raw("\tstr\tr0,[r1]\n")
			} else {
				:throw("Internal error.\n")
				x = 1
				:exit(x)
			}
		}
	} else {
		y = x 1 == # +=
		:if(y){
			y = v 1 ==
			:if(y){
				:raw("\tldrb\tr2,[r1]\n\tadd\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
			} else {
				y = v 4 ==
				:if(y){
					:raw("\tldr\tr2,[r1]\n\tadd\tr0,r2,r0\n\tstr\tr0,[r1]\n")
				} else {
					:throw("Internal error. ")
					x = 1
					:exit(x)
				}
			}
		} else {
			y = x 2 == # -=
			:if(y){
				y = v 1 ==
				:if(y){
					:raw("\tldrb\tr2,[r1]\n\tsub\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
				} else {
					y = v 4 ==
					:if(y){
						:raw("\tldr\tr2,[r1]\n\tsub\tr0,r2,r0\n\tstr\tr0,[r1]\n")
					} else {
						:throw("Internal error.\n")
						x = 1
						:exit(x)
					}
				}
			} else {
				y = x 3 == # /=
				:if(y){
					y = v 1 ==
					:if(y){
						:raw("\tldrb\tr2,[r1]\n\tsdiv\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
					} else {
						y = v 4 ==
						:if(y){
							:raw("\tldr\tr2,[r1]\n\tsdiv\tr0,r2,r0\n\tstr\tr0,[r1]\n")
						} else {
							:throw("Internal error.\n")
							x = 1
							:exit(x)
						}
					}
				} else {
					y = x 4 == # *=
					:if(y){
						y = v 1 ==
						:if(y){
							:raw("\tldrb\tr2,[r1]\n\tmul\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
						} else {
							y = v 4 ==
							:if(y){
								:raw("\tldr\tr2,[r1]\n\tmul\tr0,r2,r0\n\tstr\tr0,[r1]\n")
							} else {
								:throw("Internal error.\n")
								x = 1
								:exit(x)
							}
						}
					}
				}
			}
		}
	}
}
:fun(codegen_dataseg){
	:raw("\n.data\n")
	i = h
	y = i j <
	:while(y){
		:load(u,i)
		:load(x,u)
		y = x 3 == # string literal
		:if(y){
			x = u 3 +
			:load(x,x)
			:raw("S")
			:call(putint)
			:raw(": .asciz ")
			u = u 2 + # start
			:load(u,u)
			:load(x,u)
			:putchar(x)
			u = u 1 +
			y = 1
			:while(y){
				:load(x,u)
				:putchar(x)
				u = u 1 +
				y = x 34 =! # "
			}
		} else {
			y = x 0 == # declaration
			:if(y){
				x = u 1 + # declaration type
				:load(x,x)
				v = x 1 + # type type
				:load(v,v)
				:call(memory_getTypeSize)
				w = y
				x = u 3 + # ident
				:raw("V")
				:load(x,x)
				:call(printIdent)
				y = v 6 == v 4 == | # name | array
				:if(y){
					:raw(": .space ")
					x = w
					:call(putint)
				} else {
					y = w 1 ==
					:if(y){
						:raw(": .byte ")
					} else {
						y = w 4 ==
						:if(y){
							:raw(": .word ")
						} else {
							:throw("Internal error.\n")
							x = 1
							:exit(x)
						}
					}
					x = u 2 + # expression
					:load(x,x)
					x = x 2 + # expr1
					:load(x,x)
					y = x 1 + # constant type
					:load(y,y)
					y = y 3 == # string literal
					:if(y){
						x = x 3 + # string id
						:raw("S")
					} else {
						x = x 2 + # value
					}
					:load(x,x)
					:call(putint)
				}
			} else {
				:throw("Internal error.\n")
				:call(errint)
				x = 1
				:exit(x)
			}		
		}
		:raw("\n")
		i = i 1 +
		y = i j <
	}
}
# x expression, y 0noload, 1load
# expressions 0,1,2,3,24,25,28
:fun(codegen_expression){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = y
	:call(push)
	:load(u,x)
	y = u 2 == # expression
	:if(y){
		u = x 1 +
		:load(u,u)
		# Postfix increment - Prefix decrement, array access, component access, pointer &
		y = u 0 => u 3 =< & u 24 == | u 25 == | u 28 == |
		:if(y){
			v = x
			x = x 2 +
			:load(x,x)
			y = 0
			:call(codegen_expression) # result is in r0
			x = v 
			y = u 0 == # postf ++
			:if(y){
				x = x 4 + # type
				:load(x,x)
				y = x 1 +
				:load(y,y)
				y = y 5 == # pointer
				:if(y){
					y = x 2 + # basetype
					:load(x,y)
					:call(memory_getTypeSize)
					:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\n\tadd\tr2,r1,r2\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
				} else {
					:call(memory_getTypeSize)
					u = y 1 ==
					:if(u){
						:raw("\tldrb\tr1,[r0]\n\tadd\tr2,r1,#1\n\tstrb\tr2,[r0]\n\tmov\tr0,r1\n")
					} else {
						u = y 4 ==
						:if(u){
							:raw("\tldr\tr1,[r0]\n\tadd\tr2,r1,#1\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
						} else {
							:throw("Internal error.\n")
							x = 1
							:exit(x)
						}
					}
				}
			} else {
				y = u 1 == # postf --
				:if(y){
					x = x 4 + # type
					:load(x,x)
					y = x 1 +
					:load(y,y)
					y = y 5 == # pointer
					:if(y){
						y = x 2 + # basetype
						:load(x,y)
						:call(memory_getTypeSize)
						:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
						x = y
						:call(putint)
						:raw("\nsub\tr2,r1,r2\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
					} else {
						:call(memory_getTypeSize)
						u = y 1 ==
						:if(u){
							:raw("\tldrb\tr1,[r0]\n\tsub\tr2,r1,#1\n\tstrb\tr2,[r0]\n\tmov\tr0,r1\n")
						} else {
							u = y 4 ==
							:if(u){
								:raw("\tldr\tr1,[r0]\n\tsub\tr2,r1,#1\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
							} else {
								:throw("Internal error.\n")
								x = 1
								:exit(x)
							}
						}
					}
				} else {
					y = u 2 == # pref ++
					:if(y){
						x = x 4 + # type
						:load(x,x)
						y = x 1 +
						:load(y,y)
						y = y 5 == # pointer
						:if(y){
							y = x 2 + # basetype
							:load(x,y)
							:call(memory_getTypeSize)
							:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
							x = y
							:call(putint)
							:raw("\n\tadd\tr1,r1,r2\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
						} else {
							:call(memory_getTypeSize)
							u = y 1 ==
							:if(u){
								:raw("\tldrb\tr1,[r0]\n\tadd\tr1,r1,#1\n\tstrb\tr1,[r0]\n\tmov\tr0,r1\n")
							} else {
								u = y 4 ==
								:if(u){
									:raw("\tldr\tr1,[r0]\n\tadd\tr1,r1,#1\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
								} else {
									:throw("Internal error.\n")
									x = 1
									:exit(x)
								}
							}
						}
					} else {
						y = u 3 == # pref --
						:if(y){
							x = x 4 + # type
							:load(x,x)
							y = x 1 +
							:load(y,y)
							y = y 5 == # pointer
							:if(y){
								y = x 2 + # basetype
								:load(x,y)
								:call(memory_getTypeSize)
								:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
								x = y
								:call(putint)
								:raw("\nsub\tr1,r1,r2\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
							} else {
								:call(memory_getTypeSize)
								u = y 1 ==
								:if(u){
									:raw("\tldrb\tr1,[r0]\n\sub\tr1,r1,#1\n\tstrb\tr1,[r0]\n\tmov\tr0,r1\n")
								} else {
									u = y 4 ==
									:if(u){
										:raw("\tldr\tr1,[r0]\n\tsub\tr1,r1,#1\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
									} else {
										:throw("Internal error.\n")
										x = 1
										:exit(x)
									}
								}
							}
						} else {
							y = u 24 == # array access
							:if(y){
								v = x 2 + # expr1
								:load(v,v)
								v = v 4 + # expr1 type
								:load(v,v)
								v = v 1 +
								:load(v,v)
								v = v 5 == # pointer
								:if(v){ # load pointer value
									:raw("\tldr\tr0,[r0]\n")
								}
								:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
								v = x 4 + # expression type
								:load(v,v)
								x = x 3 +
								:load(x,x)
								:call(codegen_expression)
								x = v
								:call(memory_getTypeSize)
								x = y
								:raw("\tldr\tr1,=")
								:call(putint)
								:raw("\n\tmul\tr0,r0,r1\n\tldr\tr1,[sp],#4\n\tadd\tr0,r1,r0\n")
								x = a 1 +
								:load(x,x)
								:if(x){
									u = y 1 ==
									:if(u){
										:raw("\tldrb\tr0,[r0]\n")
									} else {
										u = y 4 ==
										:if(u){
											:raw("\tldr\tr0,[r0]\n")
										} else {
											:throw("Internal error.\n")
											x = 1
											:exit(x)
										}
									}
								}
							} else {
								y = u 25 == # component access
								:if(y){
									v = x
									x = x 3 + # component
									:load(x,x)
									x = x 4 + # calculated offset
									:load(x,x)
									:raw("\tldr\tr1,=")
									:call(putint)
									:raw("\n\tadd\tr0,r0,r1\n")
									y = a 1 +
									:load(y,y)
									:if(y){
										x = v 4 +
										:load(x,x)
										:call(memory_getTypeSize)
										u = y 1 ==
										:if(u){
											:raw("\n\tldrb\tr0,[r0]\n")
										} else {
											u = y 4 ==
											:if(u){
												:raw("\n\tldr\tr0,[r0]\n")
											} else {
												:throw("Internal error.\n")
												x = 1
												:exit(x)
											}
										}
									}
								} else {
									y = u 28 == # pointer &
									:if(y){
										# no need to do anything, inner expression already called with y=1
									}
								}
							}
						}
					}
				}
			}
		} else {
			:call(codegen_expression_2)
		}
	} else {
		:call(codegen_call)
	}
	:call(pop)
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
# expressions 4-21,26,27,29,30
:fun(codegen_expression_2){
	# unop +, unop -, unop !, unop ~, unop *, cast
	y = u 4 == u 5 == | u 6 == | u 27 == | u 29 == | u 30 == |
	:if(y){
		v = x
		x = x 2 + # expr1
		:load(x,x)
		y = 1
		:call(codegen_expression)
		y = u 30 == # cast
		:if(y){
			x = v 4 + # type
			:load(x,x)
			x = x 1 + # type type
			:load(x,x)
			y = x 1 == # char
			:if(y){
				:raw("\tmov\tr1,#256\n\tsdiv\tr2,r0,r1\n\tmls\tr0,r2,r1,r0\n")
			}
		} else {
			y = u 5 == # -
			:if(y){
				:raw("\tmov\tr1,#-1\n\tmul\tr0,r0,r1\n")
			} else {
				y = u 6 == # !
				:if(y){
					:raw("\teor\tr0,r0,#1\n")
				} else {
					y = u 27 == # ~
					:if(y){
						:raw("\tmvn\tr0,r0\n")
					} else { # *
						y = a 1 +
						:load(y,y)
						:if(y){
							x = x 4 +
							:load(x,x)
							x = x 2 +
							:load(x,x)
							:call(memory_getTypeSize)
							x = y 1 ==
							:if(x){
								:raw("\tldrb\tr0,[r0]\n")
							} else {
								x = y 4 ==
								:if(x){
									:raw("\tldr\tr0,[r0]\n")
								} else {
									:throw("Internal error. ")
									x = 1
									:exit(x)
								}
							}
						}
					}
				}
			}
		}
	} else {
		# binop * - binop ||, ^
		y = u 7 => u 21 =< & u 26 == |
		:if(y){
			v = x
			x = v 2 +
			:load(x,x)
			y = 1
			:call(codegen_expression)
			:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
			x = v 3 +
			:load(x,x)
			y = 1
			:call(codegen_expression)
			:raw("\tldr\tr1,[sp],#4\n")
			y = u 7 == # binop *
			:if(y){
				:raw("\tmul\tr0,r1,r0\n")
			} else {
				y = u 8 == # binop /
				:if(y){
					:raw("\tsdiv\tr0,r1,r0\n")
				} else {
					y = u 9 == # binop %
					:if(y){
						:raw("\tsdiv\tr2,r1,r0\n\tmls\tr0,r2,r0,r1\n")
					} else {
						y = u 10 == # binop +
						:if(y){
							x = v 4 + # expression type
							:load(x,x)
							x = x 1 +
							:load(x,x)
							y = x 5 == # pointer
							:if(y){
								x = v 2 +
								:load(x,x)
								x = x 4 +
								:load(x,x)
								u = x 1 +
								:load(u,u)
								y = u 5 ==
								:if(y){ # expr1 is pointer
									x = x 2 + # basetype
									:load(x,x)
									:call(memory_getTypeSize)
									:raw("\tldr\tr2,=")
									x = y
									:call(putint)
									:raw("\n\tmul\tr0,r0,r2\n")
								} else { # expr2 is pointer
									x = v 3 + # expr2
									:load(x,x)
									x = x 4 + # type
									:load(x,x)
									x = x 2 + # basetype
									:load(x,x)
									:call(memory_getTypeSize)
									:raw("\tldr\tr2,=")
									x = y
									:call(putint)
									:raw("\n\tmul\tr1,r1,r2\n")
								}
							}
							:raw("\tadd\tr0,r1,r0\n")
						} else {
							y = u 11 == # binop -
							:if(y){
								x = v 4 + # expression type
								:load(x,x)
								x = x 1 +
								:load(x,x)
								y = x 5 == # pointer
								:if(y){
									x = v 2 +
									:load(x,x)
									x = x 4 +
									:load(x,x)
									u = x 1 +
									:load(u,u)
									y = u 5 ==
									:if(y){ # expr1 is pointer
										x = x 2 + # basetype
										:load(x,x)
										:call(memory_getTypeSize)
										:raw("\tldr\tr2,=")
										x = y
										:call(putint)
										:raw("\n\tmul\tr0,r0,r2\n")
									} else { # expr2 is pointer
										x = v 3 + # expr2
										:load(x,x)
										x = x 4 + # type
										:load(x,x)
										x = x 2 + # basetype
										:load(x,x)
										:call(memory_getTypeSize)
										:raw("\tldr\tr2,=")
										x = y
										:call(putint)
										:raw("\n\tmul\tr1,r1,r2\n")
									}
								}
								:raw("\tsub\tr0,r1,r0\n")
								x = v 4 + # expression type
								:load(u,x)
								x = u 1 +
								:load(x,x)
								y = x 0 == # int
								x = v 2 + # expr1
								:load(x,x)
								x = x 4 + # expr1 type
								:load(u,x)
								x = u 1 + # type type
								:load(x,x)
								y = y x 5 == & # result is int, but operands are pointer
								:if(y){
									x = u 2 +
									:load(x,x)
									:call(memory_getTypeSize)
									:raw("\tldr\tr1,=")
									x = y
									:call(putint)
									:raw("\n\tsdiv\tr0,r0,r1\n")
								}
							} else {
								:call(codegen_expression_2andahalf)
							}
						}
					}
				}
			}
		} else {
			:call(codegen_expression_3)
		}
	}
}
:fun(codegen_expression_2andahalf){
	y = u 12 == # binop <
	:if(y){
		:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovlt\tr0,#1\n")
	} else {
		y = u 13 == # binop >
		:if(y){
			:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovgt\tr0,#1\n")
		} else {
			y = u 14 == # binop <=
			:if(y){
				:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovle\tr0,#1\n")
			} else {
				y = u 15 == # binop >=
				:if(y){
					:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovge\tr0,#1\n")
				} else {
					y = u 16 == # binop ==
					:if(y){
						:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmoveq\tr0,#1\n")
					} else {
						y = u 17 == # binop !=
						:if(y){
							:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovne\tr0,#1\n")
						} else {
							# binop &, binop &&
							y = u 18 == u 20 == |
							:if(y){
								:raw("\tand\tr0,r1,r0\n")
							} else {
								# binop |, binop ||
								y = u 19 == u 21 == |
								:if(y){
									:raw("\torr\tr0,r1,r0\n")
								} else {
									y = u 26 == # binop ^
									:if(y){
										:raw("\teor\tr0,r1,r0\n")
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(codegen_expression_3){
	y = u 31 == # pointer component
	:if(y){
		v = x
		x = v 2 + # expr1
		:load(x,x)
		y = 1
		:call(codegen_expression)
		x = v 3 + # component
		:load(x,x)
		x = x 4 + # calculated offset
		:load(x,x)
		:raw("\tldr\tr1,=")
		:call(putint)
		x = a 1 +
		:load(x,x)
		:if(x){
			x = v 4 +
			:load(x,x)
			:call(memory_getTypeSize)
			u = y 1 ==
			:if(u){
				:raw("\n\tldrb\tr0,[r0,r1]\n")
			} else {
				u = y 4 ==
				:if(u){
					:raw("\n\tldr\tr0,[r0,r1]\n")
				} else {
					:throw("Internal error.\n")
					x = 1
					:exit(x)
				}
			}
		} else {
			:raw("\n\tadd\tr0,r0,r1\n")
		}
	} else {
		y = u 23 == # const
		:if(y){
			x = x 2 +
			:load(x,x)
			v = x 1 +
			:load(v,v)
			y = v 3 == # string
			:if(y){
				:raw("\tldr\tr0,=S")
				x = x 3 +
				:load(x,x)
				:call(putint)
				:raw("\n")
			} else {
				:raw("\tldr\tr0,=")
				x = x 2 + # value
				:load(x,x)
				:call(putint)
				:raw("\n")
			}
		} else {
			y = u 22 == # ident
			:if(y){
				x = x 3 + # corresponding declaration
				:load(x,x)
				v = x
				x = v 4 + # offset
				:load(x,x)
				y = x 0 1 - =!
				:if(y){
					:raw("\tldr\tr0,=")
					:call(putint)
					:raw("\n\tsub\tr0,fp,r0\n")
				} else {
					:raw("\tldr\tr0,=V")
					x = v 3 + # ident
					:load(x,x)
					:call(printIdent)
					:raw("\n")
				}
				y = a 1 +
				:load(y,y)
				:if(y){
					x = v 1 + # type
					:load(x,x)
					:call(memory_getTypeSize)
					x = y
					y = x 1 ==
					:if(y){
						:raw("\tldrb\tr0,[r0]\n")
					} else {
						y = x 4 ==
						:if(y){
							:raw("\tldr\tr0,[r0]\n")
						} else {
							:throw("Internal error.\n")
							x = 1
							:exit(x)
						}
					}
				}
			} else {
				y = u 32 == # sizeof
				x = x 2 + # expr
				:load(x,x)
				:call(memory_getTypeSize)
				:raw("\tldr\tr0,=")
				x = y
				:call(putint)
				:raw("\n")
			}
		}
	}
}
:fun(codegen_call){
	s = c
	:call(push)
	s = z
	:call(push)
	z = x 3 +
	:load(z,z) # call start addr
	s = z 2 +
	:load(s,s) # function decl addr
	s = s 2 +
	:load(s,s) # ident addr
	:call(push)
	#:call(putint)
	#:raw("halo ")
	z = z 5 +
	:load(x,z)
	u = z 1 +
	:load(u,u)
	c = 0
	y = x 10 =! u 1 =! | # x != call | u != end
	:while(y){
		y = x 11 == c 0 == & # arg
		:if(y){
			x = z 1 +
			:load(x,x)
			v = x 4 + # expression type
			:load(v,v)
			:call(codegen_expression)
			x = v
			:call(memory_getTypeSize)
			x = y 1 ==
			:if(x){
				:raw("\tsub\tsp,sp,#1\n\tstrb\tr0,[sp]\n")
			} else {
				x = y 4 ==
				:if(x){
					:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
				} else {
					:throw("Internal error.\n")
					x = 1
					:exit(x)
				}
			}
		} else {
			y = x 10 == # call
			:if(y){
				x = z 1 +
				:load(x,x)
				y = x 0 == # start
				:if(y){
					c = c 1 +
				} else {
					c = c 1 -
				}
			}
		}
		z = z 5 +
		:load(x,z)
		u = z 1 +
		:load(u,u)
		y = x 10 =! u 1 =! | c 0 > | # x != call | u != end | c > 0
	}
	:raw("\tbl\tF")
	:call(pop)
	x = s
	:call(printIdent)
	:raw("\n")
	:call(pop)
	z = s
	:call(pop)
	c = s
}
:fun(codegen_isMain){
	s = x
	:call(push)
	s = u
	:call(push)
	u = x 2 +
	:load(u,u)
	y = u 4 == # len(main)
	:if(y){
		x = x 1 +
		:load(x,x)
		:load(u,x)
		y = u 109 == # m
		u = x 1 +
		:load(u,u)
		u = u 97 == # a
		y = y u &
		u = x 2 +
		:load(u,u)
		u = u 105 == # i
		y = y u &
		u = x 3 +
		:load(u,u)
		u = u 110 == # n
		y = y u &
	}
	:call(pop)
	u = s
	:call(pop)
	x = s
}
#
# Phase 4 - Memory
#
:fun(memory){
	:if(d){
		:raw("Phase 4 - Memory\n")
	}
	i = e
	y = i g <
	c = 0 # string counter
	f = 0 # function flag
	o = 0 # declaration offset
	p = 0 # struct flag
	r = 0 # param offset
	:while(y){
		:load(x,i)
		u = i 1 +
		:load(u,u)
		y = x 2 == u 23 == & # expression & constant 
		:if(y){
			x = i 2 +
			:load(x,x)
			u = x 1 +
			:load(u,u)
			y = u 3 == # string
			:if(y){
				u = x 3 +
				:store(c,u) # override line no. with string id
				:store(x,m)
				m = m 1 +
				:if(d){
					x = x 2 +
					:load(x,x)
					:load(u,x)
					:putchar(u)
					x = x 1 +
					:load(u,x)
					y = u 34 =! # "
					:while(y){
						y = u 92 == # \
						:if(y){
							:putchar(u)
							x = x 1 +
							:load(u,x)
						}
						:putchar(u)
						x = x 1 +
						:load(u,x)
						y = u 34 =! # "
					}
					:putchar(u)
					:raw("(")
					x = c
					:call(putint)
					:raw(") ")
				}
				c = c 1 +
			}
		} else {
			y = x 0 == # declaration
			:if(y){
				y = f 0 == # not in a function
				:if(y){
					:store(i,m)
					m = m 1 +
				} else { # decl in function
					x = i
					:call(memory_getSize)
					o = o y +
					x = y
					:call(putint)
					:if(d){
						x = i 3 +
						:load(x,x)
						:call(printIdent)
						:raw("(")
						x = o
						:call(putint)
						:raw(") ")
					}
					x = i 4 +
					:store(o,x) # use free space to write offset
				}
			} else {
				y = x 4 == # parameter
				:if(y){
					y = p 0 ==
					:if(y){ # function param
						x = i
						:call(memory_getSize)
						r = r y +
						o = o y +
						x = i 4 + # same offset as declaration
						:store(o,x)
						:if(d){
							x = i 2 +
							:load(x,x)
							:call(printIdent)
							:raw("(")
							x = o
							:call(putint)
							:raw(") ")
						}
					} else { # struct param
						x = i
						:call(memory_getSize)
						:if(d){
							x = i 2 +
							:load(x,x)
							:call(printIdent)
							:raw("(")
							x = o
							:call(putint)
							:raw(") ")
						}
						x = i 4 + # same offset
						:store(o,x)
						o = o y +
					}
				} else {
					y = x 3 == # function
					:if(y){
						:if(f){ # funcion end
							x = i 2 +
							o = 8 o + # 8 bytes for 2 ints (RA,FP)
							:store(o,x)
							x = i 4 + # extra space
							:store(r,x) # size of parameters
							:raw("]\n ")
						} else {
							x = i 2 +
							:load(x,x)
							:raw("\n")
							:call(printIdent)
							:raw("[ ")
						}
						o = 0
						r = 0
						f = 1 f -
					} else {
						y = x 12 == # struct
						:if(y){
							:if(p){ # struct end
								:call(pop)
								o = s
							} else { # struct start
								s = o
								:call(push)
								o = 0
							}
							p = 1 p -
						}
					}
				}
			}
		}
		i = i 5 +
		y = i g <
	}
}
# input: x (syntax token)
# output: y (size in bytes)
:fun(memory_getSize){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	:load(u,x)
	# u != decl & u != param & u != struct
	y = u 0 =! u 4 =! & u 12 =! &
	:if(y){
		:throw("[Memory getSize] Invalid argument.\n")
		x = 1
		:exit(x)
	}
	y = u 0 == u 4 == | # u == decl | u == param
	:if(y){ # decl/param
		x = x 1 +
		:load(x,x) # type addr
		:call(memory_getTypeSize)
	} else { 
		u = x 3 + # precalculated size (perhaps)
		:load(u,u)
		y = u 0 1 - ==
		:if(y){
			s = x 3 +
			:call(push)
			u = x 5 +
			:load(x,u)
			y = x 12 =!
			v = 0
			:while(y){
				y = x 4 == # parameter
				:if(y){
					x = u 1 +
					:load(x,x) # type addr
					:call(memory_getTypeSize)
					v = v y +	
				}
				u = u 5 +
				:load(x,u)
				y = x 12 =!
			}
			:call(pop)
			:store(v,s)
			y = v
		} else {
			y = u
		}
	}
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
:fun(memory_getTypeSize){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	:load(u,x)
	y = u 1 =!
	:if(y){
		:throw("[Memory getTypeSize] invalid arguments.\n")
		x = 1
		:exit(x)
	}
	u = x 1 +
	:load(u,u)
	y = u 0 == u 5 == | # int | pointer
	:if(y){
		y = 4
	} else {
		y = u 1 == u 2 == | u 3 == | # char | bool | boid
		:if(y){
			y = 1
		} else {
			y = u 4 == # array
			:if(y){
				u = x 3 +
				:load(u,u) # const token address
				u = u 2 + # value
				:load(s,u)
				:call(push)
				x = x 2 + # basetype
				:load(x,x)
				:call(memory_getTypeSize)
				:call(pop)
				y = y s *
			} else {
				y = u 6 == # name
				:if(y){
					x = x 2 +
					:load(x,x)
					:call(memory_getSize)
				}
			}
		}
	}
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
#
# Phase 3 - Semantic analisys
#
:fun(semantics){
	:if(d){
		:raw("\nPhase 3 - Semantic analisys\n")
	}
	:call(semantics_nameResolver)
	m = g # the memory pointer can be reset to the initial position
	:call(semantics_typeResolver)
}
:fun(semantics_typeResolver){
	# h will be used for address resolving
	:call(semantics_typeResolver_validateStructsAndArrays)
	i = e
	y = i g <
	:while(y){
		:load(x,i)
		:call(semantics_typeResolver_checkVoid)
		h = 0 # reset addrresolver flag
		y = x 0 == # declaration
		:if(y){
			x = i 2 +
			:load(x,x)
			y = x 0 1 - =! # initialization
			:if(y){
				s = i 3 + # ident
				:load(s,s)
				s = s 3 + # line no
				:load(l,s)
				x = i 1 + # type
				:load(s,x)
				x = s 1 +
				:load(x,x)
				y = x 4 == # array
				:if(y){
					:throw("Cannot initialize array ")
					x = i 3 + # ident
					:load(x,x)
					:call(errorIdent)
					:throw(". ")
					x = x 3 + # line no.
					:load(x,x)
					:call(errorPrintLine)
				}
				y = x 6 == # struct
				:if(y){
					:throw("Cannot initialize struct ")
					x = i 3 + # ident
					:load(x,x)
					:call(errorIdent)
					:throw(". ")
					x = x 3 + # line no.
					:load(x,x)
					:call(errorPrintLine)
				}
				:call(push)
				x = i 2 + # expression
				:load(x,x)
				:call(semantics_typeResolver_resolveExpression)
				:call(pop)
				x = s
				y = m 1 -
				:load(y,y)
				:call(semantics_typeResolver_equals)
				y = y 0 ==
				:if(y){
					:throw("Types must be equal. ")
					x = l
					:call(errorPrintLine)
				}
			}
		} else {
			y = x 3 == # function
			:if(y){
				x = i 3 + # start/end/decl
				:load(x,x)
				y = x 0 ==
				:if(y){
					x = i 1 +
					:load(f,x) # load f with type of current function
				}
			} else {
				y = x 5 == # return
				:if(y){
					x = i 1 +
					:load(x,x)
					y = x 0 1 - ==
					:if(y){
						x = 3
						y = 0
						:call(semantics_typeResolver_createType)
						x = f
						y = m 5 -
						:call(semantics_typeResolver_equals)
					} else {
						:call(semantics_typeResolver_resolveExpression)
						y = m 1 -
						:load(y,y)
						x = f
						:call(semantics_typeResolver_equals)
					}
					y = y 0 ==
					:if(y){
						:throw("Expression in return must match with function type. ")
						x = l
						:call(errorPrintLine)
					}
				} else {
					y = x 6 == # expression statement
					:if(y){
						x = i 1 +
						:load(x,x)
						:call(semantics_typeResolver_resolveExpression)
					} else {
						y = x 7 == # assignment
						:if(y){
							:call(semantics_typeResolver_assignments)
						} else {
							y = x 8 == # if
							:if(y){
								x = i 1 +
								:load(x,x)
								y = x 0 == # if
								:if(y){
									x = i 2 +
									:load(x,x)
									:call(semantics_typeResolver_resolveExpression)
									u = m 1 -
									x = 2
									y = 0
									:call(semantics_typeResolver_createType)
									x = m 5 -
									:load(y,u)
									:call(semantics_typeResolver_equals)
									y = y 0 ==
									:if(y){
										:throw("Expression in if must be a boolean. ")
										x = l
										:call(errorPrintLine)
									}
								}
							} else {
								y = x 9 == # while
								:if(y){
									x = i 1 +
									:load(x,x)
									y = x 0 == # start
									:if(y){
										x = i 2 +
										:load(x,x)
										:call(semantics_typeResolver_resolveExpression)
										u = m 1 -
										x = 2
										y = 0
										:call(semantics_typeResolver_createType)
										x = m 5 -
										:load(y,u)
										:call(semantics_typeResolver_equals)
										y = y 0 ==
										:if(y){
											:throw("Expression in while must be a boolean. ")
											x = l
											:call(errorPrintLine)
										}
									}
								}
							}
						}
					}
				}
			}
		}
		i = i 5 +
		y = i g <
	}
}
# x type, y basetype
:fun(semantics_typeResolver_createType){
	m = m 1 +
	:store(x,m) # type id
	m = m 1 -
	x = 1 # type
	:store(x,m) # memory cell type (1)
	m = m 2 +
	:store(y,m) # basetype
	m = m 3 + # skip two
}
# 0-6,27
:fun(semantics_typeResolver_resolveExpression){
	s = u
	:call(push)
	s = v
	:call(push)
	s = x
	:call(push)
	s = y
	:call(push)
	:load(u,x)
	y = u 2 =! u 10 =! & # expression & call
	:if(y){
		:throw("[ResolveExpression] Invalid input. ")
		x = l
		:call(errorPrintLine)
	}
	v = u 10 == # call
	:if(v){
		:call(semantics_typeResolver_resolveCall)
	} else {
		u = x 1 +
		:load(u,u)
		y = u 0 => u 3 =< & # postincrement, postdecrement, preincrement, predecrement
		:if(y){
			u = x 2 +
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			y = h 0 ==
			:if(y){
				:throw("[increment/decrement] Expression must be an Lvalue. ")
				x = l
				:call(errorPrintLine)
			}
			h = 0
			u = m 1 -
			:load(x,u) # load address of type
			x = x 1 +
			:load(x,x) # load type type
			# x != int & x != char & x != ptr
			y = x 0 =! x 1 =! & x 5 =! &
			:if(y){
				:throw("[increment/decrement] Expression must be of type int, char or pointer. ")
				x = l
				:call(errorPrintLine)
			}
			# operator doesnt change the type
		} else {
			# prefix + | prefix - | prefix ~ (bitwise negation)
			y = u 4 == u 5 == | u 27 == |
			:if(y){
				u = x 2 +
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				h = 0
				u = m 1 -
				:load(x,u) # load address of type
				x = x 1 +
				:load(x,x) # load type type
				y = x 0 =! # int
				:if(y){
					:throw("[Prefix +,-,~] Expression must be of type int. ")
					x = l
					:call(errorPrintLine)
				}
				# operator doesnt change the type
			} else {
				y = u 6 == # boolean negate
				:if(y){
					u = x 2 +
					:load(x,u)
					:call(semantics_typeResolver_resolveExpression)
					h = 0
					u = m 1 -
					:load(x,u) # load address of type
					x = x 1 +
					:load(x,x) # load type type
					y = x 2 =! # bool
					:if(y){
						:throw("[Prefix !] Expression must be of type bool. ")
						x = l
						:call(errorPrintLine)
					}
					# operator doesnt change the type
				} else {
					:call(semantics_typeResolver_resolveExpression_extra_outer)
				}
			}
		}
	}
	:call(pop)
	y = s
	:call(pop)
	x = s
	u = m 1 -
	:load(u,u)
	v = x 4 +
	:store(u,v)
	:call(pop)
	v = s
	:call(pop)
	u = s
}
:fun(semantics_typeResolver_resolveCall){
	# x,y,v,u are already saved
	s = k
	:call(push)
	s = p
	:call(push)
	s = c
	:call(push)
	# x has call address (end)
	x = x 3 +
	:load(x,x)
	k = x 2 + # function pointer
	:load(k,k)
	:load(u,k)
	y = u 3 =!
	:if(y){
		u = k 3 +
		:load(x,u)
		:call(errorIdent)
		:throw(" is not a function. ")
		x = l
		:call(errorPrintLine)
	}
	u = x # call iterator
	v = k # function iterator
	c = 1
	y = 1
	:while(y){
		y = 1
		:while(y){
			u = u 5 +
			:load(x,u)
			p = x 10 == # call
			:if(p){
				p = u 1 +
				:load(p,p)
				p = p 1 ==
				:if(p){ # end
					c = c 1 -
				} else { #start
					c = c 1 +
				}
			}
			y = c 1 == x 11 =! & c 1 > | # argument
		}
		y = 1
		:while(y){ # skip all non parameter/function end block
			v = v 5 +
			:load(s,v)
			y = s 3 =! s 4 =! & # s != function & s != parameter
		}
		y = x 10 == 
		:if(y){ # call end
			y = s 3 =! 
			:if(y){ # parameter
				:throw("Parameter count must match in function calls. ")
				x = l
				:call(errorPrintLine)
			} else { # function end
				y = 0 # no more parameters/arguments
			}
		} else { # argument
			y = s 4 ==
			:if(y){ # parameter
				x = u 1 +
				:load(x,x)
				:call(semantics_typeResolver_resolveExpression)
				h = 0
				x = m 1 - # argument type
				:load(x,x)
				y = v 1 + # parameter type
				:load(y,y)
				:call(semantics_typeResolver_equals)
				y = y 0 ==
				:if(y){
					:throw("Parameter type must match in function calls. ")
					x = l
					:call(errorPrintLine)
				}
				y = 1
			} else { # function end
				:throw("Parameter count must match in function calls. ")
				x = l
				:call(errorPrintLine)
			}
		}
	}
	k = k 1 +
	:load(k,k)
	:store(k,m)
	m = m 1 +
	:call(pop)
	c = s
	:call(pop)
	p = s
	:call(pop)
	k = s
	# x,y,v,u will get restored
}
# 7-15,18,19,26
:fun(semantics_typeResolver_resolveExpression_extra_outer){
	# *,/,%,&,|,^
	y = u 7 => u 9 =< & u 18 == | u 19 == | u 26 == |
	:if(y){ # *,/,%,&,|,^
		u = x 2 +
		v = x 3 +
		:load(x,u)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		s = m 1 -
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		u = m 1 -
		:load(x,u) # load address of type2
		x = x 1 +
		:load(x,x) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		y = y 1 +
		:load(y,y) # load type1 type
		y = x y =! y 0 =! | # same type or int
		:if(y){
			:throw("[ Binop *,/,%,&,|,^ ] Operator must have 2 expressions of type int. ")
			x = l
			:call(errorPrintLine)
		}
		# operator doesnt change the type
	} else {
		y = u 10 == u 11 == | # binop +,-
		:if(y){
			# save whether its subtraction on the stack so we know later
			s = u 11 ==
			:call(push)
			u = x 2 +
			v = x 3 +
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			h = 0
			s = m 1 -
			:call(push)
			:load(x,v)
			:call(semantics_typeResolver_resolveExpression)
			h = 0
			u = m 1 -
			:load(x,u) # load address of type2
			x = x 1 +
			:load(x,x) # load type2 type
			:call(pop)
			:load(s,s) # load address of type
			y = s 1 +
			:load(y,y) # load type1 type
			v = x 0 == # int
			:if(v){
				# y != int & y != char & y != ptr
				v = y 0 =! y 1 =! & y 5 =! &
				:if(v){
					:throw("[ Binop +,- ] One expression must be int, the other can be int, char or pointer. ")
					x = l
					:call(errorPrintLine)
				}
				# copy type of first expression, which carries over
				:store(s,m)
				m = m 1 +
			} else {
				v = y 0 == # int
				:if(v){
					# x != int & x != char & x != ptr
					v = x 0 =! x 1 =! & x 5 =! &
					:if(v){
						:throw("[ Binop +,- ] One expression must be int, the other can be int, char or pointer. ")
						x = l
						:call(errorPrintLine)
					}
					# type ok, 2nd expression carries over
				} else {
					y = a 1 +
					:load(y,y) # look on the stack if it is subtraction
					v = x 5 == x 1 == | y & # x == char | x == ptr
					y = 0
					:if(v){
						:load(x,u)
						y = s
						:call(semantics_typeResolver_equals)
					}
					:if(y){
						x = 0
						y = 0
						:call(semantics_typeResolver_createType)
						x = m 5 -
						:store(x,m)
						m = m 1 +
					} else {
						:throw("[ Binop +,- ] One expression must be int, the other can be int, char or pointer. ")
						x = l
						:call(errorPrintLine)
					}
				}
			}
			:call(pop)
		} else {
			# binop <,>,<=,>=
			y = u 12 => u 15 =< &
			:if(y){
				u = x 2 +
				v = x 3 +
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				h = 0
				s = m 1 -
				:call(push)
				:load(x,v)
				:call(semantics_typeResolver_resolveExpression)
				h = 0
				u = m 1 -
				:load(x,u) # load address of type2
				x = x 1 +
				:load(x,x) # load type2 type
				:call(pop)
				:load(y,s) # load address of type
				y = y 1 +
				:load(y,y) # load type1 type
				x = x y =! # same type
				:if(x){
					:throw("[ <,>,<=,>= ] Operator must have 2 expressions of same type (int, char, pointer). ")
					x = l
					:call(errorPrintLine)
				} else {
					# not int, char or ptr
					x = y 0 =! y 1 =! & y 5 =! &
					:if(x){
						:throw("[ <,>,<=,>= ] Operator must have 2 expressions of same type (int, char, pointer). ")
						x = l
						:call(errorPrintLine)
					}
				}
				x = 2
				y = 0
				:call(semantics_typeResolver_createType)
				x = m 5 -
				:store(x,m)
				m = m 1 +
			} else {
				:call(semantics_typeResolver_resolveExpression_outofideas)
			}
		}
	}
}
# 16,17,20,21,22
:fun(semantics_typeResolver_resolveExpression_outofideas){
	y = u 16 == u 17 == | # == or !=
	:if(y){
		u = x 2 +
		v = x 3 +
		:load(x,u)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		s = m 1 -
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		u = m 1 -
		:load(x,u) # load address of type2
		x = x 1 +
		:load(x,x) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		y = y 1 +
		:load(y,y) # load type1 type
		# same type or one of array, void, struct 
		x = x y =! y 4 == | y 3 == | y 6 == |
		:if(x){
			:throw("[ ==,!= ] Operator must have 2 expressions of same type (int, bool, char, pointer). ")
			x = l
			:call(errorPrintLine)
		}
		x = 2
		y = 0
		:call(semantics_typeResolver_createType)
		x = m 5 -
		:store(x,m)
		m = m 1 +
	} else {
		y = u 20 == u 21 == | # && or ||
		:if(y){
			u = x 2 +
			v = x 3 +
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			h = 0
			s = m 1 -
			:call(push)
			:load(x,v)
			:call(semantics_typeResolver_resolveExpression)
			h = 0
			u = m 1 -
			:load(x,u) # load address of type2
			x = x 1 +
			:load(x,x) # load type2 type
			:call(pop)
			:load(y,s) # load address of type
			y = y 1 +
			:load(y,y) # load type1 type
			y = x y =! y 2 =! | # not same type or not bool
			:if(y){
				:throw("[ &&,|| ] Operator must have 2 expressions of type bool. ")
				x = l
				:call(errorPrintLine)
			}
			# type doesnt change
		} else {
			y = u 22 == # ident
			:if(y){
				u = x 2 + # ident token
				:load(u,u)
				u = u 3 + # line no.
				:load(u,u)
				l = u # keep l updated for error messages
				u = x 3 + # declaration location
				:load(u,u)
				:load(y,u)
				y = y 3 == # function
				:if(y){
					x = x 2 +
					:load(x,x)
					:call(errorIdent)
					:throw(" is a function, not a variable. ")
					x = l
					:call(errorPrintLine)
				}
				h = 1
				u = u 1 + # type
				:load(u,u)
				:store(u,m)
				m = m 1 +
			} else {
				:call(semantics_typeResolver_resolveExpression_extra)
			}
		}
	}
}
# 23,24,25
:fun(semantics_typeResolver_resolveExpression_extra){
	y = u 23 == # const
	:if(y){
		u = x 2 + # const token
		:load(u,u)
		v = u 3 + # line no.
		:load(l,v) # keep current line updated
		v = u 1 +
		:load(v,v)
		y = v 0 == v 1 == | v 2 == | # int, char, bool
		:if(y){
			x = v
			y = 0
			:call(semantics_typeResolver_createType)
			x = m 5 -
			:store(x,m)
			m = m 1 +
		}  else {
			y = v 3 == # char*
			:if(y){
				x = 1
				y = 0
				:call(semantics_typeResolver_createType)
				x = 5
				y = m 5 -
				:call(semantics_typeResolver_createType)
				x = m 5 -
				:store(x,m)
				m = m 1 +
			} else {
				y = v 4 == # void*
				:if(y){
					x = 3
					y = 0
					:call(semantics_typeResolver_createType)
					x = 5
					y = m 5 -
					:call(semantics_typeResolver_createType)
					x = m 5 -
					:store(x,m)
					m = m 1 +
				}
			}
		}
	} else {
		y = u 24 == # array
		:if(y){
			u = x 2 +
			v = x 3 +
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			s = m 1 -
			:call(push)
			y = h 0 ==
			:if(y){
				:throw("[ Indexing ] Base expression must be Lvalue. ")
				x = l
				:call(errorPrintLine)
			}
			:load(x,v)
			:call(semantics_typeResolver_resolveExpression)
			u = m 1 -
			:load(x,u) # load address of type2
			x = x 1 +
			:load(x,x) # load type2 type
			:call(pop)
			:load(y,s) # load address of type
			y = y 1 +
			:load(y,y) # load type1 type
			v = y 4 =! y 5 =! & x 0 =! & # not array & not pointer & not int
			:if(v){
				:throw("[ Indexing ] Base expression must be of type array or pointer, index must be type int. ")
				x = l
				:call(errorPrintLine)
			}
			h = 1
			:load(y,s)
			y = y 2 + # basetype
			:load(y,y)
			:store(y,m)
			m = m 1 +
		} else {
			y = u 25 == # component
			:if(y){
				u = x 2 +
				v = x 3 +
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				u = m 1 -
				:load(x,u) # load address of type2
				y = h 0 ==
				:if(y){
					:throw("[ Component ] Base expression must be Lvalue. ")
					x = l
					:call(errorPrintLine)
				}
				x = x 1 +
				:load(y,x) # load type2 type
				y = y 6 == # struct
				:if(y){
					x = x 1 +
					:load(x,x) # struct declaration
					:load(u,v) # load address of ident
					j = x
					y = 1
					w = 1
					:while(y){
						j = j 5 +
						:load(x,j)
						y = x 4 == # parameter
						:if(y){
							x = j 2 +
							:load(x,x)
							y = u
							:call(identEquals)
							:if(y){
								w = 0
								x = j 1 +
								:load(x,x)
								:store(x,m)
								:store(j,v)
								m = m 1 +
							}
						}
						y = x 12 =! # struct
					}
					:if(w){
						:throw("Struct does not contain component ")
						x = u
						:call(errorIdent)
						:throw(". ")
						x = l
						:call(errorPrintLine)
					}
					h = 1
				} else {
					:throw("Base expression must be type struct. ")
					x = l
					:call(errorPrintLine)
				}
			} else {
				:call(semantics_typeResolver_resolveExpression_extra_inner)
			}
		}
	}
}
# 28,29,30,31
:fun(semantics_typeResolver_resolveExpression_extra_inner){
	y = u 28 == # prefix & (pointer)
	:if(y){
		u = x 2 +
		:load(x,u)
		:call(semantics_typeResolver_resolveExpression)
		y = h 0 ==
		:if(y){
			:throw("Cannot take address (expression must be Lvalue). ")
			x = l
			:call(errorPrintLine)
		}
		h = 0
		u = m 1 -
		:load(y,u) # load as basetype
		x = 5 # pointer
		:call(semantics_typeResolver_createType)
		x = m 5 -
		:store(x,m)
		m = m 1 +
	} else {
		y = u 29 == # prefix * (dereference)
		:if(y){
			u = x 2 +
			:load(x,u)
			:call(semantics_typeResolver_resolveExpression)
			u = m 1 -
			:load(x,u)
			y = x 1 +
			:load(y,y)
			y = y 5 == # pointer
			:if(y){
				y = x 2 + #basetype
				:load(y,y)
				:store(y,m)
				m = m 1 +
				h = 1
			} else {
				:throw("Expression must be a pointer. ")
				x = l
				:call(errorPrintLine)
			}
		} else {
			y = u 30 == # cast
			:if(y){
				u = x 2 +
				v = x 3 +
				:load(x,u)
				:call(semantics_typeResolver_resolveExpression)
				u = m 1 -
				:load(u,u) # load address of type
				u = u 1 +
				:load(u,u) # load expression type
				:load(x,v) # load address of cast type
				y = x 1 +
				:load(y,y) # load type1 type
				# y = bool,void,array,struct or u = bool,void,array,struct
				v = y 2 == y 3 == | y 4 == | y 6 == | u 2 == | u 3 == | u 4 == | u 6 == |
				:if(v){
					:throw("Cast expression can contain types int, char and pointer. ")
					x = l
					:call(errorPrintLine)
				}
				h = 0
				:store(x,m)
				m = m 1 +
			} else {
				y = u 31 == # pointer component
				:if(y){
					u = x 2 +
					v = x 3 +
					:load(x,u)
					:call(semantics_typeResolver_resolveExpression)
					u = m 1 -
					:load(x,u) # load address of type2
					x = x 1 +
					:load(y,x) # load type2 type
					s = x 1 + # basetype
					:load(x,s)
					s = x 1 + # type type
					:load(s,s)
					y = y 5 == s 6 == & # struct pointer
					:if(y){
						x = x 2 +
						:load(x,x) # struct declaration
						:load(u,v) # load address of ident
						j = x
						y = 1
						w = 1
						:while(y){
							j = j 5 +
							:load(x,j)
							y = x 4 == # parameter
							:if(y){
								x = j 2 +
								:load(x,x)
								y = u
								:call(identEquals)
								:if(y){
									w = 0
									x = j 1 +
									:load(x,x)
									:store(x,m)
									:store(j,v)
									m = m 1 +
								}
							}
							y = x 12 =! # struct
						}
						:if(w){
							:throw("Struct does not contain component ")
							x = u
							:call(errorIdent)
							:throw(". ")
							x = l
							:call(errorPrintLine)
						}
						h = 1
					} else {
						:throw("Base expression must be type struct pointer. ")
						x = l
						:call(errorPrintLine)
					}		
				} else {
					y = u 32 == # sizeof
					:if(y){
						x = 0 # int
						y = 0
						:call(semantics_typeResolver_createType)
						x = m 5 -
						:store(x,m)
						m = m 1 +
					}
				}
			}
		}
	}
}
:fun(semantics_typeResolver_assignments){
	x = i 2 + # expr1
	:load(x,x)
	:call(semantics_typeResolver_resolveExpression)
	s = m 1 -
	:load(s,s)
	:call(push)
	y = h 0 ==
	:if(y){
		:throw("Left side of assignment must be an Lvalue. ")
		x = l
		:call(errorPrintLine)
	}
	h = 0 # reset addrresolver flag
	x = i 3 + # expr2
	:load(x,x)
	:call(semantics_typeResolver_resolveExpression)
	x = i 1 + # type of assignment
	:load(x,x)
	y = x 0 == # =
	:if(y){
		:call(pop)
		x = s
		y = m 1 -
		:load(y,y)
		:call(semantics_typeResolver_equals)
		y = y 0 ==
		:if(y){
			:throw("[ = ] Expressions in assignment need to have equal types. ")
			x = l
			:call(errorPrintLine)
		}
	} else {
		y = x 1 == x 2 == | # +=,-=
		:if(y){
			:call(pop)
			x = s 1 +
			:load(x,x)
			y = x 0 == # int
			:if(y){
				y = m 1 -
				:load(y,y)
				y = y 1 +
				:load(x,y)
				y = x 0 =! x 1 =! & # x not int or char
				:if(y){
					:throw("[ +=,-= ] Right side must be int or char. ")
					x = l
					:call(errorPrintLine)
				}
			} else {
				y = x 5 == # pointer
				:if(y){
					y = m 1 -
					:load(y,y)
					y = y 1 +
					:load(y,y)
					y = y 0 =!
					:if(y){
						:throw("[ +=,-= ] Right side must be int. ")
						x = l
						:call(errorPrintLine)
					}
				} else {
					y = x 1 =! # char
					:if(y){
						:throw("[ +=,-= ] Left side must be int, char or ptr. ")
						x = l
						:call(errorPrintLine)
					}
				}		
			}
		} else { # *=,/=
			y = m 1 -
			:load(y,y)
			y = y 1 +
			:load(y,y)
			:call(pop)
			x = s 1 +
			:load(x,x)
			y = y 0 =! x 0 =! |
			:if(y){
				:throw("[ /=,*= ] Both expressions have to be integers. ")
				x = l
				:call(errorPrintLine)
			}
		}
	}
}
# input: x,y
:fun(semantics_typeResolver_equals){
	s = u
	:call(push)
	s = v
	:call(push)
	s = x
	:call(push)
	:load(u,x)
	:load(v,y)
	u = u 1 =! v 1 =! |
	:if(u){
		:throw("[TypeEquals] Invalid input")
		x = l
		:call(errorPrintLine)
	}
	u = x 1 +
	:load(u,u)
	v = y 1 +
	:load(v,v)
	u = u v ==
	:if(u){ # are equal
		u = v 4 == # array
		:if(u){
			u = x 3 + # load length token
			:load(u,u)
			u = u 2 + # value
			:load(u,u)
			v = y 3 + # load length token
			:load(v,v)
			v = v 2 + # value
			:load(v,v)
			u = u v =!
			:if(u){
				y = 0
			} else {
				x = x 2 + # basetype
				:load(x,x)
				y = y 2 + # basetype
				:load(y,y)
				:call(semantics_typeResolver_equals)
			}
		} else {
			u = v 5 == # ptr
			:if(u){
				x = x 2 + # basetype
				:load(x,x)
				y = y 2 + # basetype
				:load(y,y)
				:call(semantics_typeResolver_equals)
			} else {
				u = v 6 == # name
				:if(u){ # compare decls here
					x = x 2 + # basetype
					:load(x,x)
					y = y 2 + # basetype
					:load(y,y)
					y = x y ==
				} else {
					y = 1
				}
			}
		}
	} else {
		y = 0
	}
	:call(pop)
	x = s
	:call(pop)
	v = s
	:call(pop)
	u = s
}
:fun(semantics_typeResolver_checkVoid){
	y = x 0 == # declaration
	:if(y){
		v = 3 # offset
	}
	u = x 4 == # parameter
	:if(u){
		v = 2 # offset
	}
	y = y u |
	:if(y){
		u = i 1 +
		:load(u,u) # load type address
		u = u 1 + 
		:load(u,u) # load type
		y = u 3 == # void
		:if(y){
			:throw("Variable or field ")
			x = i v + # ident
			:load(x,x)
			:call(errorIdent)
			:throw(" cannot be void. ")
			x = x 3 + # line no.
			:load(x,x)
			:call(errorPrintLine)
		}
	}
}
:fun(semantics_typeResolver_recursiveType){
	:load(u,x)
	y = u 1 =! # type
	:if(y){
		x = 0 20 -
		:call(errorPrintLine)
	}
	u = x 1 +
	:load(u,u)
	y = u 4 == # array
	:while(y){ # resolve type as long as its an array
		x = x 2 +
		:load(x,x)
		u = x 1 +
		:load(u,u)
		y = u 4 == # array
	}
	y = u 6 == # nametype
	:if(y){
		u = x 2 + # basetype
		:load(u,u) # should be address of struct declaration
		j = g
		y = j m <
		:while(y){
			:load(x,j)
			y = x u ==
			:if(y){
				:throw("Struct ")
				x = x 2 + # ident
				:load(x,x)
				:call(errorIdent)
				:throw(" cannot be recursive (use pointers!). ")
				x = x 3 + # line no.
				:load(x,x)
				:call(errorPrintLine)
			}
			j = j 1 +
			y = j m <
		}
		:store(u,m)
		m = m 1 +
		y = 1
		:while(y){
			u = u 5 +
			:load(x,u)
			y = x 4 == # parameter
			:if(y){
				x = u 1 + # parameter type
				:load(x,x)
				s = u
				:call(push)
				:call(semantics_typeResolver_recursiveType)
				:call(pop)
				u = s
				y = 1
			} else {
				y = x 12 =! # end of struct
			}
		}
	}
}
:fun(semantics_typeResolver_validateStructsAndArrays){
	i = e
	y = i g <
	:while(y){
		:load(x,i)
		y = x 12 == # struct
		u = i 1 +
		:load(u,u)
		u = u 0 ==
		y = y u &
		:if(y){
			:store(i,m)
			m = m 1 +
			f = 1 # parameter flag
			z = i
			:while(y){
				z = z 5 +
				:load(x,z)
				y = x 4 == # parameter (struct component)
				:if(y){
					f = 0
					x = z 1 + # parameter type
					:load(x,x)
					:call(semantics_typeResolver_recursiveType)
					y = 1
				} else {
					y = x 12 =! # end of struct
				}
			}
			:if(f){
				:throw("Struct ")
				x = m 1 -
				:load(x,x)
				x = x 2 + # ident
				:load(x,x)
				x = x 3 + # line no.
				:call(errorIdent)
				:throw(" cannot be empty. ")
				:load(x,x)
				:call(errorPrintLine)
			}
			m = m 1 -
		} else {
			u = i 1 +
			:load(u,u)
			y = x 1 == u 4 == & # x == type & u == array
			:if(y){
				x = i 3 + # const
				:load(x,x)
				u = x
				:load(x,u)
				x = u
				u = x 1 +
				:load(u,u)
				u = u 0 =! # int
				:if(u){
					:throw("Array length must be an int. ")
					x = x 3 +
					:load(x,x)
					:call(errorPrintLine)
				}
				u = x 2 + # value
				:load(u,u)
				u = u 0 ==
				:if(u){
					:throw("Array length cannot be 0. ")
					x = x 3 +
					:load(x,x)
					:call(errorPrintLine)
				}
				u = i 2 +
				:load(u,u)
				u = u 1 +
				:load(u,u)
				u = u 3 == # void
				:if(u){
					:throw("Array basetype cannot be void. ")
					x = x 3 +
					:load(x,x)
					:call(errorPrintLine)
				}
			} else {
				y = x 3 == # function
				:if(y){
					x = i 1 +
					:load(x,x)
					x = x 1 +
					:load(x,x)
					y = x 4 == x 6 == | # array or struct
					:if(y){
						:throw("Function return type cannot be array or struct. ")
						x = i 2 + # ident
						:load(x,x)
						x = x 3 + # line no
						:load(x,x)
						:call(errorPrintLine)
					} 
				}
			}
		}
		i = i 5 +
		y = i g <
	}
}
:fun(semantics_nameResolver){
	i = e
	y = i g <
	t = 0
	# First pass - global declarations
	:while(y){
		:load(x,i)
		y = x 3 == # function
		:if(y){
			x = i 2 +
			:load(x,x)
			p = x
			:call(semantics_nameResolver_getDeclaration)
			y = y 0 1 - =!
			:if(y){
				:throw("Name ")
				x = p
				:call(errorIdent)
				:throw(" already declared. ")
				x = p 3 +
				:load(x,x)
				:call(errorPrintLine)
			}
			:store(i,m)
			m = m 1 +
			:store(t,m)
			m = m 1 +
			y = 1
			:while(y){
				i = i 5 +
				:load(x,i)
				y = x 3 =! # skip function bodies on first pass
			}
		} else {
			u = i 1 +
			:load(u,u) # expression id
			# x == expr & u != const | u == call
			y = x 2 == u 23 =! & x 10 == |
			:if(y){
				:throw("Only constants allowed in global context. ")
				u = i 2 +
				:load(u,u)
				u = u 3 +
				:load(x,u)
				:call(errorPrintLine)
			}
			:call(semantics_nameResolver_handleDeclaration)
		}
		i = i 5 +
		y = i g <
	}
	i = e
	y = i g <
	t = 0
	:while(y){
		:load(x,i)
		y = x 3 == # function
		:if(y){
			c = i # flag: function reachable return ; in theory this could cause trouble if i = 0, but i think thats impossible
			x = i 3 +
			:load(x,x)
			y = x 2 == # is declaration?
			:if(y){
				c = 0
			}
			t = t 1 +
			s = m
			:call(push)
			i = i 5 +
			:load(x,i)
			y = x 3 =! # function end
			:while(y){
				# declaration, type declaration, parameter
				y = x 0 == x 12 == | x 4 == |
				:if(y){
					:call(semantics_nameResolver_handleDeclaration)
				} else {
					y = x 8 == x 9 == | # if,while
					:if(y){
						:call(semantics_nameResolver_recursive)
					} else {
						y = x 5 == # return
						:if(y){
							c = 0 # reachable return; unset flag
						}
						:call(semantics_nameResolver_resolveNames)
					}
				}
				i = i 5 +
				:load(x,i)
				y = x 3 =! # function end
			}
			:if(c){
				x = i 3 + # function end/decl ?
				:load(x,x)
				y = x 1 == # function end (ignore decl)
				x = c 1 + # function type
				:load(x,x)
				x = x 1 + # type type
				:load(x,x)
				x = x 3 =! # void
				y = y x &
				:if(y){
					x = c 2 + # function ident
					:load(x,x)
					:call(errorIdent)
					:throw(" doesn't have a reachable return statement.\n")
					x = 1
					:exit(x)
				}
			}
			:call(pop)
			m = s
			t = t 1 -
		} else {
			u = i 1 +
			:load(u,u)
			y = x 1 == u 6 == & # x == type & u == name (type)
			:if(y){
				x = i 2 + # ident
				:load(x,x)
				p = x
				:call(semantics_nameResolver_getTypeDeclaration)
				y = r 0 1 - ==
				:if(y){
					:throw("Undeclared type ")
					x = p
					:call(errorIdent)
					:throw(". ")
					x = p 3 +
					:load(x,x)
					:call(errorPrintLine)
				}
				x = i 2 +
				:store(r,x)
			}
		}
		i = i 5 +
		y = i g <
	}
}
:fun(semantics_nameResolver_resolveNames){
	u = i 1 +
	:load(u,u)
	y = x 2 == u 22 == & # ident expression
	:if(y){
		x = i 2 + # ident
		:load(x,x)
		p = x
		:call(semantics_nameResolver_getDeclaration)
		y = r 0 1 - ==
		:if(y){
			:throw("Undeclared name ")
			x = p
			:call(errorIdent)
			:throw(". ")
			x = p 3 +
			:load(x,x)
			:call(errorPrintLine)
		}
		x = i 3 + # declaration is in place of expr2
		:store(r,x)
	} else {
		u = i 1 + # type id
		:load(u,u)
		y = x 1 == u 6 == & # named type
		:if(y){
			x = i 2 + # ident
			:load(x,x)
			p = x
			:call(semantics_nameResolver_getTypeDeclaration)
			y = r 0 1 - ==
			:if(y){
				:throw("Undeclared type ")
				x = p
				:call(errorIdent)
				:throw(". ")
				x = p 3 +
				:load(x,x)
				:call(errorPrintLine)
			}
			x = i 2 +
			:store(r,x)
		} else {
			u = i 1 + # start/end
			:load(u,u)
			y = x 10 == u 0 == & # call & start of call
			:if(y){
				x = i 2 + # ident
				:load(x,x)
				p = x
				:call(semantics_nameResolver_getDeclaration)
				y = r 0 1 - ==
				:if(y){
					:throw("Undeclared name1 ")
					x = p
					:call(errorIdent)
					:throw(". ")
					x = p 3 +
					:load(x,x)
					:call(errorPrintLine)
				}
				x = i 2 +
				:store(r,x)
			}
		}
	}
}
:fun(semantics_nameResolver_recursive){
	t = t 1 +
	s = m
	:call(push)
	y = x 8 == # if/else
	:if(y){
		y = i 1 +
		:load(y,y)
		y = y 0 ==
		i = i 5 +
		:load(x,i)
		:if(y){ # if
			u = i 1 +
			:load(u,u)
			y = x 8 =! u 1 =! |# else
			:while(y){
				y = x 0 == x 12 == | # declaration,type declaration
				:if(y){
					:call(semantics_nameResolver_handleDeclaration)
				} else {
					y = x 8 == x 9 == | # if, while
					:if(y){
						:call(semantics_nameResolver_recursive)
					} else {
						:call(semantics_nameResolver_resolveNames)
					}
				}
				i = i 5 +
				:load(x,i)
				u = i 1 +
				:load(u,u)
				y = x 8 =! u 0 == | # not if/else or another start of if
			}
			x = a 1 +
			:load(m,x)
			y = u 1 == # else
			:if(y){
				i = i 5 +
				:load(x,i)
				u = i 1 +
				:load(u,u)
				y = x 8 =! u 2 =! | # not if else or not end
				:while(y){
					y = x 0 == x 12 == | # declaration, type declaration
					:if(y){
						:call(semantics_nameResolver_handleDeclaration)
					} else {
						y = x 8 == x 9 == | # if, while
						:if(y){
							:call(semantics_nameResolver_recursive)
						} else {
							:call(semantics_nameResolver_resolveNames)
						}
					}
					i = i 5 +
					:load(x,i)
					u = i 1 +
					:load(u,u)
					y = x 8 =! u 2 =! | # if/else
				}
			}
		}
	} else { # while
		i = i 5 +
		:load(x,i)
		u = i 1 +
		:load(u,u)
		y = x 9 =! u 1 =! | # not while or not end
		:while(y){
			y = x 0 == x 12 == | # declaration, type declaration
			:if(y){
				:call(semantics_nameResolver_handleDeclaration)
			} else {
				y = x 8 == x 9 == | # if,while
				:if(y){
					:call(semantics_nameResolver_recursive)
				} else {
					:call(semantics_nameResolver_resolveNames)
				}
			}
			i = i 5 +
			:load(x,i)
			u = i 1 +
			:load(u,u)
			y = x 9 =! u 1 =! | # while
		}
	}
	:call(pop)
	m = s
	t = t 1 -
}
:fun(semantics_nameResolver_handleDeclaration){
	y = x 0 == # declaration
	:if(y){
		x = i 3 +
		:load(x,x)
		p = x
		:call(semantics_nameResolver_getDeclaration)
		y = y 0 1 - =! q t == &
		:if(y){
			:throw("Name ")
			x = p
			:call(errorIdent)
			:throw(" already declared. ")
			x = p 3 +
			:load(x,x)
			:call(errorPrintLine)
		}
		:store(i,m)
		m = m 1 +
		:store(t,m)
		m = m 1 +
	} else {
		y = x 12 == # struct
		:if(y){
			x = i 2 +
			:load(x,x)
			p = x
			:call(semantics_nameResolver_getTypeDeclaration)
			y = y 0 1 - =! q t == &
			:if(y){
				:throw("Type ")
				x = p
				:call(errorIdent)
				:throw(" already declared. ")
				x = p 3 +
				:load(x,x)
				:call(errorPrintLine)
			}
			:store(i,m)
			m = m 1 +
			:store(t,m)
			m = m 1 +
			i = i 5 +
			:load(x,i)
			y = x 12 =!
			t = t 1 +
			s = m
			:call(push)
			:while(y){
				:call(semantics_nameResolver_resolveNames)
				:call(semantics_nameResolver_handleDeclaration)
				i = i 5 +
				:load(x,i)
				y = x 12 =!
			}
			t = t 1 -
			:call(pop)
			m = s
		} else {
			y = x 4 == # parameter
			:if(y){
				x = i 2 +
				:load(x,x)
				p = x
				:call(semantics_nameResolver_getDeclaration)
				y = y 0 1 - =! q t == &
				:if(y){
					:throw("Parameter ")
					x = p
					:call(errorIdent)
					:throw(" already declared. ")
					x = p 3 +
					:load(x,x)
					:call(errorPrintLine)
				}
				:store(i,m)
				m = m 1 +
				:store(t,m)
				m = m 1 +
			}
		}
	}
}
:fun(semantics_nameResolver_getDeclaration){
	j = m 2 -
	r = 0 1 -
	q = 0 1 -
	y = j g =>
	z = x # save search ident
	:while(y){
		:load(u,j) # load declaration address
		:load(v,u) # load declaration type
		y = v 0 == # variable
		:if(y){
			v = u 3 +
			:load(y,v)
			x = z
			:call(identEquals)
			:if(y){
				r = u
				q = j 1 +
				:load(q,q)
			}
		} else {
			y = v 3 == v 4 == | # function, parameter
			:if(y){
				v = u 2 +
				:load(y,v)
				x = z
				:call(identEquals)
				:if(y){
					r = u
					q = j 1 +
					:load(q,q)
				}
			}
		}
		j = j 2 -
		y = j g => r 0 1 - == &
	}
	y = r
}
:fun(semantics_nameResolver_getTypeDeclaration){
	j = m 2 -
	r = 0 1 -
	q = 0 1 -
	y = j g =>
	z = x # save search ident
	:while(y){
		:load(u,j) # load declaration address
		:load(v,u) # load declaration type
		y = v 12 == # struct
		:if(y){
			v = u 2 +
			:load(y,v)
			x = z
			:call(identEquals)
			:if(y){
				r = u
				q = j 1 +
				:load(q,q)
			}
		}
		j = j 2 -
		y = j g => r 0 1 - == &
	}
	y = r
}
#
# Phase 2 - Syntax analisys
#
:fun(syntax){
	:if(d){
		:raw("\nPhase 2 - Syntax analisys\n")
	}
	i = b
	g = e 4 - # dont count safety token
	c = i g <
	:while(c){
		f = 1
		w = i # save old place of token parsing
		o = m # save old memory pointer
		:call(syntax_isDeclaration)
		:if(f){
			# restore if matching changed anything
			i = w
			m = o
			:call(syntax_isTypeDeclaration)
			:if(f){
				i = w
				m = o
				:call(syntax_isFunction)
				:if(f){
					:call(errorUnmatchedToken)
				}
			}
		}
		c = i g <
	}
}
:fun(syntax_isParameter){
	:call(syntax_isType)
	:load(x,i)
	y = f 0 == x 2 == & # match found & x == ID
	:if(y){
		x = 4 # parameter
		:store(x,m)
		x = m 5 - # type was written in last cell
		m = m 1 +
		:store(x,m)
		m = m 1 +
		:store(i,m) # identifier is current token
		m = m 2 + # skip two
		x = 0 1 -
		:store(x,m)
		m = m 1 +
		i = i 4 +
		:if(d){
			:raw("PAR ")
		}
	} else {
		f = 1
	}
}
:fun(syntax_isFunction){
	:call(syntax_isType)
	:load(x,i)
	y = f 0 == x 2 == & # match found & x == ID
	:if(y){ # type ident
		x = 3 # function
		:store(x,m)
		x = m 5 - # type was written in last cell
		m = m 1 +
		:store(x,m)
		m = m 1 +
		:store(i,m) # identifier is current token
		m = m 1 +
		x = 0 # start of function block
		:store(x,m)
		s = m # save start of function memory location
		:call(push)
		m = m 2 + # skip one
		i = i 4 +
		:load(x,i)
		y = x 14 == # (
		:if(y){
			i = i 4 +
			:load(x,i)
			y = x 15 =! # )
			:if(y){ # undo first increment of while loop
				i = i 4 -
			}
			:while(y){
				i = i 4 +
				f = 1
				:call(syntax_isParameter)
				:if(f){
					:call(errorUnmatchedToken)
				}
				:load(x,i)
				y = x 21 == # ,
			}
			y = x 15 =! # )
			:if(y){
				x = 41  # )
				:call(errorExpectedX)
			}
			i = i 4 +
			:load(x,i)
			y = x 22 == # ;
			:if(y){
				x = 2 # overwrite memory as function declaration start
				y = a 1 +
				:load(y,y)
				:store(x,y)
				:if(d){
					:raw("FUNDECL ")
				} 
			} else {
				y = x 16 =! # {
				:if(y){
					x = 123 # {
					:call(errorExpectedX)
				}
				i = i 4 +
				:load(x,i)
				y = x 17 =! # }
				:while(y){
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
					y = x 17 =! # }
				}
				:if(d){
					:raw("FUN ")
				} 
			}
			i = i 4 +
			y = a 1 +
			:load(y,y)
			y = y 1 +
			:store(m,y)
			x = 3 # function
			:store(x,m)
			x = 1 # function end block
			m = m 3 +
			:store(x,m)
			m = m 2 + # skip one
			f = 0 # set match flag
		} else {
			f = 1
		}
		:call(pop)
	} else {
		f = 1
	}
}
:fun(syntax_isStatement){
	s = w
	:call(push)
	s = o
	:call(push)
	w = i
	o = m
	:call(syntax_isDeclaration)
	:if(f){
		i = w
		m = o
		:call(syntax_isReturn)
		:if(f){
			i = w
			m = o
			:call(syntax_isAssign)
			:if(f){
				i = w
				m = o
				:call(syntax_isIf)
				:if(f){
					i = w
					m = o
					:call(syntax_isWhile)
					:if(f){
						i = w
						m = o
						:call(syntax_isExprStmt)
						:if(f){
							i = w
							m = o
							:call(syntax_isTypeDeclaration)
						}
					}
				}
			}
		}
	}
	:call(pop)
	o = s
	:call(pop)
	w = s
}
:fun(syntax_isReturn){
	:load(x,i)
	y = x 27 == # return
	:if(y){
		i = i 4 +
		:load(x,i)
		y = x 22 == # ;
		:if(y){
			i = i 4 +
			x = 5 # return
			:store(x,m)
			x = 0 1 - # expression
			m = m 1 +
			:store(x,m)
			m = m 4 + # skip three
			f = 0 # set match flag
			:if(d){
				:raw("RET ")
			}
		} else {
			:call(syntax_isExpression)
			:load(x,i)
			y = f 0 == x 22 == & # x == ;
			:if(y){
				i = i 4 +
				x = 5 # return
				:store(x,m)
				x = m 5 - # expression
				m = m 1 +
				:store(x,m)
				m = m 4 + # skip three
				f = 0 # set match flag
				:if(d){
					:raw("RET ")
				}
			} else {
				f = 1
			}
		}
	}
}
:fun(syntax_isAssign){
	:call(syntax_isExpression)
	:load(x,i)
	y = f 0 == x 1 == & # any of the assignments
	f = 1
	:if(y){
		z = i 1 +
		:load(s,z)
		:call(push)
		s = m 5 -
		:call(push)
		i = i 4 +
		:call(syntax_isExpression)
		:load(x,i)
		y = f 0 == x 22 == & # x == ;
		:call(pop) # expr1 mem
		z = s
		:call(pop) # assignment op
		:if(y){
			i = i 4 +
			x = 7 # assignment
			:store(x,m)
			u = m 5 - # expression2
			m = m 1 +
			:store(s,m) # assignment op
			m = m 1 +
			:store(z,m) # expression1
			m = m 1 +
			:store(u,m) # expression 2
			m = m 2 + # skip two
			f = 0 # set match flag
			:if(d){
				:raw("ASS ")
			}
		} else {
			f = 1
		}
	}
}
:fun(syntax_isIf){
	:load(x,i)
	y = x 11 == # if
	:if(y){
		i = i 4 +
		:load(x,i)
		y = x 14 == # (
		:if(y){
			i = i 4 +
			f = 1
			:call(syntax_isExpression)
			:load(x,i)
			y = f 0 == x 15 == & # x == )
			:if(y){
				i = i 4 +
				x = 8 # if/else
				:store(x,m)
				u = m 5 - # expression is last cell
				m = m 1 +
				x = 0 # if
				:store(x,m)
				m = m 1 +
				:store(u,m) # expression
				m = m 3 + # skip two
				:load(x,i)
				y = x 16 == # {
				:if(y){
					i = i 4 +
					:load(x,i)
					y = x 17 =! # }
					:while(y){
						f = 1
						:call(syntax_isStatement)
						:if(f){
							:call(errorUnmatchedToken)
						}
						:load(x,i)
						y = x 17 =! # }
					}
					i = i 4 +
				} else {
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
				}
				:load(x,i)
				y = x 12 == # else
				:if(y){
					:if(d){
						:raw("IF ")
					}
					x = 8 # if/else
					:store(x,m)
					m = m 1 +
					x = 1 # else
					:store(x,m)
					m = m 4 + # skip three
					i = i 4 +
					:load(x,i)
					y = x 16 == # {
					:if(y){
						i = i 4 +
						:load(x,i)
						y = x 17 =! # }
						:while(y){
							f = 1
							:call(syntax_isStatement)
							:if(f){
								:call(errorUnmatchedToken)
							}
							:load(x,i)
							y = x 17 =! # }
						}
						i = i 4 +
					} else {
						f = 1
						:call(syntax_isStatement)
						:if(f){
							:call(errorUnmatchedToken)
						}
					}
					x = 8 # if/else
					:store(x,m)
					m = m 1 +
					x = 2 # end
					:store(x,m)
					m = m 4 + # skip three
					:if(d){
						:raw("ELSE ")
					}
				} else {
					x = 8 # if/else
					:store(x,m)
					m = m 1 +
					x = 2 # end
					:store(x,m)
					m = m 4 + # skip three
					:if(d){
						:raw("IF ")
					}
				}
			} else {
				f = 1
			}
		}
	}
}
:fun(syntax_isWhile){
	:load(x,i)
	z = i 4 +
	:load(u,z)
	y = x 13 == u 14 == & # x == while & u == (
	:if(y){
		i = z 4 +
		:call(syntax_isExpression)
		:load(x,i)
		y = f 0 == x 15 == & # <expr> & x == )
		:if(y){
			i = i 4 +
			x = 9 # while
			:store(x,m)
			u = m 5 - # expression is last cell
			m = m 1 +
			x = 0 # start
			:store(x,m)
			m = m 1 +
			:store(u,m) # expression
			m = m 3 + # skip two
			:load(x,i)
			y = x 16 == # {
			:if(y){
				i = i 4 +
				:load(x,i)
				y = x 17 =! # }
				:while(y){
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
					y = x 17 =! # }
				}
				i = i 4 +
			} else {
				f = 1
				:call(syntax_isStatement)
				:if(f){
					:call(errorUnmatchedToken)
				}
			}
			x = 9 # while
			:store(x,m)
			m = m 1 +
			x = 1 # end
			:store(x,m)
			m = m 4 + # skip three
			:if(d){
				:raw("WHILE ")
			}
		}
	}
}
:fun(syntax_isExprStmt){
	:call(syntax_isExpression)
	:load(x,i)
	y = f 0 == x 22 == & # <expr> & x == ;
	:if(y){
		i = i 4 +
		x = 6 # expr stmt
		:store(x,m)
		x = m 5 - # expression
		m = m 1 +
		:store(x,m)
		m = m 4 + # skip three
		f = 0 # set match flag
		:if(d){
			:raw("EXP ")
		}
	} else {
		f = 1
	}
}
:fun(syntax_isExpression){
	:call(syntax_isExpression_f)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_ee)
	}
}
:fun(syntax_isExpression_ee){
	:load(x,i)
	y = x 42 == # ||
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_f)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		x = 21 # ||
		:store(x,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop|| ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_ee)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_f){
	:call(syntax_isExpression_g)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_ff)
	}
}
:fun(syntax_isExpression_ff){
	:load(x,i)
	y = x 41 == # &&
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_g)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		x = 20 # &&
		:store(x,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop&& ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_ff)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_g){
	:call(syntax_isExpression_x)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_gg)
	}
}
:fun(syntax_isExpression_gg){
	:load(x,i)
	y = x 29 == # |
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_x)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		x = 19 # |
		:store(x,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop| ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_gg)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_x){
	:call(syntax_isExpression_h)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_xx)
	}
}
:fun(syntax_isExpression_xx){
	:load(x,i)
	y = x 44 == # ^
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_h)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		x = 26 # ^
		:store(x,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop^ ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_xx)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_h){
	:call(syntax_isExpression_i)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_hh)
	}
}
:fun(syntax_isExpression_hh){
	:load(x,i)
	y = x 28 == # &
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_i)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		x = 18 # &
		:store(x,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop& ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_hh)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_i){
	:call(syntax_isExpression_j)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_ii)
	}
}
:fun(syntax_isExpression_ii){
	:load(x,i)
	y = x 30 == x 31 == | # x == '==' | x == '!='
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		y = x 30 ==
		:if(y){
			s = 16 # ==
		} else {
			s = 17 # !=
		}
		:call(push) # op
		:call(syntax_isExpression_j)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		:call(pop) # op
		:store(s,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop!== ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_ii)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_j){
	:call(syntax_isExpression_k)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_jj)
	}
}
:fun(syntax_isExpression_jj){
	:load(x,i)
	# x == '<' | x == '>' | x == '<=' | x == '>='
	y = x 32 == x 33 == | x 34 == | x 35 == |
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		s = x 20 - # offset of new codes
		:call(push) # op
		:call(syntax_isExpression_k)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		:call(pop) # op
		:store(s,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop>< ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_jj)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_k){
	:call(syntax_isExpression_l)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_kk)
	}
}
:fun(syntax_isExpression_kk){
	:load(x,i)
	y = x 39 == x 40 == | # x == '+' | x == '-'
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		s = x 29 -
		:call(push) # op
		:call(syntax_isExpression_l)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		:call(pop) # op
		:store(s,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop+- ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_kk)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_l){
	:call(syntax_isExpression_m)
	y = f 0 ==
	:if(y){
		f = 1
		:call(syntax_isExpression_ll)
	}
}
:fun(syntax_isExpression_ll){
	:load(x,i)
	y = x 36 == x 37 == | x 38 == | # x == '*' | x == '/' | x == '%'
	:if(y){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		s = x 29 -
		:call(push) # op
		:call(syntax_isExpression_m)
		u = m 5 -
		x = 2 # expression
		:store(x,m)
		m = m 1 +
		:call(pop) # op
		:store(s,m) # type
		m = m 1 +
		:call(pop) # expr1
		:store(s,m) # expr1
		m = m 1 +
		:store(u,m) #expr2
		m = m 2 + # skip one
		:if(d){
			:raw("binop/*% ")
		}
		y = f 0 ==
		:if(y){
			f = 1
			:call(syntax_isExpression_ll)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_m){
	:load(x,i)
	y = x 25 == # ++
	:if(y){
		s = 2 # pref ++
	}
	z = x 26 == # --
	:if(z){
		s = 3 # pref --
	}
	y = y z |
	z = x 39 == # +
	:if(z){
		s = 4 # pref +
	}
	y = y z |
	z = x 40 == # -
	:if(z){
		s = 5 # pref -
	}
	y = y z |
	z = x 24 == # !
	:if(z){
		s = 6 # pref !
	}
	y = y z |
	z = x 43 == # ~
	:if(z){
		s = 27 # pref ~
	}
	y = y z |
	z = x 28 == # &
	:if(z){
		s = 28 # &
	}
	y = y z |
	z = x 36 == # *
	:if(z){
		s = 29 # *
	}
	y = y z |
	z = x 14 == # (
	:if(z){ # cast expression
		s = i
		:call(push)
		s = m
		:call(push)
		i = i 4 +
		f = 1
		:call(syntax_isType)
		:load(x,i)
		u = f 0 == x 15 == & # <type> & x == ')'
		:if(u){
			:call(pop)
			:call(pop)
			s = m 5 -
			:call(push)
			s = 30
			y = 1
		} else {
			:call(pop)
			m = s
			:call(pop)
			i = s
			f = 1
		}
	}
	:if(y){
		:if(d){
			:raw("prefix ")
		}
		i = i 4 +
		:call(push)
		:call(syntax_isExpression_m)
		u = 2 # expression
		:store(u,m)
		u = m 5 -
		m = m 1 +
		:call(pop)
		:store(s,m) # type
		m = m 1 +
		:store(u,m) # inner expression
		m = m 1 +
		y = s 30 == # cast expression
		:if(y){
			:call(pop)
			:store(s, m) # type is in expr2
		}
		m = m 2 + # skip one
	} else {
		:call(syntax_isExpression_n)
	}
}
:fun(syntax_isExpression_n){
	:call(syntax_isExpression_o)
	:call(syntax_isExpression_nn)
}
:fun(syntax_isExpression_nn){
	:load(x,i)
	y = x 25 == x 26 == | # x == '++' | x == '--'
	:if(y){
		u = 2 # expression
		:store(u,m)
		u = m 5 - # save last cell
		x = x 25 ==
		:if(x){
			x = 0 # ++
		} else {
			x = 1 # --
		}
		m = m 1 +
		:store(x,m) # type
		m = m 1 +
		:store(u,m) # token
		m = m 3 + # skip two
		i = i 4 +
		:if(d){
			:raw("postinc ")
		}
		:call(syntax_isExpression_nn)
	} else {
		y = x 18 == # [
		:if(y){
			s = m 5 -
			:call(push)
			i = i 4 +
			f = 1
			:call(syntax_isExpression)
			:call(pop)
			:load(x,i)
			y = f 0 == x 19 == & # <expr> & x == ']'
			:if(y){
				u = 2 # expression
				:store(u,m)
				u = m 5 - # save last cell
				x = 24 # array access 
				m = m 1 +
				:store(x,m) # type
				m = m 1 +
				:store(s,m) # base expression
				m = m 1 +
				:store(u,m) # offset
				m = m 2 + # skip one
				i = i 4 +
				:if(d){
					:raw("arr ")
				}
				:call(syntax_isExpression_nn)
			}
		} else {
			y = x 20 == # .
			:if(y){
				i = i 4 +
				:load(x,i)
				y = x 2 == # ident
				:if(y){
					u = m 5 - # last expression
					x = 2 # expression
					:store(x,m)
					m = m 1 +
					x = 25 # comp acess
					:store(x,m) # type
					m = m 1 +
					:store(u,m) # base expression
					m = m 1 +
					:store(i,m) # token (component)
					m = m 2 + # skip one
					i = i 4 +
					:if(d){
						:raw("comp ")
					}
					:call(syntax_isExpression_nn)
				} else {
					f = 1
				}
			} else {
				y = x 46 == # ->
				:if(y){
					i = i 4 +
					:load(x,i)
					y = x 2 == # ident
					:if(y){
						u = m 5 - # last expression
						x = 2 # expression
						:store(x,m)
						m = m 1 +
						x = 31 # comp acess (from pointer)
						:store(x,m) # type
						m = m 1 +
						:store(u,m) # base expression
						m = m 1 +
						:store(i,m) # token (component)
						m = m 2 + # skip one
						i = i 4 +
						:if(d){
							:raw("ptrcomp ")
						}
						:call(syntax_isExpression_nn)
					} else {
						f = 1
					}
				}
			}
		}
	}
}
:fun(syntax_isExpression_o){
	:load(x,i)
	y = x 2 == # ident
	:if(y){
		z = i 4 +
		:load(x,z)
		y = x 14 == # (
		:if(y){ # function call
			# Starting memory entry for call
			s = m
			:call(push)
			x = 10 # call
			:store(x,m)
			m = m 1 +
			x = 0 # start
			:store(x,m)
			m = m 1 +
			:store(i,m) # ident
			m = m 3 + # skip two
			# Finish writing memory
			i = z 4 +
			:load(x,i)
			y = x 15 =! # )
			:if(y){ # undo first increment of while loop
				i = i 4 -
			}
			:while(y){
				i = i 4 +
				f = 1
				:call(syntax_isExpression)
				:if(f){
					:call(errorUnmatchedToken)
				}
				x = 11 # argument
				:store(x,m)
				u = m 5 -
				m = m 1 +
				:store(u,m)
				m = m 4 + # skip three
				:load(x,i)
				y = x 21 == # ,
			}
			y = x 15 =! # )
			:if(y){
				x = 41 # )
				:call(errorExpectedX)
			}
			:if(d){
				:raw("call ")
			}
			# Ending memory entry for call
			x = 10 # call
			:store(x,m)
			m = m 1 +
			x = 1 # end
			:store(x,m)
			m = m 2 + # skip one
			:call(pop)
			:store(s,m)
			m = m 2 + # skip one
		} else { # ident
			x = 2 # expression
			:store(x,m)
			m = m 1 +
			x = 22 # ident
			:store(x,m) # type
			m = m 1 +
			:store(i,m) # token
			m = m 3 + # skip two
			:if(d){
				:raw("ident ")
			}
		}
		i = i 4 +
		f = 0
	} else {
		y = x 3 == # const
		:if(y){
			x = 2 # expression
			:store(x,m)
			m = m 1 +
			x = 23
			:store(x,m) # type
			m = m 1 +
			:store(i,m) # token
			m = m 3 + # skip two
			i = i 4 +
			f = 0
			:if(d){
				:raw("const ")
			}
		} else {
			y = x 14 == # (
			:if(y){
				:if(d){
					:raw("startencl ")
				}
				i = i 4 +
				:call(syntax_isExpression)
				:load(x,i)
				y = x 15 =! # )
				:if(y){
					x = 41 # )
					:call(errorExpectedX)
				}
				:raw("enclxpr ")
				i = i 4 +
			} else {
				y = x 47 == # sizeof
				:if(y){
					i = i 4 +
					:load(x,i)
					y = x 14 == # (
					:if(y){
						i = i 4 +
						f = 1
						:call(syntax_isType)
						:if(f){
							:throw("Expected type, found ")
							:load(x,i)
							:call(errint)
							:throw(".\n")
							x = 1
							:exit(x)
						} else {
							:load(x,i)
							y = x 15 =! # )
							:if(y){
								x = 15 # )
								:call(errorExpectedX)
							}
						}
					} else {
						x = 14 # (
						:call(errorExpectedX)
					}
					s = m 5 - # type cell
					x = 2 # expression
					:store(x,m)
					m = m 1 +
					x = 32
					:store(x,m) # type
					m = m 1 +
					:store(s,m) # token
					m = m 3 + # skip two
					i = i 4 +
					:if(d){
						:raw("sizeof ")
					}
				}
			}
		}
	}
}
:fun(syntax_isType){
	:load(x,i)
	y = x 0 == # type token
	f = 1
	:if(y){
		x = 1 # type
		:store(x,m)
		m = m 1 +
		x = i 1 +
		:load(x,x)
		:store(x,m) # type id
		m = m 4 + # skip three
		i = i 4 +
		:load(x,i)
		f = 0 # set match flag
	} else {
		y = x 2 == # ident token
		:if(y){
			x = 1 # type
			:store(x,m)
			m = m 1 +
			x = 6 # name type
			:store(x,m) # type id
			m = m 1 +
			:store(i,m) # basetype is the ident
			m = m 3 + # skip two
			i = i 4 +
			f = 0 # set match flag
		}
	}
	y = f 0 ==
	:while(y){
		:load(x,i)
		u = x 36 == # *
		:if(u){
			x = 1 # type
			:store(x,m)
			u = m 5 -
			m = m 1 +
			x = 5 # pointer type
			:store(x,m) # type id
			m = m 1 +
			:store(u,m) # basetype is last type
			m = m 3 + # skip two
			i = i 4 +
		} else {
			u = x 18 == # [
			z = i 4 +
			:load(x,z)
			v = x 3 == # const
			u = u v &
			k = z
			z = z 4 +
			:load(x,z)
			v = x 19 == # ]
			u = u v &
			:if(u){
				x = 1 # type
				:store(x,m)
				u = m 5 -
				m = m 1 +
				x = 4 # array type
				:store(x,m) # type id
				m = m 1 +
				:store(u,m) # basetype is last type
				m = m 1 +
				:store(k,m) # length is the const token
				m = m 2 + # skip one
				i = z 4 +
			} else {
				y = 0
			}
		}
	}
}
:fun(syntax_isDeclaration){
	:call(syntax_isType)
	:load(x,i)
	y = f 0 == x 2 == & # <type> & x == ID
	l = i # save identifier location
	:if(y){ # type ident
		i = i 4 +
		:load(x,i)
		y = x 22 == # ;
		:if(y){ # type ident;
			i = i 4 +
			x = 0
			:store(x,m)
			x = m 5 - # type was written in last cell
			m = m 1 +
			:store(x,m)
			m = m 1 +
			x = 0 1 -
			:store(x,m)
			m = m 1 +
			:store(l,m)
			m = m 1 +
			x = 0 1 -
			:store(x,m)
			m = m 1 +
			f = 0 # set match flag
			:if(d){
				:raw("DECL ")
			}
		} else {
			z = i 1 +
			:load(z,z) # load id
			y = x 1 == z 0 == & # any assignment & z == '='
			:if(y){ # type ident = 
				i = i 4 +
				n = m 5 - # save type location
				f = 1
				:call(syntax_isExpression)
				:load(x,i)
				y = f 0 == x 22 == & # <expr> & x == ';'
				:if(y){ # type ident = expr ;
					i = i 4 +
					x = 0
					:store(x,m)
					m = m 1 +
					:store(n,m) # type location was saved in n
					m = m 1 +
					x = m 7 - # last cell (5) and the 2 we just added
					:store(x,m)
					m = m 1 +
					:store(l,m)
					m = m 1 +
					x = 0 1 -
					:store(x,m)
					m = m 1 +
					:if(d){
						:raw("INIT ")
					}
				} else {
					f = 1 # no match
				}
			} else {
				f = 1 # no match
			}
		}
	} else {
		f = 1 # no match
	}
}
:fun(syntax_isTypeDeclaration){
	:load(x,i)
	y = x 45 == # struct
	:if(y){
		i = i 4 +
		:load(x,i)
		y = x 2 == # ident
		:if(y){
			x = 12 # struct
			:store(x,m)
			m = m 1 +
			x = 0 # start
			:store(x,m)
			m = m 1 +
			:store(i,m)
			m = m 1 +
			x = 0 1 -
			:store(x,m)
			m = m 2 + # skip one
			i = i 4 +
			:load(x,i)
			y = x 16 == # {
			:if(y){
				i = i 4 +
				:load(x,i)
				y = x 17 =! # }
				:while(y){
					f = 1
					:call(syntax_isParameter)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
					y = x 22 =! # ;
					:if(y){
						x = 59 # ;
						:call(errorExpectedX)
					}
					y = x 0 1 - == # EOF
					:if(y){
						:raw("End of file reached while parsing struct.")
						x = 1
						:exit(x)
					}
					i = i 4 +
					:load(x,i)
					y = x 17 =! # }
				}
				x = 12 # struct
				:store(x,m)
				m = m 1 +
				x = 1 # end
				:store(x,m)
				m = m 4 + # skip three
				i = i 4 +
				:load(x,i)
				y = x 22 =! # ;
				:if(y){
					x = 59 # ;
					:call(errorExpectedX)
				} 
				i = i 4 +
				f = 0
				:if(d){
					:raw("TYPEDECL ")
				}
			} else {
				x = 123 # {
				:call(errorExpectedX)
			}
		} else {
			:throw("Expected identifier. ")
			x = i 3 +
			:load(x,x)
			:call(errorPrintLine)
		}
	}
}
#
# Phase 1 - Tokenize
#
:fun(tokenize){
	:if(d){
		:raw("Phase 1 - Tokenization\n")
	}
	l = 1 # line count
	i = 0 # file index
	c = i b < # read through the file
	:while(c){
		f = 1 # flag for matches ( 0 => stop trying to match)
		:call(tokenize_isComment)
		:if(f){
			:call(tokenize_isWhitespace)
			:if(f){
				:call(tokenize_isKeyword)
				:if(f){
					:call(tokenize_isConstant)
					:if(f){
						:call(tokenize_isSymbol)
						:if(f){
							:call(tokenize_isIdentifier)
							:if(f){
								:call(errorUnmatchedChar)
							}
						}
					}
				}
			}
		}
		c = i b < # Update condition
	}
	# End of tokens
	x = 0 1 -
	:store(x,m)
	m = m 1 +
	:store(x,m)
	m = m 1 +
	:store(x,m)
	m = m 1 +
	:store(x,m)
	m = m 1 +
}
# Match comment
:fun(tokenize_isComment){
	:load(x,i)
	y = x 47 == # '/'
	:if(y){
		z = i 1 +
		:load(x,z)
		y = x 47 == z b < & # x == '/' & z < b
		:if(y){
			f = 0 # set match flag
			i = z 1 + # increment file index
			:load(x,i)
			y = x 10 =! i b < & # skip characters until end of line
			:while(y){
				i = i 1 + # increment file index
				:load(x,i)
				y = x 10 =! i b < & # newline
			}
		} else {
			y = x 42 == # '*'
			:if(y){
				v = 0
				i = i 1 +
				:while(y){
					u = i b =>
					:if(u){
						:call(errorEOFcomment)
					}
					:load(x,i)
					i = i 1 +
					u = x 42 == # '*'
					:if(u){
						v = 1
					} else {
						u = x 47 == v & # /
						:if(u){
							y = 0
						}
						v = 0
						u = x 10 == # \n
						:if(u){
							l = l 1 +
						}
					}
				}
			}
		}
	}
}
# Match whitespace
:fun(tokenize_isWhitespace){
	:load(x,i)
	y = x 10 == # \n
	:if(y){
		l = l 1 + # increment line counter
	}
	y = y x 9 == | x 32 == | # y | x == '\t' | x == ' '
	:if(y){
		f = 0 # set match flag
		:while(y){
			i = i 1 +
			:load(x,i)
			y = x 10 == # \n
			:if(y){
				l = l 1 + # increment line counter
			}
			y = y x 9 == | x 32 == | # y | x == '\t' | x == ' '
		}
	}
}
# Match keywords
:fun(tokenize_isKeyword){
	w = i # save file index if match fails
	# Preload 4 characters in t,u,v,z
	:load(p,i)
	i = i 1 +
	:load(q,i)
	i = i 1 +
	:load(r,i)
	i = i 1 +
	:load(s,i)
	i = i 1 +
	:load(t,i)
	i = i 1 +
	:call(tokenize_isKeyword_bool)
	:if(f){
		:call(tokenize_isKeyword_char)
		:if(f){
			:call(tokenize_isKeyword_int)
			:if(f){
				:call(tokenize_isKeyword_void)
				:if(f){
					:call(tokenize_isKeyword_if)
					:if(f){
						:call(tokenize_isKeyword_else)
						:if(f){
							:call(tokenize_isKeyword_while)
							:if(f){
								:call(tokenize_isKeyword_return)
								:if(f){
									:call(tokenize_isKeyword_struct)
									:if(f){
										:call(tokenize_isKeyword_sizeof)
									}
								}
							}
						}
					}
				}
			}
		}
	}
	:if(f){
		i = w # restore file index if no match was found
	}
}
# input x
# output y
# writes: u,v,y
:fun(tokenize_isKeyword_helper){ # check if char is not identifier
	# !(x >= '0' & x <= '9' | x >= 'A' & x <= 'Z' | x == '_' | x >= 'a' & x <= 'z')
	y = 1 x 48 => x 57 =< & x 65 => x 90 =< & | x 95 == | x 97 => x 122 =< & | -
}
# input: loaded p,q,r,s,t
# output: sets r, writes memory
# write: x,y,m
# calls: tokenize_isKeyword_helper
:fun(tokenize_isKeyword_bool){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 'b' & q == 'o' & r == 'o' & s == 'l'
	y = y p 98 == & q 111 == & r 111 == & s 108 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m 1 +
		x = 2 # id 2 (bool)
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 + 
		i = i 1 -
		:if(d){
			:raw("BOOL ")
		}
	}
}
:fun(tokenize_isKeyword_char){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 'c' & q == 'h' & r == 'a' & s == 'r'
	y = y p 99 == & q 104 == & r 97 == & s 114 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m 1 +
		x = 1 # id 1 (char)
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 +
		i = i 1 -
		:if(d){
			:raw("CHAR ")
		}
	}
}
:fun(tokenize_isKeyword_int){
	x = s # 4th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	# y & x == 'i' & q == 'n' && r == 't'
	y = y p 105 == & q 110 == & r 116 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m 1 +
		x = 0 # id 0 (int)
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 +
		# i is too far
		i = i 2 -
		:if(d){
			:raw("INT ")
		}
	}
}
:fun(tokenize_isKeyword_void){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 'v' & q == 'o' & r == 'i' & s == 'd'
	y = y p 118 == & q 111 == & r 105 == & s 100 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m 1 +
		x = 3 # id 3 (void)
		:store(x,m)
		m = m 1 +
		x = 0
		:store(x,m)
		m = m 1 + # skip optional field
		:store(l,m)
		m = m 1 +
		i = i 1 -
		:if(d){
			:raw("VOID ")
		}
	}
}
:fun(tokenize_isKeyword_if){
	x = r # 3rd character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 'i' & q == 'f'
	y = y p 105 == & q 102 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 11 # type 11
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		# i is too far since most keywords longer
		i = i 3 -
		:if(d){
			:raw("IF ")
		}
	}
}
:fun(tokenize_isKeyword_else){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 'e' & q == 'l' & r == 's' & s == 'e'
	y = y p 101 == & q 108 == & r 115 == & s 101 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 12 # type 1
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		i = i 1 -
		:if(d){
			:raw("ELSE ")
		}
	}
}
:fun(tokenize_isKeyword_while){
	:load(x,i) # 6th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 'w' & q = 'h' & r == 'i' & s == 'l' & t == 'e'
	y = y p 119 == & q 104 == & r 105 == & s 108 == & t 101 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 13 # type 1
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("WHILE ")
		}
	}
}
:fun(tokenize_isKeyword_return){
	:load(z,i) # 6th character
	i = i 1 +
	:load(x,i) # 7th character should be non-identifier
	i = i 1 -
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 'r' & q == 'e' & r == 't' & s == 'u' & t == 'r' & z == 'n'
	y = y p 114 == & q 101 == & r 116 == & s 117 == & t 114 == & z 110 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 27 # type 27
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		i = i 1 + # increment file (we loaded but didnt increment)
		:if(d){
			:raw("RETURN ")
		}
	}
}
:fun(tokenize_isKeyword_struct){
	:load(z,i) # 6th character
	i = i 1 +
	:load(x,i) # 7th character should be non-identifier
	i = i 1 -
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 's' & q == 't' & r == 'r' & s == 'u' & t == 'c' & z == 't'
	y = y p 115 == & q 116 == & r 114 == & s 117 == & t 99 == & z 116 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 45 # type 45
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		i = i 1 + # increment file (we loaded but didnt increment)
		:if(d){
			:raw("STRUCT ")
		}
	}
}
:fun(tokenize_isKeyword_sizeof){
	:load(z,i) # 6th character
	i = i 1 +
	:load(x,i) # 7th character should be non-identifier
	i = i 1 -
	:call(tokenize_isKeyword_helper) # y contains result
	# y & p == 's' & q == 'i' & r == 'z' & s == 'e' & t == 'o' && z == 'f'
	y = y p 115 == & q 105 == & r 122 == & s 101 == & t 111 == & z 102 == &
	:if(y){ # match
		f = 0 # set match flag
		x = 47 # type 47
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		i = i 1 + # increment file (we loaded but didnt increment)
		:if(d){
			:raw("SIZEOF ")
		}
	}
}
:fun(tokenize_isSymbol){
	:load(x,i)
	z = i 1 +
	:load(z,z)
	:call(tokenize_isSymbol_ADDEQ)
	:if(f){
		:call(tokenize_isSymbol_SUBEQ)
		:if(f){
			:call(tokenize_isSymbol_DIVEQ)
			:if(f){
				:call(tokenize_isSymbol_MULEQ)
				:if(f){
					:call(tokenize_isSymbol_INC)
					:if(f){
						:call(tokenize_isSymbol_DEC)
						:if(f){
							:call(tokenize_isSymbol_EQ)
							:if(f){
								:call(tokenize_isSymbol_NEQ)
								:if(f){
									:call(tokenize_isSymbol_LEQ)
									:if(f){
										:call(tokenize_isSymbol_GEQ)
										:if(f){
											:call(tokenize_isSymbol_AND)
											:if(f){
												:call(tokenize_isSymbol_OR)
												:if(f){
													:call(tokenize_isSymbol_ARROW)
													:if(f){
														:call(tokenize_isSymbol_LPARENT)
														:if(f){
															:call(tokenize_isSymbol_RPARENT)
															:if(f){
																:call(tokenize_isSymbol_LCURLY)
																:if(f){
																	:call(tokenize_isSymbol_RCURLY)
																	:if(f){
																		:call(tokenize_isSymbol_LBRACK)
																		:if(f){
																			:call(tokenize_isSymbol_RBRACK)
																			:if(f){
																				:call(tokenize_isSymbol_PERIOD)
																				:if(f){
																					:call(tokenize_isSymbol_COMMA)
																					:if(f){
																						:call(tokenize_isSymbol_SEMICOLON)
																						:if(f){
																							:call(tokenize_isSymbol_COLON)
																							:if(f){
																								:call(tokenize_isSymbol_EXCL)
																								:if(f){
																									:call(tokenize_isSymbol_ASSIGN)
																									:if(f){
																										:call(tokenize_isSymbol_BITAND)
																										:if(f){
																											:call(tokenize_isSymbol_BITOR)
																											:if(f){
																												:call(tokenize_isSymbol_LT)
																												:if(f){
																													:call(tokenize_isSymbol_GT)
																													:if(f){
																														:call(tokenize_isSymbol_MUL)
																														:if(f){
																															:call(tokenize_isSymbol_DIV)
																															:if(f){
																																:call(tokenize_isSymbol_MOD)
																																:if(f){
																																	:call(tokenize_isSymbol_ADD)
																																	:if(f){
																																		:call(tokenize_isSymbol_SUB)
																																		:if(f){
																																			:call(tokenize_isSymbol_BITXOR)
																																			:if(f){
																																				:call(tokenize_isSymbol_BITNOT)
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(tokenize_isSymbol_ADDEQ){
	y = x 43 == z 61 == & # x == '+' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 1 # type 4
		:store(x,m)
		m = m 1 +
		x = 1 # id 1 (+=)
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("ADDEQ ")
		}
	}
}
:fun(tokenize_isSymbol_SUBEQ){
	y = x 45 == z 61 == & # x == '-' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m 1 +
		x = 2 # id 2 (-=)
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("SUBEQ ")
		}
	}
}
:fun(tokenize_isSymbol_DIVEQ){
	y = x 47 == z 61 == & #  x == '/' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m 1 +
		x = 3 # id 3 (/=)
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("DIVEQ ")
		}
	}
}
:fun(tokenize_isSymbol_MULEQ){
	y = x 42 == z 61 == & # x == '*' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m 1 +
		x = 4 # id 4 (*=)
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("MULEQ ")
		}
	}
}
:fun(tokenize_isSymbol_INC){
	y = x 43 == z 43 == & # x == '+' & z == '+'
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 25 # type 25
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("INC ")
		}
	}
}
:fun(tokenize_isSymbol_DEC){
	y = x 45 == z 45 == & # x == '-' & z == '-'
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 26 # type 26
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("DEC ")
		}
	}
}
:fun(tokenize_isSymbol_EQ){
	y = x 61 == z 61 == & # x == '=' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 30 # type 30
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("EQ ")
		}
	}
}
:fun(tokenize_isSymbol_NEQ){
	y = x 33 == z 61 == & # x == '!' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 31 # type 31
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("NEQ ")
		}
	}
}
:fun(tokenize_isSymbol_LEQ){
	y = x 60 == z 61 == & # x == '<' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 34 # type 34
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("LEQ ")
		}
	}
}
:fun(tokenize_isSymbol_GEQ){
	y = x 62 == z 61 == & # x == '>' & z == '='
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 35 # type 35
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("GEQ ")
		}
	}
}
:fun(tokenize_isSymbol_AND){
	y = x 38 == z 38 == & # x == '&' & z == '&'
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 41 # type 41
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("AND ")
		}
	}
}
:fun(tokenize_isSymbol_OR){
	y = x 124 == z 124 == & # x == '|' & z == '|'
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 42 # type 42
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("OR ")
		}
	}
}
:fun(tokenize_isSymbol_ARROW){
	y = x 45 == z 62 == & # x == '-' & z == '>'
	:if(y){
		i = i 2 +
		f = 0 # set match flag
		x = 46 # type 46
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("ARROW ")
		}
	}
}
:fun(tokenize_isSymbol_LPARENT){
	y = x 40 == # (
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 14 # type 14
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("LPARENT ")
		}
	}
}
:fun(tokenize_isSymbol_RPARENT){
	y = x 41 == # )
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 15 # type 15
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("RPARENT ")
		}
	}
}
:fun(tokenize_isSymbol_LCURLY){
	y = x 123 == # {
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 16 # type 16
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("LCURLY ")
		}
	}
}
:fun(tokenize_isSymbol_RCURLY){
	y = x 125 == # {
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 17 # type 17
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("RCURLY ")
		}
	}
}
:fun(tokenize_isSymbol_LBRACK){
	y = x 91 == # [
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 18 # type 18
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("LBRACK ")
		}
	}
}
:fun(tokenize_isSymbol_RBRACK){
	y = x 93 == # ]
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 19 # type 19
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("RBRACK ")
		}
	}
}
:fun(tokenize_isSymbol_PERIOD){
	y = x 46 == # .
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 20 # type 20
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("PERIOD ")
		}
	}
}
:fun(tokenize_isSymbol_COMMA){
	y = x 44 == # ,
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 21 # type 16
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("COMMA ")
		}
	}
}
:fun(tokenize_isSymbol_SEMICOLON){
	y = x 59 == # ;
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 22 # type 22
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("SEMICOLON ")
		}
	}
}
:fun(tokenize_isSymbol_COLON){
	y = x 58 == # :
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 23 # type 23
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("COLON ")
		}
	}
}
:fun(tokenize_isSymbol_ASSIGN){
	y = x 61 == # =
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m 1 +
		x = 0 # id 0
		:store(x,m)
		m = m 2 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("ASSIGN ")
		}
	}
}
:fun(tokenize_isSymbol_EXCL){
	y = x 33 == # !
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 24 # type 24
		:store(x,m)
		m = m 3 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("EXCL ")
		}
	}
}
:fun(tokenize_isSymbol_BITAND){
	y = x 38 == # &
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 28 # type 28
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("BITAND ")
		}
	}
}
:fun(tokenize_isSymbol_BITOR){
	y = x 124 == # |
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 29 # type 29
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("BITOR ")
		}
	}
}
:fun(tokenize_isSymbol_LT){
	y = x 60 == # <
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 32 # type 32
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("LT ")
		}
	}
}
:fun(tokenize_isSymbol_GT){
	y = x 62 == # >
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 33 # type 33
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("GT ")
		}
	}
}
:fun(tokenize_isSymbol_MUL){
	y = x 42 == # *
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 36 # type 36
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("MUL ")
		}
	}
}
:fun(tokenize_isSymbol_DIV){
	y = x 47 == # /
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 37 # type 37
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("DIV ")
		}
	}
}
:fun(tokenize_isSymbol_MOD){
	y = x 37 == # %
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 38 # type 38
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("MOD ")
		}
	}
}
:fun(tokenize_isSymbol_ADD){
	y = x 43 == # +
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 39 # type 39
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("ADD ")
		}
	}
}
:fun(tokenize_isSymbol_SUB){
	y = x 45 == # -
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 40 # type 40
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("SUB ")
		}
	}
}
:fun(tokenize_isSymbol_BITNOT){
	y = x 126 == # ~
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 43 # type 43
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("BITNOT ")
		}
	}
}
:fun(tokenize_isSymbol_BITXOR){
	y = x 94 == # ^
	:if(y){
		i = i 1 +
		f = 0 # set match flag
		x = 44 # type 44
		:store(x,m)
		m = m 3 + # skip 2 optional fields
		x = l # line number
		:store(x,m)
		m = m 1 +
		:if(d){
			:raw("BITXOR ")
		}
	}
}
:fun(tokenize_isConstant){
	:call(tokenize_isConstant_false)
	:if(f){
		:call(tokenize_isConstant_true)
		:if(f){
			:call(tokenize_isConstant_char)
			:if(f){
				:call(tokenize_isConstant_int)
				:if(f){
					:call(tokenize_isConstant_string)
					:if(f){
						:call(tokenize_isConstant_null)
					}
				}
			}
		}
	}
}
:fun(tokenize_isConstant_true){
	:load(p,i)
	z = i 1 +
	:load(q,z)
	z = z 1 +
	:load(r,z)
	z = z 1 +
	:load(s,z)
	z = z 1 +
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	# y & p == 't' & q == 'r' & r == 'u' & s == 'e'
	y = y p 116 == & q 114 == & r 117 == & s 101 == &
	:if(y){
		i = i 4 +
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m 1 +
		x = 2 # id 2 (constant(bool))
		:store(x,m)
		m = m 1 +
		x = 1
		:store(x,m)
		m = m 1 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("CBOOL(1) ")
		}
	}
}
:fun(tokenize_isConstant_null){
	:load(p,i)
	z = i 1 +
	:load(q,z)
	z = z 1 +
	:load(r,z)
	z = z 1 +
	:load(s,z)
	z = z 1 +
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	# y & p == 'n' & q == 'u' & r == 'l' & s == 'l'
	y = y p 110 == & q 117 == & r 108 == & s 108 == &
	:if(y){
		i = i 4 +
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m 1 +
		x = 4 # id 4 (constant(voidptr))
		:store(x,m)
		m = m 1 +
		x = 0
		:store(x,m)
		m = m 1 +
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("NULL ")
		}
	}
}
:fun(tokenize_isConstant_false){
	:load(p,i)
	z = i 1 +
	:load(q,z)
	z = z 1 +
	:load(r,z)
	z = z 1 +
	:load(s,z)
	z = z 1 +
	:load(t,z)
	z = z 1 +
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	# y & p == 'f' & q == 'a' & r == 'l' & s == 's' & t == 'e'
	y = y p 102 == & q 97 == & r 108 == & s 115 == & t 101 == &
	:if(y){
		i = i 5 +
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m 1 +
		x = 2 # id 2 (constant(bool))
		:store(x,m)
		m = m 1 +
		x = 0
		:store(x,m)
		m = m 1 + # skip optional field
		x = l # line number
		:store(x,m)
		m = m 1 +
		:if(d){
			:raw("CBOOL(0) ")
		}
	}
}
:fun(tokenize_isConstant_char){
	:load(p,i)
	z = i 1 +
	:load(q,z)
	x = q
	:call(isValidChar)
	y = y p 39 == &
	:if(y){
		z = z 1 +
		y = q 92 == # \
		:if(y){
			:load(x,z)
			:call(convertEscapableChar)
			w = y
			z = z 1 +
			:load(p,z)
			y = p 39 == # '
			:if(y){
				i = i 4 +
				f = 0 # set flag
				x = 3 # type 3
				:store(x,m)
				m = m 1 +
				x = 1 # id 1 (constant(char))
				:store(x,m)
				m = m 1 +
				x = w
				:store(x,m)
				m = m 1 + # skip optional field
				x = l # line number
				:store(x,m)
				m = m 1 +
				:if(d){
					:raw("CCHAR(")
					:call(putint)
					:raw(") ")
				}
			} else {
				:call(errorInvalidCharConstant)
			}
		} else {
			:load(r,z)
			y = r 39 == # '
			:if(y){
				i = i 3 +
				f = 0 # set flag
				x = 3 # type 0
				:store(x,m)
				m = m 1 +
				x = 1 # id 1 (constant(char))
				:store(x,m)
				m = m 1 +
				:store(q,m)
				m = m 1 + # skip optional field
				:store(l,m)
				m = m 1 +
				:if(d){
					:raw("CCHAR(")
					:call(putint)
					:raw(") ")
				}
			} else {
				:call(errorInvalidCharConstant)
			}
		}
	}
}
:fun(tokenize_isConstant_int){
	w = i
	:load(x,i)
	y = x 48 => x 57 =< & # x >= '0' & x <= '9'
	v = x 48 == # 0
	:if(y){
		z = 0
		:while(y){
			z = z 10 *
			y = z 0 <
			:if(y){
				:call(errorConstantTooBig)
			}
			x = x 48 -
			z = z x +
			i = i 1 +
			:load(x,i)
			y = x 48 => x 57 =< & # x >= '0' & x <= '9'
			v = v y &
			:if(v){
				:call(errorLeadingZero)
			}
		}
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m 1 +
		x = 0 # id 0 (constant(int))
		:store(x,m)
		m = m 1 +
		:store(z,m)
		m = m 1 + # skip optional field
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("CINT(")
			x = z
			:call(putint)
			:raw(") ")
		}
	} else {
		i = w
	}
}
:fun(tokenize_isConstant_string){
	:load(x,i)
	y = x 34 == # "
	:if(y){
		z = i
		:while(y){
			i = i 1 +
			:load(x,i)
			y = x 92 == # \
			:if(y){
				i = i 1 +
				:load(x,i)
				:call(convertEscapableChar)
				y = 1
			} else {
				:call(isValidChar)
				y = 1 y -
				:if(y){
					:call(errorInvalidCharInString)
				}
				y = x 34 =! # "
			}
		}
		i = i 1 + # move past "
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m 1 +
		x = 3 # id 3 (constant(int))
		:store(x,m)
		m = m 1 +
		:store(z,m)
		m = m 1 +
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("CSTRING(")
			:load(x,z)
			:putchar(x)
			z = z 1 +
			y = 1
			:while(y){
				:load(x,z)
				z = z 1 +
				:putchar(x)
				w = x 92 == # \
				:if(w){
					:load(x,z)
					z = z 1 +
					:putchar(x)
				} else {
					w = x 34 == # "
					:if(w){
						y = 0
					}
				}
			}
			:raw(") ")
		}
	}
}
:fun(tokenize_isIdentifier){
	:load(x,i)
	z = i
	w = 0 # length
	# x == '_' | x >= 'A' & x <= 'Z' | x >= 'a' & x <= 'z'
	y = x 95 == x 65 => x 90 =< & | x 97 => x 122 =< & |
	:if(y){
		f = 0 # set match flag
		:while(y){
			w = w 1 +
			i = i 1 +
			:load(x,i)
			:call(tokenize_isKeyword_helper) # returns 1 in y if its NOT an identifier char
			y = 1 y -
		}
		f = 0 # set flag
		x = 2 # type 2
		:store(x,m)
		m = m 1 +
		x = z # start of identifier
		:store(x,m)
		m = m 1 +
		:store(w,m)
		m = m 1 +
		:store(l,m)
		m = m 1 +
		:if(d){
			:raw("IDENT(")
			w = z w + # end
			y = z w <
			:while(y){
				:load(x,z)
				:putchar(x)
				z = z 1 +
				y = z w <
			}
			:raw(") ")
		}
	}
}
#
# Phase 0 - Read file
#
:fun(readFile){
	:getchar(x)
	:while(x){
		:store(x,m)
		m = m 1 +
		:getchar(x)
	}
}
#
# Utility functions
#
# breakpoint
:fun(break){
}
:fun(push){
	:store(s,a)
	a = a 1 -
}
:fun(pop){
	a = a 1 +
	:load(s,a)
}
:fun(putint){
	s = y
	:call(push) # save y
	s = w
	:call(push) # save w
	s = z
	:call(push) # save z
	s = x
	:call(push) # save x
	y = x 0 <
	:if(y){
		:raw("-")
		w = x 0 1 - *
	} else {
		w = x
	}
	y = 10
	z = w y / 0 >
	:while(z){
		y = y 10 *
		z = w y / 0 >
	}
	y = y 10 /
	:while(y){
		x = w y / 10 % 48 +
		:putchar(x)
		y = y 10 /
	}
	:call(pop) # restore x
	x = s
	:call(pop) # restore z
	z = s
	:call(pop) # restore w
	w = s
	:call(pop) # restore y
	y = s
}
:fun(errint){
	s = y
	:call(push) # save y
	s = w
	:call(push) # save w
	s = z
	:call(push) # save z
	s = x
	:call(push) # save x
	y = x 0 <
	:if(y){
		:raw("-")
		w = x 0 1 - *
	} else {
		w = x
	}
	y = 10
	z = w y / 0 >
	:while(z){
		y = y 10 *
		z = w y / 0 >
	}
	y = y 10 /
	:while(y){
		x = w y / 10 % 48 +
		:uchar(x)
		y = y 10 /
	}
	:call(pop) # restore x
	x = s
	:call(pop) # restore z
	z = s
	:call(pop) # restore w
	w = s
	:call(pop) # restore y
	y = s
}
# input: x
# writes: y
:fun(convertEscapableChar){
	y = x 110 == # n
	:if(y){
		y = 10 # newline
	} else {
		y = x 116 == # t
		:if(y){
			y = 9 # tab
		} else {
			y = x 39 == # '
			:if(y){
				y = 39
			} else {
				y = x 34 == # "
				:if(y){
					y = 34
				} else {
					y = x 92 == # \
					:if(y){
						y = 92
					} else {
						:throw("Invalid escape sequence. Line ")
						x = l
						:call(errint)
						:throw("\n")
						x = 1
						:exit(x)
					}
				}
			}
		}
	}
}
:fun(isValidChar){
	y = x 32 => x 126 =< & # x >= ' ' & x <= '~'
}
:fun(debug_printTokenIds){
	i = b
	c = i e <
	:while(c){
		:load(x,i)
		:call(putint)
		:raw(" ")
		i = i 5 +
		c = i e <
	}
}
:fun(debug_printType){
	:load(u,x)
	y = u 1 =!
	:if(y){
		x = u
		:call(putint)
		x = 0 30 -
		:call(errorPrintLine)
	}
	u = x 1 +
	:load(u,u)
	y = u 0 == # int
	:if(y){
		:raw("int")
	} else {
		y = u 1 == # char
		:if(y){
			:raw("char")
		} else {
			y = u 2 == # bool
			:if(y){
				:raw("bool")
			} else {
				y = u 3 == # void
				:if(y){
					:raw("void")
				} else {
					y = u 4 == # array
					:if(y){
						:raw("arr(")
						u = x 3 +
						:load(u,u) # load token addr
						u = u 2 +
						:load(u,u) # load const value
						v = x
						x = u
						:call(putint)
						:raw(", ")
						x = v
						u = x 2 + # basetype
						:load(x,u)
						:call(debug_printType)
						:raw(")")
					} else {
						y = u 5 ==
						:if(y){
							:raw("ptr(")
							u = x 2 + # basetype
							:load(x,u)
							:call(debug_printType)
							:raw(")")
						} else {
							y = u 6 ==
							:if(y){
								u = x 2 + # basetype
								:load(u,u)
								v = u 2 + # length
								:load(v,v)
								u = u 1 + # start
								:load(u,u)
								v = u v +
								y = u v <
								:while(y){
									:load(x,u)
									:putchar(x)
									u = u 1 +
									y = u v <
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(debug_printTypes){
	:raw("\nTypes:\n")
	i = e
	c = i g <
	:while(c){
		:load(x,i)
		y = x 0 == # declaration
		:if(y){
			:raw("DECL [ ")
		}
		u = x 3 == # function
		:if(u){
			v = i 3 +
			:load(v,v)
			v = v 1 =! # end
			u = u v &
		}
		:if(u){
			:raw("FUN [ ")
		}
		y = y u |
		u = x 4 == # parameter
		:if(u){
			:raw("PAR [ ")
		}
		y = y u |
		:if(y){
			z = i 1 +
			:load(x,z)
			:call(debug_printType)
			:raw(" ] ")
		} else {
			y = x 2 == # expression
			z = i 1 +
			:load(x,z)
			y = x 30 == # cast expression
			:if(y){
				:raw("CAST [ ")
				z = i 3 +
				:load(x,z)
				:call(debug_printType)
				:raw(" ] ")
			}
		}
		i = i 5 +
		c = i g <
	}
	:raw("End debug printtypes\n")
}
:fun(debug_printExpressions){
	:raw("\nExpressions:\n")
	i = e
	c = e g <
	:while(c){
		:load(x,i)
		y = x 0 ==
		:if(y){ # declaration
			x = i 2 +
			:load(x,x)
			y = x 0 1 - =!
			:if(y){
				:raw("INIT[ ")
				:call(debug_printExpression)
				:raw(" ] ")
			}
		} else {
			y = x 5 ==
			:if(y){ # return
				x = i 1 +
				:load(x,x)
				:raw("RET[ ")
				y = x 0 1 - =!
				:if(y){
					:call(debug_printExpression)
				}
				:raw(" ] ")
			} else {
				y = x 6 ==
				:if(y){ # expression stmt
					x = i 1 +
					:load(x,x)
					:raw("EXP[ ")
					:call(debug_printExpression)
					:raw(" ] ")
				} else {
					y = x 7 ==
					:if(y){ # assign
						x = i 2 +
						:load(x,x)
						:raw("ASS[ ")
						:call(debug_printExpression)
						:raw(" ]=[ ")
						x = i 3 +
						:load(x,x)
						:call(debug_printExpression)
						:raw(" ] ")
					} else {
						y = x 8 ==
						:if(y){
							x = i 1 +
							:load(x,x)
							y = x 0 == # if
							:if(y){
								x = i 2 +
								:load(x,x)
								:raw("IF[ ")
								:call(debug_printExpression)
								:raw(" ] ")
							}
						} else {
							y = x 9 ==
							:if(y){
								x = i 1 +
								:load(x,x)
								y = x 0 == # start
								:if(y){
									x = i 2 +
									:load(x,x)
									:raw("WHILE[ ")
									:call(debug_printExpression)
									:raw(" ] ")
								}
							}
						}
					}
				}
			}
		}
		i = i 5 +
		c = i g <
	}
}
:fun(debug_printExpressionExtra){
	y = u 10 == # call expression
	:if(y){
		u = 1
		:while(u){
			x = x 5 -
			:load(y,x)
			y = y 10 ==
			:if(y){
				y = x 1 +
				:load(y,y)
				:if(y){ # y : 0start, 1end
					u = u 1 +
				} else {
					u = u 1 -
				}
			}
		}
		:raw("CALL(")
		u = x 2 + # expr1 (token)
		:load(u,u) # load token addr
		:load(y,u) # check if its an ident
		y = y 2 =!
		:if(y){
			x = 0 44 -
			:call(errorPrintLine)
		}
		v = x
		x = u
		:call(printIdent)
		x = v
		:raw(")[ ")
		u = 1
		v = 0
		:while(u){
			x = x 5 +
			:load(z,x)
			y = z 10 ==
			:if(y){
				y = x 1 +
				:load(y,y)
				:if(y){ # y : 0start, 1end
					:if(v){
						v = v 1 -
					} else {
						u = 0
					}
				} else {
					v = v 1 +
				}
			} else {
				y = z 11 == v 0 == &
				:if(y){
					s = x
					:call(push)
					x = x 1 +
					:load(x,x)
					:call(debug_printExpression)
					:call(pop)
					x = s
					:raw(", ")
				}
			}
		}
		:raw(" ]")
	}
}
:fun(debug_printPrefix){
	y = u 2 ==
	:if(y){
		:raw("++")
	} else {
		y = u 3 ==
		:if(y){
			:raw("--")
		} else {
			y = u 4 ==
			:if(y){
				:raw("+")
			} else {
				y = u 5 ==
				:if(y){
					:raw("-")
				} else {
					y = u 27 ==
					:if(y){
						:raw("~")
					} else {
						y = u 28 ==
						:if(y){
							:raw("&")
						} else {
							y = u 29 ==
							:if(y){
								:raw("*")
							} else {
								y = u 30 ==
								:if(y){
									:raw("cast")
								} else {
									:raw("!")
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(debug_printExpression){
	:load(u,x)
	y = u 2 =! # check if its an expression
	:if(y){
		:call(debug_printExpressionExtra)
	} else {
		u = x 1 +
		:load(u,u)
		y = u 0 ==
		:if(y){ # postfix ++
			:raw("(")
			x = x 2 + # expr1
			:load(x,x)
			:call(debug_printExpression)
			:raw("++")
			:raw(")")
		} else {
			y = u 1 ==
			:if(y){ # postfix --
				:raw("(")
				x = x 2 + # expr1
				:load(x,x)
				:call(debug_printExpression)
				:raw("--")
				:raw(")")
			} else {
				y = u 2 => u 6 =< & u 27 => u 30 =< & |
				:if(y){ # prefix
					:raw("(")
					x = x 2 + # expr1
					:load(x,x)
					:call(debug_printPrefix)
					:call(debug_printExpression)
					:raw(")")
				} else {
					y = u 7 => u 21 =< & u 26 == |
					:if(y){ # binop
						:raw("(")
						x = x 2 + # expr1
						s = x 1 + # expr2
						:call(push) # push expr2
						s = u # op
						:call(push) # push op
						:load(x,x)
						:call(debug_printExpression)
						:call(pop) # pop op
						y = s 7 ==
						:if(y){
							:raw("*")
						} else {
							y = s 8 ==
							:if(y){
								:raw("/")
							} else {
								y = s 9 ==
								:if(y){
									:raw("%")
								} else {
									y = s 10 ==
									:if(y){
										:raw("+")
									} else {
										y = s 11 ==
										:if(y){
											:raw("-")
										} else {
											y = s 12 ==
											:if(y){
												:raw("<")
											} else {
												y = s 13 ==
												:if(y){
													:raw(">")
												} else {
													y = s 14 ==
													:if(y){
														:raw("<=")
													} else {
														y = s 15 ==
														:if(y){
															:raw(">=")
														} else {
															y = s 16 ==
															:if(y){
																:raw("==")
															} else {
																y = s 17 ==
																:if(y){
																	:raw("!=")
																} else {
																	y = s 18 ==
																	:if(y){
																		:raw("&")
																	} else {
																		y = s 19 ==
																		:if(y){
																			:raw("|")
																		} else {
																			y = s 20 ==
																			:if(y){
																				:raw("&&")
																			} else {
																				y = s 26 ==
																				:if(y){
																					:raw("^")
																				} else {
																					:raw("||")
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
						:call(pop) # pop expr2
						:load(x,s)
						:call(debug_printExpression)
						:raw(")")
					} else {
						y = u 22 ==
						:if(y){ # ident
							u = x 2 + # expr1 (token)
							:load(x,u) # load token addr
							:load(u,x)
							y = u 2 =!
							:if(y){
								x = 0 42 -
								:call(errorPrintLine)
							}
							:call(printIdent)
						} else {
							y = u 23 ==
							:if(y){ # const
								u = x 2 + # expr1 (token)
								:load(x,u) # load token addr
								:load(u,x)
								y = u 3 =!
								:if(y){
									x = 0 43 -
									:call(errorPrintLine)
								}
								u = x 2 +
								:load(x,u)
								:call(putint)
							} else {
								y = u 24 ==
								:if(y){ # array
									:raw("(")
									x = x 2 + # expr1
									s = x 1 + # expr2
									:call(push)
									:load(x,x)
									:call(debug_printExpression)
									:raw("[")
									:call(pop)
									:load(x,s)
									:call(debug_printExpression)
									:raw("])")
								} else {
									y = u 25 ==
									:if(y){ # component
										:raw("(")
										x = x 2 + # expr1
										s = x 1 + # expr2
										:call(push)
										:load(x,x)
										:call(debug_printExpression)
										:raw(".")
										:call(pop)
										:load(x,s)
										:call(printIdent)
										:raw(")")
									} else {
										y = u 31 == # pointer component
										:if(y){
											:raw("(")
											x = x 2 + # expr1
											s = x 1 + # expr2
											:call(push)
											:load(x,x)
											:call(debug_printExpression)
											:raw("->")
											:call(pop)
											:load(x,s)
											:call(printIdent)
											:raw(")")
										}
									}
								}
							}
						}
					}
				}
			}
		}	
	}
}
:fun(printIdent){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = y
	:call(push)
	u = x 1 +
	:load(u,u) # start
	v = x 2 +
	:load(v,v) # length
	v = u v +
	y = u v <
	:while(y){
		:load(x,u)
		:putchar(x)
		u = u 1 +
		y = u v <
	}
	:call(pop)
	y = s
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
:fun(errorIdent){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = y
	:call(push)
	u = x 1 +
	:load(u,u) # start
	v = x 2 +
	:load(v,v) # length
	v = u v +
	y = u v <
	:while(y){
		:load(x,u)
		:uchar(x)
		u = u 1 +
		y = u v <
	}
	:call(pop)
	y = s
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
# input: x,y
# output: y
:fun(identEquals){
	s = t
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = z
	:call(push)
	##
	z = 0
	:if(z){
		z = x
		:raw(" ( ")
		:call(printIdent)
		:raw(" ")
		x = y
		:call(printIdent)
		:raw(" ) ")
		x = z
	}
	##
	u = x 2 + # ident1 length
	:load(u,u)
	v = y 2 + # ident2 length
	:load(v,v)
	z = u v ==
	:if(z){
		x = x 1 + # ident1 start
		:load(x,x)
		y = y 1 + # ident2 start
		:load(y,y)
		t = 0 # counter
		z = u # length
		u = t z <
		:while(u){
			u = x t +
			:load(u,u)
			v = y t +
			:load(v,v)
			u = u v ==
			:if(u){
				t = t 1 +
				u = t z <
			}
		}
		y = t z ==
	} else {
		y = 0
	}
	:call(pop)
	z = s
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	t = s
}
#
# Errors
#
:fun(errorExpectedX){
	:throw("Expected ")
	:putchar(x)
	:throw(", found token type ")
	:load(x,i)
	:call(errint)
	:throw(". ")
	x = i 3 +
	:load(x,x)
	:call(errorPrintLine)
}
:fun(errorUnmatchedToken){
	:throw("Unmatched token (type ")
	:load(x,i)
	:call(errint)
	:throw("). ")
	x = i 3 +
	:load(x,x)
	:call(errorPrintLine)
}
:fun(errorEOFcomment){
	:throw("EOF reached while parsing comment.")
	x = 1
	:exit(x)
}
:fun(errorInvalidCharConstant){
	:throw("Invalid char constant. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorLeadingZero){
	:throw("Invalid int constant (leading zeros). ")
	x = l
	:call(errorPrintLine)
}
:fun(errorConstantTooBig){
	:throw("Invalid int constant (too big). ")
	x = l
	:call(errorPrintLine)
}
:fun(errorInvalidCharInString){
	:throw("Invalid char encountered in string literal. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorUnmatchedChar){
	:throw("Unmatched char '")
	:load(x,i)
	:uchar(x)
	:throw("'. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorPrintLine){
	:throw("Line ")
	:call(errint)
	:throw("\n")
	x = 1
	:exit(x)
}
