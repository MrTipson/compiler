#abc
#def
#ghi
:fun(main){
	d = 1 # debug
	a = 0
	:call(readFile)
	b = m
	:call(tokenize)
	:exit(a)
}
#
# Phase 1 - Tokenize
#
:fun(tokenize){
	:if(d){
		:raw("Phase 1 - Tokenization\n")
	}
	l = 1 # line count
	i = 0 # file index
	c = i < b # read through the file
	:while(c){
		f = 1 # flag for matches ( 0 => stop trying to match)
		:call(tokenize_isComment)
		:if(f){
			:call(tokenize_isWhitespace)
			:if(f){
				:call(tokenize_isKeyword)
				:if(f){
					:call(tokenize_isConstant)
					:if(f){
						:call(tokenize_isSymbol)
						:if(f){
							:call(tokenize_isIdentifier)
							:if(f){
								:call(errorUnmatchedChar)
							}
						}
					}
				}
			}
		}
		c = i < b # Update condition
	}
}
# Match comment
:fun(tokenize_isComment){
	:load(x,i)
	y = x == 35 # '#'
	:if(y){
		f = 0 # set match flag
		i = i + 1 # increment file index
		:load(x,i)
		y = x =! 10 # skip characters until end of line
		:while(y){
			i = i + 1 # increment file index
			:load(x,i)
			y = x =! 10 # newline
		}
	}
}
# Match whitespace
:fun(tokenize_isWhitespace){
	:load(x,i)
	y = x == 10 # \n
	:if(y){
		l = l + 1 # increment line counter
	}
	z = x == 9 # \t
	y = y | z
	z = x == 32 # space
	y = y | z
	:if(y){
		f = 0 # set match flag
		:while(y){
			i = i + 1
			:load(x,i)
			y = x == 10 # \n
			:if(y){
				l = l + 1 # increment line counter
			}
			z = x == 9 # \t
			y = y | z
			z = x == 32 # space
			y = y | z
		}
	}
}
# Match keywords
:fun(tokenize_isKeyword){
	w = i # save file index if match fails
	# Preload 4 characters in t,u,v,z
	:load(p,i)
	i = i + 1
	:load(q,i)
	i = i + 1
	:load(r,i)
	i = i + 1
	:load(s,i)
	i = i + 1
	:load(t,i)
	:call(tokenize_isKeyword_bool)
	:if(f){
		:call(tokenize_isKeyword_char)
		:if(f){
			:call(tokenize_isKeyword_int)
			:if(f){
				:call(tokenize_isKeyword_void)
				:if(f){
					:call(tokenize_isKeyword_if)
					:if(f){
						:call(tokenize_isKeyword_else)
						:if(f){
							:call(tokenize_isKeyword_while)
						}
					}
				}
			}
		}
	}
	:if(f){
		i = w # restore file index if no match was found
	}
}
# input x
# output y
# writes: u,v,y
:fun(tokenize_isKeyword_helper){ # check if char is not identifier
	y = x < 48 # 0
	u = x > 57 # 9
	v = x < 65 # A
	u = u & v
	y = y | u
	u = x > 90 # Z
	v = x < 97 # a
	u = u & v
	v = x =! 95 # _
	u = u & v
	y = y | u
	u = x > 122 # z
	y = y | u
}
# input: loaded p,q,r,s,t
# output: sets r, writes memory
# write: x,y,m
# calls: tokenize_isKeyword_helper
:fun(tokenize_isKeyword_bool){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 98 # b
	y = y & x
	x = q == 111 # o
	y = y & x
	x = r == 111 # o
	y = y & x
	x = s == 108 # l
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (bool)
		:store(x,m)
		m = m + 1
		m = m + 1 # skip optional field
		:if(d){
			:raw("BOOL ")
		}
	}
}
:fun(tokenize_isKeyword_char){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 99 # c
	y = y & x
	x = q == 104 # h
	y = y & x
	x = r == 97 # a
	y = y & x
	x = s == 114 # r
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 1 # id 1 (char)
		:store(x,m)
		m = m + 1
		m = m + 1 # skip optional field
		:if(d){
			:raw("CHAR ")
		}
	}
}
:fun(tokenize_isKeyword_int){
	x = s # 4th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 105 # i
	y = y & x
	x = q == 110 # n
	y = y & x
	x = r == 116 # t
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 0 # id 0 (int)
		:store(x,m)
		m = m + 1
		m = m + 1 # skip optional field
		# i is too far
		i = i - 1
		:if(d){
			:raw("INT ")
		}
	}
}
:fun(tokenize_isKeyword_void){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 118 # v
	y = y & x
	x = q == 111 # o
	y = y & x
	x = r == 105 # i
	y = y & x
	x = s == 100 # d
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 0 # type 0
		:store(x,m)
		m = m + 1
		x = 3 # id 3 (void)
		:store(x,m)
		m = m + 1
		m = m + 1 # skip optional field
		:if(d){
			:raw("VOID ")
		}
	}
}
:fun(tokenize_isKeyword_if){
	x = r # 3rd character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 105 # i
	y = y & x
	x = q == 102 # f
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 11 # type 11
		:store(x,m)
		m = m + 3 # skip optional field
		# i is too far since most keywords are 4 chars long
		i = i - 2
		:if(d){
			:raw("IF ")
		}
	}
}
:fun(tokenize_isKeyword_else){
	x = t # 5th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 101 # e
	y = y & x
	x = q == 108 # l
	y = y & x
	x = r == 115 # s
	y = y & x
	x = s == 101 # e
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 12 # type 1
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("ELSE ")
		}
	}
}
:fun(tokenize_isKeyword_while){
	:load(x,i) # 6th character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	x = p == 119 # w
	y = y & x
	x = q == 104 # h
	y = y & x
	x = r == 105 # i
	y = y & x
	x = s == 108 # l
	y = y & x
	x = t == 101 # e
	y = y & x
	:if(y){ # match
		f = 0 # set match flag
		x = 13 # type 1
		:store(x,m)
		m = m + 3 # skip optional field
		i = i + 1 # increment file (we loaded but didnt increment)
		:if(d){
			:raw("WHILE ")
		}
	}
}
:fun(tokenize_isSymbol){
	:load(x,i)
	:call(tokenize_isSymbol_ADDEQ)
	:if(f){
		:call(tokenize_isSymbol_SUBEQ)
		:if(f){
			:call(tokenize_isSymbol_DIVEQ)
			:if(f){
				:call(tokenize_isSymbol_MULEQ)
				:if(f){
					:call(tokenize_isSymbol_INC)
					:if(f){
						:call(tokenize_isSymbol_DEC)
						:if(f){
							:call(tokenize_isSymbol_EQ)
							:if(f){
								:call(tokenize_isSymbol_NEQ)
								:if(f){
									:call(tokenize_isSymbol_LEQ)
									:if(f){
										:call(tokenize_isSymbol_GEQ)
										:if(f){
											:call(tokenize_isSymbol_AND)
											:if(f){
												:call(tokenize_isSymbol_OR)
												:if(f){
													:call(tokenize_isSymbol_LPARENT)
													:if(f){
														:call(tokenize_isSymbol_RPARENT)
														:if(f){
															:call(tokenize_isSymbol_LCURLY)
															:if(f){
																:call(tokenize_isSymbol_RCURLY)
																:if(f){
																	:call(tokenize_isSymbol_LBRACK)
																	:if(f){
																		:call(tokenize_isSymbol_RBRACK)
																		:if(f){
																			:call(tokenize_isSymbol_PERIOD)
																			:if(f){
																				:call(tokenize_isSymbol_COMMA)
																				:if(f){
																					:call(tokenize_isSymbol_SEMICOLON)
																					:if(f){
																						:call(tokenize_isSymbol_COLON)
																						:if(f){
																							:call(tokenize_isSymbol_EXCL)
																							:if(f){
																								:call(tokenize_isSymbol_ASSIGN)
																								:if(f){
																									:call(tokenize_isSymbol_BITAND)
																									:if(f){
																										:call(tokenize_isSymbol_BITOR)
																										:if(f){
																											:call(tokenize_isSymbol_LT)
																											:if(f){
																												:call(tokenize_isSymbol_GT)
																												:if(f){
																													:call(tokenize_isSymbol_MUL)
																													:if(f){
																														:call(tokenize_isSymbol_DIV)
																														:if(f){
																															:call(tokenize_isSymbol_MOD)
																															:if(f){
																																:call(tokenize_isSymbol_ADD)
																																:if(f){
																																	:call(tokenize_isSymbol_SUB)
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
:fun(tokenize_isSymbol_ADDEQ){
	y = x == 43 # +
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 4
		:store(x,m)
		m = m + 1
		x = 1 # id 1 (+=)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("ADDEQ ")
		}
	}
}
:fun(tokenize_isSymbol_SUBEQ){
	y = x == 45 # -
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (-=)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("SUBEQ ")
		}
	}
}
:fun(tokenize_isSymbol_DIVEQ){
	y = x == 47 # /
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 3 # id 3 (/=)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("DIVEQ ")
		}
	}
}
:fun(tokenize_isSymbol_MULEQ){
	y = x == 42 # *
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 4 # id 4 (*=)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("MULEQ ")
		}
	}
}
:fun(tokenize_isSymbol_INC){
	y = x == 43 # +
	z = i + 1
	:load(z,z)
	z = z == 43 # +
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 25 # type 25
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("INC ")
		}
	}
}
:fun(tokenize_isSymbol_DEC){
	y = x == 45 # -
	z = i + 1
	:load(z,z)
	z = z == 45 # -
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 26 # type 26
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("DEC ")
		}
	}
}
:fun(tokenize_isSymbol_EQ){
	y = x == 61 # =
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (==)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("EQ ")
		}
	}
}
:fun(tokenize_isSymbol_NEQ){
	y = x == 33 # !
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 3 # id 3 (!=)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("NEQ ")
		}
	}
}
:fun(tokenize_isSymbol_LEQ){
	y = x == 60 # <
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 6 # id 6 (<=)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("LEQ ")
		}
	}
}
:fun(tokenize_isSymbol_GEQ){
	y = x == 62 # >
	z = i + 1
	:load(z,z)
	z = z == 61 # =
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 7 # id 7 (>=)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("GEQ ")
		}
	}
}
:fun(tokenize_isSymbol_AND){
	y = x == 38 # &
	z = i + 1
	:load(z,z)
	z = z == 38 # &
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 13 # id 13 (&&)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("AND ")
		}
	}
}
:fun(tokenize_isSymbol_OR){
	y = x == 124 # |
	z = i + 1
	:load(z,z)
	z = z == 124 # |
	y = y & z
	:if(y){
		i = i + 2
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 14 # id 14 (||)
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("OR ")
		}
	}
}
:fun(tokenize_isSymbol_LPARENT){
	y = x == 40 # (
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 14 # type 14
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("LPARENT ")
		}
	}
}
:fun(tokenize_isSymbol_RPARENT){
	y = x == 41 # )
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 15 # type 15
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("RPARENT ")
		}
	}
}
:fun(tokenize_isSymbol_LCURLY){
	y = x == 123 # {
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 16 # type 16
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("LCURLY ")
		}
	}
}
:fun(tokenize_isSymbol_RCURLY){
	y = x == 125 # {
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 17 # type 17
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("RCURLY ")
		}
	}
}
:fun(tokenize_isSymbol_LBRACK){
	y = x == 91 # [
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 18 # type 18
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("LBRACK ")
		}
	}
}
:fun(tokenize_isSymbol_RBRACK){
	y = x == 93 # ]
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 19 # type 19
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("RBRACK ")
		}
	}
}
:fun(tokenize_isSymbol_PERIOD){
	y = x == 46 # .
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 20 # type 20
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("PERIOD ")
		}
	}
}
:fun(tokenize_isSymbol_COMMA){
	y = x == 44 # ,
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 21 # type 16
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("COMMA ")
		}
	}
}
:fun(tokenize_isSymbol_SEMICOLON){
	y = x == 59 # ;
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 22 # type 22
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("SEMICOLON ")
		}
	}
}
:fun(tokenize_isSymbol_COLON){
	y = x == 58 # :
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 23 # type 23
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("COLON ")
		}
	}
}
:fun(tokenize_isSymbol_ASSIGN){
	y = x == 61 # =
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 1 # type 1
		:store(x,m)
		m = m + 1
		x = 0 # id 0
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("ASSIGN ")
		}
	}
}
:fun(tokenize_isSymbol_EXCL){
	y = x == 33 # !
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 24 # type 24
		:store(x,m)
		m = m + 3 # skip optional field
		:if(d){
			:raw("EXCL ")
		}
	}
}
:fun(tokenize_isSymbol_BITAND){
	y = x == 38 # &
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 0 # id 0
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("BITAND ")
		}
	}
}
:fun(tokenize_isSymbol_BITOR){
	y = x == 124 # |
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 1 # id 1
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("BITOR ")
		}
	}
}
:fun(tokenize_isSymbol_LT){
	y = x == 60 # <
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 4 # id 4
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("LT ")
		}
	}
}
:fun(tokenize_isSymbol_GT){
	y = x == 62 # >
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 5 # id 5
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("GT ")
		}
	}
}
:fun(tokenize_isSymbol_MUL){
	y = x == 42 # *
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 8 # id 8
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("MUL ")
		}
	}
}
:fun(tokenize_isSymbol_DIV){
	y = x == 47 # /
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 9 # id 9
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("DIV ")
		}
	}
}
:fun(tokenize_isSymbol_MOD){
	y = x == 37 # %
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 10 # id 10
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("MOD ")
		}
	}
}
:fun(tokenize_isSymbol_ADD){
	y = x == 43 # +
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 11 # id 11
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("ADD ")
		}
	}
}
:fun(tokenize_isSymbol_SUB){
	y = x == 45 # -
	:if(y){
		i = i + 1
		f = 0 # set match flag
		x = 4 # type 4
		:store(x,m)
		m = m + 1
		x = 12 # id 12
		:store(x,m)
		m = m + 2 # skip optional field
		:if(d){
			:raw("SUB ")
		}
	}
}
:fun(tokenize_isConstant){
	:call(tokenize_isConstant_false)
	:if(f){
		:call(tokenize_isConstant_true)
		:if(f){
			:call(tokenize_isConstant_char)
			:if(f){
				:call(tokenize_isConstant_int)
				:if(f){
					:call(tokenize_isConstant_string)
				}
			}
		}
	}
}
:fun(tokenize_isConstant_true){
	:load(p,i)
	z = i + 1
	:load(q,z)
	z = z + 1
	:load(r,z)
	z = z + 1
	:load(s,z)
	z = z + 1
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	z = p == 116 # t 
	y = y & z
	z = q == 114 # r
	y = y & z
	z = r == 117 # u
	y = y & z
	z = s == 101 # e
	y = y & z
	:if(y){
		i = i + 4
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (constant(bool))
		:store(x,m)
		m = m + 1
		x = 1
		:store(x,m)
		m = m + 1 # skip optional field
		:if(d){
			:raw("CBOOL(1) ")
		}
	}
}
:fun(tokenize_isConstant_false){
	:load(p,i)
	z = i + 1
	:load(q,z)
	z = z + 1
	:load(r,z)
	z = z + 1
	:load(s,z)
	z = z + 1
	:load(t,z)
	z = z + 1
	:load(x,z)
	:call(tokenize_isKeyword_helper)
	z = p == 102 # f 
	y = y & z
	z = q == 97 # a
	y = y & z
	z = r == 108 # l
	y = y & z
	z = s == 115 # s
	y = y & z
	z = t == 101 # e
	y = y & z
	:if(y){
		i = i + 5
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 2 # id 2 (constant(bool))
		:store(x,m)
		m = m + 1
		x = 0
		:store(x,m)
		m = m + 1 # skip optional field
		:if(d){
			:raw("CBOOL(0) ")
		}
	}
}
:fun(tokenize_isConstant_char){
	:load(p,i)
	z = i + 1
	:load(q,z)
	x = q
	:call(isValidChar)
	x = p == 39 # '
	y = y & x
	:if(y){
		z = z + 1
		y = q == 92 # \
		:if(y){
			:load(x,z)
			:call(convertEscapableChar)
			w = y
			z = z + 1
			:load(p,z)
			y = p == 39 # '
			:if(y){
				i = i + 4
				f = 0 # set flag
				x = 3 # type 3
				:store(x,m)
				m = m + 1
				x = 1 # id 1 (constant(char))
				:store(x,m)
				m = m + 1
				x = w
				:store(x,m)
				m = m + 1 # skip optional field
				:if(d){
					:raw("CCHAR(")
					:call(putint)
					:raw(") ")
				}
			} else {
				:call(errorInvalidCharConstant)
			}
		} else {
			:load(r,z)
			y = r == 39 # '
			:if(y){
				i = i + 3
				f = 0 # set flag
				x = 3 # type 0
				:store(x,m)
				m = m + 1
				x = 1 # id 1 (constant(char))
				:store(x,m)
				m = m + 1
				x = q
				:store(x,m)
				m = m + 1 # skip optional field
				:if(d){
					:raw("CCHAR(")
					:call(putint)
					:raw(") ")
				}
			} else {
				:call(errorInvalidCharConstant)
			}
		}
	}
}
:fun(tokenize_isConstant_int){
	w = i
	:load(x,i)
	s = 1
	y = x == 45 # -
	:if(y){
		s = -1
		i = i + 1
		:load(x,i)
	}
	y = x => 48 # 0
	u = x =< 57 # 9
	y = y & u
	v = x == 48 # 0
	:if(y){
		z = 0
		:while(y){
			z = z * 10
			y = z < 0
			:if(y){
				:call(errorConstantTooBig)
			}
			x = x - 48
			z = z + x
			i = i + 1
			:load(x,i)
			y = x => 48 # 0
			u = x =< 57 # 9
			y = y & u
			v = v & y
			:if(v){
				:call(errorLeadingZero)
			}
		}
		z = z * s
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 0 # id 0 (constant(int))
		:store(x,m)
		m = m + 1
		x = z
		:store(x,m)
		m = m + 1 # skip optional field
		:if(d){
			:raw("CINT(")
			x = z
			:call(putint)
			:raw(") ")
		}
	} else {
		i = w
	}
}
:fun(tokenize_isConstant_string){
	:load(x,i)
	y = x == 34 # "
	:if(y){
		z = i
		:while(y){
			i = i + 1
			:load(x,i)
			y = x == 92 # \
			:if(y){
				i = i + 1
				:load(x,i)
				:call(convertEscapableChar)
				y = 1
			} else {
				:call(isValidChar)
				y = 1 - y
				:if(y){
					:call(errorInvalidCharInString)
				}
				y = x =! 34 # "
			}
		}
		i = i + 1 # move past "
		f = 0 # set flag
		x = 3 # type 3
		:store(x,m)
		m = m + 1
		x = 3 # id 3 (constant(int))
		:store(x,m)
		m = m + 1
		x = z
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("CSTRING(")
			:load(x,z)
			:putchar(x)
			z = z + 1
			y = 1
			:while(y){
				:load(x,z)
				z = z + 1
				:putchar(x)
				w = x == 92 # \
				:if(w){
					:load(x,z)
					z = z + 1
					:putchar(x)
				} else {
					w = x == 34 # "
					:if(w){
						y = 0
					}
				}
			}
			:raw(") ")
		}
	}
}
:fun(tokenize_isIdentifier){
	:load(x,i)
	z = i
	w = 0 # length
	y = x == 95 # _
	u = x => 65 # A
	v = x =< 90 # Z
	u = u & v
	y = y | u
	u = x => 97 # a
	v = x =< 122 # z
	u = u & v
	y = y | u
	:if(y){
		f = 0 # set match flag
		:while(y){
			w = w + 1
			i = i + 1
			:load(x,i)
			:call(tokenize_isKeyword_helper) # returns 1 in y if its NOT an identifier char
			y = 1 - y
		}
		f = 0 # set flag
		x = 2 # type 2
		:store(x,m)
		m = m + 1
		x = z # start of identifier
		:store(x,m)
		m = m + 1
		x = w # length of identifier
		:store(x,m)
		m = m + 1
		:if(d){
			:raw("IDENT(")
			w = z + w # end
			y = z < w
			:while(y){
				:load(x,z)
				:putchar(x)
				z = z + 1
				y = z < w
			}
			:raw(") ")
		}
	}
}
#
# Phase 0 - Read file
#
:fun(readFile){
	:getchar(x)
	:while(x){
		:store(x,m)
		m = m + 1
		:getchar(x)
	}
}
#
# Utility functions
#
:fun(putint){
	y = x < 0
	:if(y){
		:raw("-")
		w = x * -1
	} else {
		w = x
	}
	y = 10
	x = w / y
	z = x > 0
	:while(z){
		y = y * 10
		x = w / y
		z = x > 0
	}
	y = y / 10
	:while(y){
		x = w / y
		x = x % 10
		x = x + 48
		:putchar(x)
		y = y / 10
	}
}
# input: x
# writes: y
:fun(convertEscapableChar){
	y = x == 110 # n
	:if(y){
		y = 10 # newline
	} else {
		y = x == 116 # t
		:if(y){
			y = 9 # tab
		} else {
			y = x == 39 # '
			:if(y){
				y = 39
			} else {
				y = x == 34 # "
				:if(y){
					y = 34
				} else {
					y = x == 92 # \
					:if(y){
						y = 92
					} else {
						:raw("Invalid escape sequence. Line ")
						x = l
						:call(putint)
						:raw("\n")
						x = 1
						:exit(x)
					}
				}
			}
		}
	}
}
:fun(isValidChar){
	y = x => 32 # space
	u = x =< 126 # ~
	y = y & u
}
#
# Errors
#
:fun(errorInvalidCharConstant){
	:raw("Invalid char constant. ")
	:call(errorPrintLine)
}
:fun(errorLeadingZero){
	:raw("Invalid int constant (leading zeros). ")
	:call(errorPrintLine)
}
:fun(errorConstantTooBig){
	:raw("Invalid int constant (too big). ")
	:call(errorPrintLine)
}
:fun(errorInvalidCharInString){
	:raw("Invalid char encountered in string literal. ")
	:call(errorPrintLine)
}
:fun(errorUnmatchedChar){
	:raw("Unmatched char '")
	:load(x,i)
	:putchar(x)
	:raw("' in file. ")
	:call(errorPrintLine)
}
:fun(errorPrintLine){
	:raw("Line ")
	x = l
	:call(putint)
	:raw("\n")
	x = 1
	:exit(x)
}
