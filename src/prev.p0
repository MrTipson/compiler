:fun(main){
	d = 1 # debug
	:if(d){
		:raw("/*\n")
	}
	a = 20000 # stack pointer
	:call(readFile)
	b = m
	:call(tokenize)
	# c = condition, d = debug, so next var is e
	e = m
	:call(syntax)
	# f = flag
	g = m
	:if(d){
		:call(debug_printExpressions)
		:call(debug_printTypes)
	}
	:call(semantics)
	h = m
	:call(memory)
	j = m
	:if(d){
		:raw("\nPhase 5 - Code generation\n*/\n")
	}
	:call(codegen)
}
#
# Phase 5 - Code generation
#
:fun(codegen){
	i = e
	c = 0
	q = 0 # function flag
	f = 0 1 - # current function ident
	:raw(".syntax\tunified\n\n.text\n.align\t1\n\n")
	:while(i g <){
		:load(x,i)
		:if(x 5 ==){ # return
			:load(x,i 1 +)
			:if(x 0 1 - =!){ # return has expression
				y = 1
				:call(codegen_expression)
			}
			:raw("\tb\tFE")
			x = f
			:call(printIdent)
			:raw("\n")
		} elif(x 6 ==){ # expression statement
			:load(x,i 1 +)
			y = 1
			:call(codegen_expression)
		} elif(x 7 ==){ # assignment
			:call(codegen_assign)
		} elif(x 8 ==){ # if/else
			:load(x,i 1 +)
			:if(x 0 ==){ # if
				#:raw("IF")
				:load(x,i 2 +) # expr
				y = 1
				:call(codegen_expression)
				:raw("\tcmp\tr0,#0\n\tbeq\tLneg_")
				x = c
				:call(putint)
				:raw("\n")
				s = c
				:call(push)
				c = c 1 +
				s = 1 # flag to print neg label
				:call(push)
			} elif(x 1 ==){ # else
				#:raw("ELSE")
				:call(pop)
				:call(pop)
				x = s
				:raw("\tb\tLend_")
				:call(putint)
				:raw("\nLneg_")
				:call(putint)
				:raw(":\n")
				s = x
				:call(push)
				s = 0
				:call(push)
			} else {
				#:raw("ENDIF")
				:call(pop)
				y = s
				:call(pop)
				x = s
				:if(y){
					:raw("Lneg_")
					:call(putint)
					:raw(":\n")
				}
				:raw("Lend_")
				:call(putint)
				:raw(":\n")
			}
		} elif(x 9 ==){ # while
			:load(x,i 1 +)
			:if(x 0 ==){ # start
				:raw("Lcond_")
				x = c
				c = c 1 +
				:call(putint)
				:raw(":\n")
				s = x
				:call(push)
				:load(x,i 2 +) # cond
				y = 1
				:call(codegen_expression)
				:raw("\tcmp\tr0,#0\n\tbeq\tLend_")
				:load(x,a 1 +)
				:call(putint)
				:raw("\n")
			} else {
				:raw("\tb\tLcond_")
				:call(pop)
				x = s
				:call(putint)
				:raw("\nLend_")
				:call(putint)
				:raw(":\n")
			}
		} elif(x 3 ==){ # function
			:load(x,i 3 +)
			:if(x 0 ==){ # start
				q = 1
				:load(x,i 2 +)
				:call(codegen_isMain)
				:if(y){
					:raw(".global\t_start\n_start:\n\tadd\tr2,sp,#4\n\tstr\tr2,[sp,#-4]\n\tsub\tsp,sp,#4\n\tbl\tFmain\n\tmov\tr7,#1\n\tsvc\t0\n")
				}
				:raw("\n.global F")
				:call(printIdent)
				:raw("\nF")
				:call(printIdent)
				f = x
				:raw(":\n")
				:load(x,i 4 +) # function end pointer
				:load(u,x 2 +) # frame size
				:load(v,x 4 +) # params size
				:raw("\tldr\tr1,=")
				x = u v -
				:call(putint)
				:raw("\n\tsub\tsp,sp,r1\n\tstr\tfp,[sp,#4]\n\tstr\tlr,[sp]\n\tldr\tr1,=")
				x = u
				:call(putint)
				:raw("\n\tadd\tfp,sp,r1\n")
			} else {
				:if(x 1 == q &){ # x == end & q == 1 (inside function flag)
					:raw("\tmov\tr0,#0\nFE")
					x = f
					:call(printIdent)
					:raw(":\n\tldr\tfp,[sp,#4]\n\tldr\tlr,[sp]\n")
					:load(x,i 2 +) # frame size
					:raw("\tldr\tr1,=")
					:call(putint)
					:raw("\n\tadd\tsp,sp,r1\n\tbx\tlr\n")
					q = 0
				}
			}
		} else {
			:call(codegen_extra)
		}
		i = i 5 +
	}
	:call(codegen_dataseg)
}
:fun(codegen_extra){
	y = x 0 == # declaration
	:load(x,i 2 +) # expr
	:if(y x 0 1 - =! &){ # declaration that has an expression (x != -1)
		y = 1
		:call(codegen_expression)
		:load(x,i 4 +)
		:if(x 0 =!){
			:raw("\tldr\tr1,=")
			:call(putint)
			:raw("\n\tsub\tr1,fp,r1\n")
		} else {
			:raw("\tldr\tr1,=V")
			:load(x,i 3 +) # ident
			:call(printIdent)
			:raw("\n")
		}
		:load(x,i 1 +)
		:call(memory_getTypeSize)
		:if(y 1 ==){
			:raw("\tstrb\tr0,[r1]\n")
		} elif(y 4 ==){
			:raw("\tstr\tr0,[r1]\n")
		} else {
			:call(errorInternal)
		}
	}
}
:fun(codegen_assign){
	:load(v,i 2 +) # expr1
	x = v
	y = 0
	:call(codegen_expression)
	:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
	:load(x,i 3 +) # expr2
	y = 1
	:call(codegen_expression)
	:load(x,v 4 +) # expression type
	:call(memory_getTypeSize)
	v = y
	:load(x,i 1 +) # type of assignment
	:raw("\tldr\tr1,[sp],#4\n")
	:if(x 0 ==){ # =
		:if(v 1 ==){
			:raw("\tstrb\tr0,[r1]\n")
		} elif(v 4 ==){
			:raw("\tstr\tr0,[r1]\n")
		} else {
			:call(errorInternal)
		}
	} elif(x 1 ==){ # +=
		:if(v 1 ==){ # byte
			:raw("\tldrb\tr2,[r1]\n\tadd\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
		} elif(v 4 ==){ # word
			:raw("\tldr\tr2,[r1]\n\tadd\tr0,r2,r0\n\tstr\tr0,[r1]\n")
		} else {
			:call(errorInternal)
		}
	} elif(x 2 ==){ # -=
		:if(v 1 ==){ # byte
			:raw("\tldrb\tr2,[r1]\n\tsub\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
		} elif(v 4 ==){ # word
			:raw("\tldr\tr2,[r1]\n\tsub\tr0,r2,r0\n\tstr\tr0,[r1]\n")
		} else {
			:call(errorInternal)
		}
	} elif(x 3 ==){ # /=
		:if(v 1 ==){ # byte
			:raw("\tldrb\tr2,[r1]\n\tsdiv\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
		} elif(v 4 ==){ # word
			:raw("\tldr\tr2,[r1]\n\tsdiv\tr0,r2,r0\n\tstr\tr0,[r1]\n")
		} else {
			:call(errorInternal)
		}
	} elif(x 4 ==){ # *=
		:if(v 1 ==){ # byte
			:raw("\tldrb\tr2,[r1]\n\tmul\tr0,r2,r0\n\tstrb\tr0,[r1]\n")
		} elif(v 4 ==){ # word
			:raw("\tldr\tr2,[r1]\n\tmul\tr0,r2,r0\n\tstr\tr0,[r1]\n")
		} else {
			:call(errorInternal)
		}
	}
}
:fun(codegen_dataseg){
	:raw("\n.data\n")
	i = h
	:while(i j <){
		:load(u,i)
		:load(x,u)
		:if(x 3 ==){ # string literal
			:load(x,u 3 +)
			:raw("S")
			:call(putint)
			:raw(": .asciz ")
			:load(u,u 2 +) # start
			:load(x,u)
			:putchar(x) # this should be opening "
			u = u 1 +
			x = 0
			:while(x 34 =!){ # break out after printing closing "
				:load(x,u)
				:putchar(x)
				u = u 1 +
			}
		} elif(x 0 ==){ # declaration
			:load(x,u 1 +) # declaration type
			:load(v,x 1 +) # type type
			:call(memory_getTypeSize)
			w = y # save type size for later
			:raw("V")
			:load(x,u 3 +) # ident
			:call(printIdent)
			:if(v 6 == v 4 == |){ # name | array
				:raw(": .space ")
				x = w
				:call(putint)
			} elif(w 1 ==){ # byte
				:raw(": .byte ")
			} elif(w 4 ==){ # word
				:raw(": .word ")
			} else {
			:call(errorInternal)
			}
			:load(x,u 2 +) # expression
			:load(x,x 2 +) # expr1
			:load(y,x 1 +) # constant type
			:if(y 3 ==){ # string literal
				x = x 3 + # string id
				:raw("S")
			} else {
				x = x 2 + # value
			}
			:load(x,x)
			:call(putint)
		} else {
			:call(errorInternal)
		}
		:raw("\n")
		i = i 1 +
	}
}
# x expression, y 0noload, 1load
# expressions 0,1,2,3,24,25,28
:fun(codegen_expression){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = y
	:call(push)
	:load(u,x)
	:if(u 2 ==){ # expression
		:load(u,x 1 +)
		# Postfix increment - Prefix decrement, array access, component access, pointer &
		:if(u 0 => u 3 =< & u 24 == | u 25 == | u 28 == |){
			v = x
			:load(x,x 2 +)
			y = 0
			:call(codegen_expression) # result is in r0
			x = v
			:if(u 0 ==){ # postf ++
				:load(x,x 4 +) # type
				:load(y,x 1 +)
				:if(y 5 ==){ # pointer
					:load(x,x 2 +) # basetype
					:call(memory_getTypeSize)
					:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\n\tadd\tr2,r1,r2\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
				} else {
					:call(memory_getTypeSize)
					:if(y 1 ==){ # byte
						:raw("\tldrb\tr1,[r0]\n\tadd\tr2,r1,#1\n\tstrb\tr2,[r0]\n\tmov\tr0,r1\n")
					} elif(y 4 ==){ # word
						:raw("\tldr\tr1,[r0]\n\tadd\tr2,r1,#1\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
					} else {
						:call(errorInternal)
					}
				}
			} elif(u 1 ==){ # postf --
				:load(x,x 4 +) # type
				:load(y,x 1 +) # type type
				:if(y 5 ==){ # pointer
					:load(x,x 2 +) # basetype
					:call(memory_getTypeSize)
					:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\nsub\tr2,r1,r2\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
				} else {
					:call(memory_getTypeSize)
					:if(y 1 ==){ # byte
						:raw("\tldrb\tr1,[r0]\n\tsub\tr2,r1,#1\n\tstrb\tr2,[r0]\n\tmov\tr0,r1\n")
					} elif(y 4 ==){ # word
						:raw("\tldr\tr1,[r0]\n\tsub\tr2,r1,#1\n\tstr\tr2,[r0]\n\tmov\tr0,r1\n")
					} else {
						:call(errorInternal)
					}
				}
			} elif(u 2 ==){ # pref ++
				:load(x,x 4 +) # type
				:load(y,x 1 +) # type type
				:if(y 5 ==){ # pointer
					:load(x,x 2 +) # basetype
					:call(memory_getTypeSize)
					:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\n\tadd\tr1,r1,r2\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
				} else {
					:call(memory_getTypeSize)
					:if(y 1 ==){ # byte
						:raw("\tldrb\tr1,[r0]\n\tadd\tr1,r1,#1\n\tstrb\tr1,[r0]\n\tmov\tr0,r1\n")
					} elif(y 4 ==){ # word
						:raw("\tldr\tr1,[r0]\n\tadd\tr1,r1,#1\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
					} else {
						:call(errorInternal)
					}
				}
			} elif(u 3 ==){ # pref --
				:load(x,x 4 +) # type
				:load(y,x 1 +) # type type
				:if(y 5 ==){ # pointer
					:load(x,x 2 +) # basetype
					:call(memory_getTypeSize)
					:raw("\tldr\tr1,[r0]\n\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\nsub\tr1,r1,r2\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
				} else {
					:call(memory_getTypeSize)
					:if(y 1 ==){ # byte
						:raw("\tldrb\tr1,[r0]\n\sub\tr1,r1,#1\n\tstrb\tr1,[r0]\n\tmov\tr0,r1\n")
					} elif(y 4 ==){ # word
						:raw("\tldr\tr1,[r0]\n\tsub\tr1,r1,#1\n\tstr\tr1,[r0]\n\tmov\tr0,r1\n")
					} else {
						:call(errorInternal)
					}
				}
			} elif(u 24 ==){ # array access
				:load(v,x 2 +) # expr1
				:load(v,v 4 +) # expr1 type
				:load(v,v 1 +) # expr1 type type
				:if(v 5 ==){ # pointer
					:raw("\tldr\tr0,[r0]\n") # load pointer value
				}
				:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
				:load(v,x 4 +) # expression type
				:load(x,x 3 +) # expr2
				y = 1
				:call(codegen_expression)
				x = v
				:call(memory_getTypeSize)
				x = y
				:raw("\tldr\tr1,=")
				:call(putint)
				:raw("\n\tmul\tr0,r0,r1\n\tldr\tr1,[sp],#4\n\tadd\tr0,r1,r0\n")
				:load(x,a 1 +) # check y on the stack if load is needed
				:if(x){
					:if(y 1 ==){ # byte
						:raw("\tldrb\tr0,[r0]\n")
					} elif(y 4 ==){ # word
						:raw("\tldr\tr0,[r0]\n")
					} else {
						:call(errorInternal)
					}
				}
			} elif(u 25 ==){ # component access
				v = x
				:load(x,x 3 +) # component
				:load(x,x 4 +) # calculated offset
				:raw("\tldr\tr1,=")
				:call(putint)
				:raw("\n\tadd\tr0,r0,r1\n")
				:load(y,a 1 +) # inspect y on the stack if load is needed
				:if(y){
					:load(x,v 4 +)
					:call(memory_getTypeSize)
					:if(y 1 ==){ # byte
						:raw("\n\tldrb\tr0,[r0]\n")
					} elif(y 4 ==){ # word
						:raw("\n\tldr\tr0,[r0]\n")
					} else {
						:call(errorInternal)
					}
				}
			} elif(u 28 ==){ # pointer &
				# no need to do anything, inner expression already called with y=1
			}
		} else {
			:call(codegen_expression_2)
		}
	} else {
		:call(codegen_call)
	}
	:call(pop)
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
# expressions 4-21,26,27,29,30
:fun(codegen_expression_2){
	# unop +, unop -, unop !, unop ~, unop *, cast
	:if(u 4 == u 5 == | u 6 == | u 27 == | u 29 == | u 30 == |){
		v = x
		:load(x,x 2 +) # expr1
		y = 1
		:call(codegen_expression)
		:if(u 30 ==){ # cast
			:load(x,v 4 +) # type
			:load(x,x 1 +) # type type
			:if(x 1 ==){ # char
				:raw("\tmov\tr1,#256\n\tsdiv\tr2,r0,r1\n\tmls\tr0,r2,r1,r0\n")
			}
		} elif(u 5 ==){ # -
			:raw("\tmov\tr1,#-1\n\tmul\tr0,r0,r1\n")
		} elif(u 6 ==){ # !
			:raw("\teor\tr0,r0,#1\n")
		} elif(u 27 ==){ # ~
			:raw("\tmvn\tr0,r0\n")
		} else { # * (dereference)
			:load(y,a 1 +) # inspect y on the stack if load is needed
			:if(y){ 
				:load(x,x 4 +) # type
				:load(x,x 2 +) # basetype
				:call(memory_getTypeSize)
				:if(y 1 ==){ # byte
					:raw("\tldrb\tr0,[r0]\n")
				} elif(y 4 ==){ # word
					:raw("\tldr\tr0,[r0]\n")
				} else {
					:call(errorInternal)
				}
			}
		}
	} elif(u 7 => u 21 =< & u 26 == |){ # binop * - binop ||, ^
		v = x
		:load(x,v 2 +)
		y = 1
		:call(codegen_expression)
		:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
		:load(x,v 3 +)
		y = 1
		:call(codegen_expression)
		:raw("\tldr\tr1,[sp],#4\n")
		:if(u 7 ==){ # binop *
			:raw("\tmul\tr0,r1,r0\n")
		} elif(u 8 ==){ # binop /
			:raw("\tsdiv\tr0,r1,r0\n")
		} elif(u 9 ==){ # binop %
			:raw("\tsdiv\tr2,r1,r0\n\tmls\tr0,r2,r0,r1\n")
		} elif(u 10 ==){ # binop +
			:load(x,v 4 +) # expression type
			:load(x,x 1 +) # type type
			:if(x 5 ==){ # pointer
				:load(x,v 2 +) # expr1
				:load(x,x 4 +) # expr1 type 
				:load(u,x 1 +) # expr1 type type
				:if(u 5 ==){ # expr1 is pointer
					x = x 2 + # basetype
					:load(x,x)
					:call(memory_getTypeSize)
					:raw("\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\n\tmul\tr0,r0,r2\n")
				} else { # expr2 is pointer
					:load(x,v 3 +) # expr2
					:load(x,x 4 +) # type
					:load(x,x 2 +) # basetype
					:call(memory_getTypeSize)
					:raw("\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\n\tmul\tr1,r1,r2\n")
				}
			}
			:raw("\tadd\tr0,r1,r0\n")
		} elif(u 11 ==){ # binop -
			:load(x,v 4 +) # expression type
			:load(x,x 1 +) # type type
			:if(x 5 ==){ # pointer
				:load(x,v 2 +) # expr1
				:load(x,x 4 +) # expr1 type
				:load(u,x 1 +) # expr1 type type
				:if(u 5 ==){ # expr1 is pointer
					:load(x,x 2 +) # basetype
					:call(memory_getTypeSize)
					:raw("\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\n\tmul\tr0,r0,r2\n")
				} else { # expr2 is pointer
					:load(x,v 3 +) # expr2
					:load(x,x 4 +) # expr2 type
					:load(x,x 2 +) # expr2 basetype
					:call(memory_getTypeSize)
					:raw("\tldr\tr2,=")
					x = y
					:call(putint)
					:raw("\n\tmul\tr1,r1,r2\n")
				}
			}
			:raw("\tsub\tr0,r1,r0\n")
			:load(u,v 4 +) # expression type
			:load(x,u 1 +) # expression type type
			y = x 0 == # int
			:load(x,v 2 +) # expr1
			:load(u,x 4 +) # expr1 type
			:load(x,u 1 +) # expr1 type type
			:if(y x 5 == &){ # result is int, but operands are pointer
				:load(x,u 2 +) # expr1 basetype
				:call(memory_getTypeSize)
				:raw("\tldr\tr1,=")
				x = y
				:call(putint)
				:raw("\n\tsdiv\tr0,r0,r1\n")
			}
		} else {
			:call(codegen_expression_2andahalf)
		}
	} else {
		:call(codegen_expression_3)
	}
}
:fun(codegen_expression_2andahalf){
	:if(u 12 ==){ # binop <
		:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovlt\tr0,#1\n")
	} elif(u 13 ==){ # binop >
		:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovgt\tr0,#1\n")
	} elif(u 14 ==){ # binop <=
		:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovle\tr0,#1\n")
	} elif(u 15 ==){ # binop >=
		:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovge\tr0,#1\n")
	} elif(u 16 ==){ # binop ==
		:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmoveq\tr0,#1\n")
	} elif(u 17 ==){ # binop !=
		:raw("\tcmp\tr1,r0\n\tmov\tr0,#0\n\tmovne\tr0,#1\n")
	} elif(u 18 == u 20 == |){ # binop &, binop &&
		:raw("\tand\tr0,r1,r0\n")
	} elif(u 19 == u 21 == |){ # binop |, binop ||
		:raw("\torr\tr0,r1,r0\n")
	} elif(u 26 ==){ # binop ^
		:raw("\teor\tr0,r1,r0\n")
	}
}
:fun(codegen_expression_3){
	:if(u 31 ==){ # pointer component
		v = x
		:load(x,v 2 +) # expr1
		y = 1
		:call(codegen_expression)
		:load(x,v 3 +) # component
		:load(x,x 4 +) # calculated offset
		:raw("\tldr\tr1,=")
		:call(putint)
		:load(x,a 1 +) # inspect y on the stack if load is needed
		:if(x){
			:load(x,v 4 +)
			:call(memory_getTypeSize)
			:if(y 1 ==){ # byte
				:raw("\n\tldrb\tr0,[r0,r1]\n")
			} elif(y 4 ==){ # word
				:raw("\n\tldr\tr0,[r0,r1]\n")
			} else {
				:call(errorInternal)
			}
		} else {
			:raw("\n\tadd\tr0,r0,r1\n")
		}
	} elif(u 23 ==){ # const
		:load(x,x 2 +) # expr1 (const token object location)
		:load(v,x 1 +) # const token id
		:if(v 3 ==){ # string
			:raw("\tldr\tr0,=S")
			:load(x,x 3 +) # string id
			:call(putint)
			:raw("\n")
		} else {
			:raw("\tldr\tr0,=")
			:load(x,x 2 +) # const value
			:call(putint)
			:raw("\n")
		}
	} elif(u 22 ==){ # ident
		:load(x,x 3 +) # corresponding declaration
		v = x
		:load(x,v 4 +) # offset
		:if(x 0 1 - =!){
			:raw("\tldr\tr0,=")
			:call(putint)
			:raw("\n\tsub\tr0,fp,r0\n")
		} else {
			:raw("\tldr\tr0,=V")
			:load(x,v 3 +) # ident
			:call(printIdent)
			:raw("\n")
		}
		:load(y,a 1 +) # inspect y on the stack if load is needed
		:if(y){
			:load(x,v 1 +) # type
			:call(memory_getTypeSize)
			:if(y 1 ==){ # byte
				:raw("\tldrb\tr0,[r0]\n")
			} elif(y 4 ==){ # word
				:raw("\tldr\tr0,[r0]\n")
			} else {
				:call(errorInternal)
			}
		}
	} elif(u 32 ==){ # sizeof
		:load(x,x 2 +) # expr
		:call(memory_getTypeSize)
		:raw("\tldr\tr0,=")
		x = y
		:call(putint)
		:raw("\n")
	} else {
		:call(errorInternal)
	}
}
:fun(codegen_call){
	s = c
	:call(push)
	s = z
	:call(push)
	:load(z,x 3 +) # call start addr
	:load(s,z 2 +) # function decl addr
	:load(s,s 2 +) # ident addr
	:call(push)
	z = z 5 +
	:load(x,z) # next object in memory
	:load(u,z 1 +) # possibly the end field of an object
	c = 0
	:while(x 10 =! u 1 =! | c 0 > |){ # x != call | u != end | c > 0
		:if(x 11 == c 0 == &){ # arg for current call
			:load(x,z 1 +) # arg expression
			:load(v,x 4 +) # expression type
			y = 1
			:call(codegen_expression)
			x = v
			:call(memory_getTypeSize)
			:if(y 1 ==){ # byte
				:raw("\tsub\tsp,sp,#1\n\tstrb\tr0,[sp]\n")
			} elif(y 4 ==){ # word
				:raw("\tsub\tsp,sp,#4\n\tstr\tr0,[sp]\n")
			} else {
				:call(errorInternal)
			}
		} elif(x 10 ==){ # call
			:load(x,z 1 +)
			:if(x 0 ==){ # start
				c = c 1 +
			} else {
				c = c 1 -
			}
		}
		z = z 5 +
		:load(x,z)
		:load(u,z 1 +)
	}
	:raw("\tbl\tF")
	:call(pop)
	x = s
	:call(printIdent)
	:raw("\n")
	:call(pop)
	z = s
	:call(pop)
	c = s
}
:fun(codegen_isMain){
	s = x
	:call(push)
	:load(u,x 2 +)
	:if(u 4 ==){ # len(main)
		:load(x,x 1 +)
		:load(t,x)
		:load(u,x 1 +)
		:load(v,x 2 +)
		:load(z,x 3 +)
		y = t 109 == u 97 == & v 105 == & z 110 == & # tuvz == 'main'
	}
	:call(pop)
	x = s
}
#
# Phase 4 - Memory
#
:fun(memory){
	:if(d){
		:raw("Phase 4 - Memory\n")
	}
	i = e
	c = 0 # string counter
	f = 0 # function flag
	o = 0 # declaration offset
	p = 0 # struct flag
	r = 0 # param offset
	:while(i g <){
		:load(x,i)
		:load(u,i 1 +)
		:if(x 2 == u 23 == &){ # expression & constant 
			:load(x,i 2 +)
			:load(u,x 1 +)
			:if(u 3 ==){ # string
				:store(c,x 3 +) # override line no. with string id
				:store(x,m)
				m = m 1 +
				:if(d){
					x = x 2 +
					:load(x,x)
					:load(u,x)
					:putchar(u)
					x = x 1 +
					:load(u,x)
					:while(u 34 =!){ # u != '"'
						:if(u 92 ==){ # u == '\'
							:putchar(u)
							x = x 1 +
							:load(u,x)
						}
						:putchar(u)
						x = x 1 +
						:load(u,x)
					}
					:putchar(u)
					:raw("(")
					x = c
					:call(putint)
					:raw(") ")
				}
				c = c 1 +
			}
		} elif(x 0 ==){ # declaration
			:if(f 0 ==){ # not in a function
				:store(i,m)
				m = m 1 +
			} else { # decl in function
				x = i
				:call(memory_getSize)
				o = o y +
				x = y
				:call(putint)
				:if(d){
					:load(x,i 3 +)
					:call(printIdent)
					:raw("(")
					x = o
					:call(putint)
					:raw(") ")
				}
				:store(o,i 4 +) # use free space to write offset
			}
		} elif(x 4 ==){ # parameter
			:if(p 0 ==){ # function param
				x = i
				:call(memory_getSize)
				r = r y +
				o = o y +
				:store(o,i 4 +) # same offset as declaration
				:if(d){
					:load(x,i 2 +)
					:call(printIdent)
					:raw("(")
					x = o
					:call(putint)
					:raw(") ")
				}
			} else { # struct param
				x = i
				:call(memory_getSize)
				:if(d){
					:load(x,i 2 +)
					:call(printIdent)
					:raw("(")
					x = o
					:call(putint)
					:raw(") ")
				}
				:store(o,i 4 +) # same offset
				o = o y +
			}
		} elif(x 3 ==){ # function
			:if(f){ # funcion end
				o = 8 o + # 8 bytes for 2 ints (RA,FP)
				:store(o,i 2 +)
				:store(r,i 4 +) # size of parameters
				:raw("]\n ")
			} else {
				:load(x,i 2 +)
				:raw("\n")
				:call(printIdent)
				:raw("[ ")
			}
			o = 0
			r = 0
			f = 1 f -
		} elif(x 12 ==){ # struct
			:if(p){ # struct end
				:call(pop)
				o = s
			} else { # struct start
				s = o
				:call(push)
				o = 0
			}
			p = 1 p -
		}
		i = i 5 +
	}
}
# input: x (syntax token)
# output: y (size in bytes)
:fun(memory_getSize){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	:load(u,x)
	:if(u 0 =! u 4 =! & u 12 =! &){ # u != decl & u != param & u != struct
		:throw("[Memory getSize] Invalid argument.\n")
		x = 1
		:exit(x)
	}
	:if(u 0 == u 4 == |){ # u == decl | u == param
		:load(x,x 1 +) # type addr
		:call(memory_getTypeSize)
	} else { 
		:load(u,x 3 +) # precalculated size (perhaps)
		:if(u 0 1 - ==){ # not available
			s = x 3 +
			:call(push)
			u = x 5 +
			:load(x,u)
			v = 0
			:while(x 12 =!){ # not struct
				:if(x 4 ==){ # parameter
					:load(x,u 1 +) # type addr
					:call(memory_getTypeSize)
					v = v y +	
				}
				u = u 5 +
				:load(x,u)
			}
			:call(pop)
			:store(v,s)
			y = v
		} else {
			y = u
		}
	}
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
:fun(memory_getTypeSize){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	:load(u,x)
	:if(u 1 =!){
		:throw("[Memory getTypeSize] invalid arguments.\n")
		x = 1
		:exit(x)
	}
	:load(u,x 1 +)
	:if(u 0 == u 5 == |){ # int | pointer
		y = 4
	} elif(u 1 == u 2 == | u 3 == |){ # char | bool | boid
		y = 1
	} elif(u 4 ==){ # array
		:load(u,x 3 +) # const token address
		:load(s,u 2 +) # value
		:call(push)
		:load(x,x 2 +) # basetype
		:call(memory_getTypeSize)
		:call(pop)
		y = y s *
	} elif(u 6 ==){ # name
		:load(x,x 2 +)
		:call(memory_getSize)
	}
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
#
# Phase 3 - Semantic analisys
#
:fun(semantics){
	:if(d){
		:raw("\nPhase 3 - Semantic analisys\n")
	}
	:call(semantics_nameResolver)
	m = g # the memory pointer can be reset to the initial position
	:call(semantics_typeResolver)
}
:fun(semantics_typeResolver){
	# h will be used for address resolving
	:call(semantics_typeResolver_validateStructsAndArrays)
	i = e
	:while(i g <){
		:load(x,i)
		:call(semantics_typeResolver_checkVoid)
		h = 0 # reset addrresolver flag
		:if(x 0 ==){ # declaration
			:load(x,i 2 +)
			:if(x 0 1 - =!){ # initialization
				:load(s,i 3 +) # ident
				:load(l,s 3 +) # line no
				:load(s,i 1 +) # type
				:load(x,s 1 +) # type type
				:if(x 4 ==){ # array
					:throw("Cannot initialize array ")
					:load(x,i 3 +) # ident
					:call(errorIdent)
					:throw(". ")
					:load(x,x 3 +) # line no.
					:call(errorPrintLine)
				}
				:if(x 6 ==){ # struct
					:throw("Cannot initialize struct ")
					:load(x,i 3 +) # ident
					:call(errorIdent)
					:throw(". ")
					:load(x,x 3 +) # line no.
					:call(errorPrintLine)
				}
				:call(push)
				:load(x,i 2 +) # expression
				:call(semantics_typeResolver_resolveExpression)
				:call(pop)
				x = s
				:load(y,m 1 -)
				:call(semantics_typeResolver_equals)
				:if(y 0 ==){
					:throw("Types must be equal. ")
					x = l
					:call(errorPrintLine)
				}
			}
		} elif(x 3 ==){ # function
			:load(x,i 3 +) # start/end/decl
			:if(x 0 ==){
				:load(f,i 1 +) # load f with type of current function
			}
		} elif(x 5 ==){ # return
			:load(x,i 1 +)
			:if(x 0 1 - ==){
				x = 3
				y = 0
				:call(semantics_typeResolver_createType)
				x = f
				y = m 5 -
				:call(semantics_typeResolver_equals)
			} else {
				:call(semantics_typeResolver_resolveExpression)
				:load(y,m 1 -)
				x = f
				:call(semantics_typeResolver_equals)
			}
			:if(y 0 ==){
				:throw("Expression in return must match with function type. ")
				x = l
				:call(errorPrintLine)
			}
		} elif(x 6 ==){ # expression statement
			:load(x,i 1 +)
			:call(semantics_typeResolver_resolveExpression)
		} elif(x 7 ==){ # assignment
			:call(semantics_typeResolver_assignments)
		} elif(x 8 ==){ # if/else/end
			:load(x,i 1 +)
			:if(x 0 ==){ # if
				:load(x,i 2 +)
				:call(semantics_typeResolver_resolveExpression)
				u = m 1 -
				x = 2
				y = 0
				:call(semantics_typeResolver_createType)
				x = m 5 -
				:load(y,u)
				:call(semantics_typeResolver_equals)
				:if(y 0 ==){
					:throw("Expression in if must be a boolean. ")
					x = l
					:call(errorPrintLine)
				}
			}
		} elif(x 9 ==){ # while
			:load(x,i 1 +)
			:if(x 0 ==){ # start
				:load(x,i 2 +)
				:call(semantics_typeResolver_resolveExpression)
				u = m 1 -
				x = 2
				y = 0
				:call(semantics_typeResolver_createType)
				x = m 5 -
				:load(y,u)
				:call(semantics_typeResolver_equals)
				:if(y 0 ==){
					:throw("Expression in while must be a boolean. ")
					x = l
					:call(errorPrintLine)
				}
			}
		}
		i = i 5 +
	}
}
# x type, y basetype
:fun(semantics_typeResolver_createType){
	:store(1,m) # memory cell type (1)
	:store(x,m 1 +) # type id
	:store(y,m 2 +) # basetype
	m = m 5 +
}
# 0-6,27
:fun(semantics_typeResolver_resolveExpression){
	s = u
	:call(push)
	s = v
	:call(push)
	s = x
	:call(push)
	s = y
	:call(push)
	:load(u,x)
	:if(u 2 =! u 10 =! &){ # expression & call
		:throw("[ResolveExpression] Invalid input. ")
		x = l
		:call(errorPrintLine)
	}
	:if(u 10 ==){ # call
		:call(semantics_typeResolver_resolveCall)
	} else {
		:load(u,x 1 +)
		:if(u 0 => u 3 =< &){ # postincrement, postdecrement, preincrement, predecrement
			:load(x,x 2 +)
			:call(semantics_typeResolver_resolveExpression)
			:if(h 0 ==){
				:throw("[increment/decrement] Expression must be an Lvalue. ")
				x = l
				:call(errorPrintLine)
			}
			h = 0
			:load(x,m 1 -) # load address of type
			:load(x,x 1 +) # load type type
			# x != int & x != char & x != ptr
			:if(x 0 =! x 1 =! & x 5 =! &){
				:throw("[increment/decrement] Expression must be of type int, char or pointer. ")
				x = l
				:call(errorPrintLine)
			}
			# operator doesnt change the type
		} elif(u 4 == u 5 == | u 27 == |){ # prefix + | prefix - | prefix ~ (bitwise negation)
			:load(x,x 2 +)
			:call(semantics_typeResolver_resolveExpression)
			h = 0
			:load(x,m 1 -) # load address of type
			:load(x,x 1 +) # load type type
			:if(x 0 =!){ # int
				:throw("[Prefix +,-,~] Expression must be of type int. ")
				x = l
				:call(errorPrintLine)
			}
			# operator doesnt change the type
		} elif(u 6 ==){ # boolean negate
			:load(x,x 2 +)
			:call(semantics_typeResolver_resolveExpression)
			h = 0
			:load(x,m 1 -) # load address of type
			:load(x,x 1 +) # load type type
			:if(x 2 =!){ # bool
				:throw("[Prefix !] Expression must be of type bool. ")
				x = l
				:call(errorPrintLine)
			}
			# operator doesnt change the type
		} else {
			:call(semantics_typeResolver_resolveExpression_extra_outer)
		}
	}
	:call(pop)
	y = s
	:call(pop)
	x = s
	:load(u,m 1 -)
	:store(u,x 4 +)
	:call(pop)
	v = s
	:call(pop)
	u = s
}
:fun(semantics_typeResolver_resolveCall){
	# x,y,v,u are already saved
	s = k
	:call(push)
	s = p
	:call(push)
	s = c
	:call(push)
	:load(x,x 3 +) # x has call address (end)
	:load(k,x 2 +) # function pointer
	:load(u,k)
	:if(u 3 =!){ # is function
		:load(x,k 3 +) # declaration ident TODO doesnt work for parameters
		:call(errorIdent)
		:throw(" is not a function. ")
		x = l
		:call(errorPrintLine)
	}
	u = x # call iterator
	v = k # function iterator
	c = 1
	y = 1
	:while(y){
		y = 1
		:while(y){
			u = u 5 +
			:load(x,u)
			:if(x 10 ==){ # call
				:load(p,u 1 +)
				:if(p 1 ==){ # end
					c = c 1 -
				} else { #start
					c = c 1 +
				}
			}
			y = c 1 == x 11 =! & c 1 > | # argument
		}
		y = 1
		:while(y){ # skip all non parameter/function end block
			v = v 5 +
			:load(s,v)
			y = s 3 =! s 4 =! & # s != function & s != parameter
		}
		:if(x 10 ==){ # call end
			:if(s 3 =!){ # parameter
				:throw("Parameter count must match in function calls. ")
				x = l
				:call(errorPrintLine)
			} else { # function end
				y = 0 # no more parameters/arguments
			}
		} elif(s 4 ==){ # parameter
			:load(x,u 1 +)
			:call(semantics_typeResolver_resolveExpression)
			h = 0
			:load(x,m 1 -) # argument type
			:load(y,v 1 +) # parameter type
			:call(semantics_typeResolver_equals)
			:if(y 0 ==){
				:throw("Parameter type must match in function calls. ")
				x = l
				:call(errorPrintLine)
			}
			y = 1
		} else { # function end
			:throw("Parameter count must match in function calls. ")
			x = l
			:call(errorPrintLine)
		}
	}
	:load(k,k 1 +)
	:store(k,m)
	m = m 1 +
	:call(pop)
	c = s
	:call(pop)
	p = s
	:call(pop)
	k = s
	# x,y,v,u will get restored
}
# 7-15,18,19,26
:fun(semantics_typeResolver_resolveExpression_extra_outer){
	:if(u 7 => u 9 =< & u 18 == | u 19 == | u 26 == |){ # *,/,%,&,|,^
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		s = m 1 -
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		:load(x,m 1 -) # load address of type2
		:load(x,x 1 +) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		:load(y,y 1 +) # load type1 type
		:if(x y =! y 0 =! |){ # same type or int
			:throw("[ Binop *,/,%,&,|,^ ] Operator must have 2 expressions of type int. ")
			x = l
			:call(errorPrintLine)
		}
		# operator doesnt change the type
	} elif(u 10 == u 11 == |){ # binop +,-
		# save whether its subtraction on the stack so we know later
		s = u 11 ==
		:call(push)
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		s = m 1 -
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		:load(x,m 1 -) # load address of type2
		:load(x,x 1 +) # load type2 type
		:call(pop)
		:load(s,s) # load address of type
		:load(y,s 1 +) # load type1 type
		:if(x 0 ==){ # int
			:if(y 0 =! y 1 =! & y 5 =! &){ # y != int & y != char & y != ptr
				:throw("[ Binop +,- ] One expression must be int, the other can be int, char or pointer. ")
				x = l
				:call(errorPrintLine)
			}
			# copy type of first expression, which carries over
			:store(s,m)
			m = m 1 +
		} elif(y 0 ==){ # int
			:if(x 0 =! x 1 =! & x 5 =! &){ # x != int & x != char & x != ptr
				:throw("[ Binop +,- ] One expression must be int, the other can be int, char or pointer. ")
				x = l
				:call(errorPrintLine)
			}
			# type ok, 2nd expression carries over
		} else {
			:load(v,a 1 +) # look on the stack if it is subtraction
			y = 0
			:if(x 5 == x 1 == | v &){ # x == char | x == ptr
				:load(x,m 1 -)
				y = s
				:call(semantics_typeResolver_equals)
			}
			:if(y){
				x = 0
				y = 0
				:call(semantics_typeResolver_createType)
				x = m 5 -
				:store(x,m)
				m = m 1 +
			} else {
				:throw("[ Binop +,- ] One expression must be int, the other can be int, char or pointer. ")
				x = l
				:call(errorPrintLine)
			}
		}
		:call(pop)
	} elif(u 12 => u 15 =< &){ # binop <,>,<=,>=
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		s = m 1 -
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		:load(x,m 1 -) # load address of type2
		:load(x,x 1 +) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		:load(y,y 1 +) # load type1 type
		:if(x y =!){ # same type
			:throw("[ <,>,<=,>= ] Operator must have 2 expressions of same type (int, char, pointer). ")
			x = l
			:call(errorPrintLine)
		} elif(y 0 =! y 1 =! & y 5 =! &){ # not int, char or ptr
			:throw("[ <,>,<=,>= ] Operator must have 2 expressions of same type (int, char, pointer). ")
			x = l
			:call(errorPrintLine)
		}
		x = 2
		y = 0
		:call(semantics_typeResolver_createType)
		x = m 5 -
		:store(x,m)
		m = m 1 +
	} else {
		:call(semantics_typeResolver_resolveExpression_outofideas)
	}
}
# 16,17,20,21,22
:fun(semantics_typeResolver_resolveExpression_outofideas){
	:if(u 16 == u 17 == |){ # == or !=
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		s = m 1 -
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		:load(x,m 1 -) # load address of type2
		:load(x,x 1 +) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		:load(y,y 1 +) # load type1 type
		# same type or one of array, void, struct 
		:if(x y =! y 4 == | y 3 == | y 6 == |){
			:throw("[ ==,!= ] Operator must have 2 expressions of same type (int, bool, char, pointer). ")
			x = l
			:call(errorPrintLine)
		}
		x = 2
		y = 0
		:call(semantics_typeResolver_createType)
		x = m 5 -
		:store(x,m)
		m = m 1 +
	} elif(u 20 == u 21 == |){ # && or ||
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		s = m 1 -
		:call(push)
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		h = 0
		:load(x,m 1 -) # load address of type2
		:load(x,x 1 +) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		:load(y,y 1 +) # load type1 type
		:if(x y =! y 2 =! |){ # not same type or not bool
			:throw("[ &&,|| ] Operator must have 2 expressions of type bool. ")
			x = l
			:call(errorPrintLine)
		}
		# type doesnt change
	} elif(u 22 ==){ # ident
		:load(u,x 2 +) # ident token
		:load(u,u 3 +) # line no.
		l = u # keep l updated for error messages
		:load(u,x 3 +) # declaration location
		:load(y,u)
		:if(y 3 ==){ # function
			:load(x,x 2 +)
			:call(errorIdent)
			:throw(" is a function, not a variable. ")
			x = l
			:call(errorPrintLine)
		}
		h = 1
		:load(u,u 1 +) # type
		:store(u,m)
		m = m 1 +
	} else {
		:call(semantics_typeResolver_resolveExpression_extra)
	}
}
# 23,24,25
:fun(semantics_typeResolver_resolveExpression_extra){
	:if(u 23 ==){ # const
		:load(u,x 2 +) # const token
		:load(l,u 3 +) # keep current line updated
		:load(v,u 1 +)
		:if(v 0 == v 1 == | v 2 == |){ # int, char, bool
			x = v
			y = 0
			:call(semantics_typeResolver_createType)
			:store(m 5 -,m)
			m = m 1 +
		} elif(v 3 ==){ # char*
			x = 1
			y = 0
			:call(semantics_typeResolver_createType)
			x = 5
			y = m 5 -
			:call(semantics_typeResolver_createType)
			:store(m 5 -,m)
			m = m 1 +
		} elif(v 4 ==){ # void*
			x = 3
			y = 0
			:call(semantics_typeResolver_createType)
			x = 5
			y = m 5 -
			:call(semantics_typeResolver_createType)
			:store(m 5 -,m)
			m = m 1 +
		}
	} elif(u 24 ==){ # array
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		s = m 1 -
		:call(push)
		:if(h 0 ==){
			:throw("[ Indexing ] Base expression must be Lvalue. ")
			x = l
			:call(errorPrintLine)
		}
		:load(x,v)
		:call(semantics_typeResolver_resolveExpression)
		:load(x,m 1 -) # load address of type2
		:load(x,x 1 +) # load type2 type
		:call(pop)
		:load(y,s) # load address of type
		:load(y,y 1 +) # load type1 type
		:if(y 4 =! y 5 =! & x 0 =! &){ # not array & not pointer & not int
			:throw("[ Indexing ] Base expression must be of type array or pointer, index must be type int. ")
			x = l
			:call(errorPrintLine)
		}
		h = 1
		:load(y,s)
		:load(y,y 2 +) # basetype
		:store(y,m)
		m = m 1 +
	} elif(u 25 ==){ # component
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		:load(x,m 1 -) # load address of type2
		:if(h 0 ==){
			:throw("[ Component ] Base expression must be Lvalue. ")
			x = l
			:call(errorPrintLine)
		}
		x = x 1 +
		:load(y,x) # load type2 type
		:if(y 6 ==){ # struct
			:load(x,x 1 +) # struct declaration
			:load(u,v) # load address of ident
			w = 1
			j = x 5 +
			:load(x,j)	
			:while(x 12 =!){ # struct
				:if(x 4 ==){ # parameter
					:load(x,j 2 +)
					y = u
					:call(identEquals)
					:if(y){
						w = 0
						:load(x,j 1 +)
						:store(x,m)
						:store(j,v)
						m = m 1 +
					}
				}
				j = j 5 +
				:load(x,j)
			}
			:if(w){
				:throw("Struct does not contain component ")
				x = u
				:call(errorIdent)
				:throw(". ")
				x = l
				:call(errorPrintLine)
			}
			h = 1
		} else {
			:throw("Base expression must be type struct. ")
			x = l
			:call(errorPrintLine)
		}
	} else {
		:call(semantics_typeResolver_resolveExpression_extra_inner)
	}
}
# 28,29,30,31
:fun(semantics_typeResolver_resolveExpression_extra_inner){
	:if(u 28 ==){ # prefix & (pointer)
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		:if(h 0 ==){
			:throw("Cannot take address (expression must be Lvalue). ")
			x = l
			:call(errorPrintLine)
		}
		h = 0
		:load(y,m 1 -) # load as basetype
		x = 5 # pointer
		:call(semantics_typeResolver_createType)
		:store(m 5 -,m)
		m = m 1 +
	} elif(u 29 ==){ # prefix * (dereference)
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		:load(x,m 1 -)
		:load(y,x 1 +)
		:if(y 5 ==){ # pointer
			:load(y,x 2 +) # basetype
			:store(y,m)
			m = m 1 +
			h = 1
		} else {
			:throw("Expression must be a pointer. ")
			x = l
			:call(errorPrintLine)
		}
	} elif(u 30 ==){ # cast
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		:load(u,m 1 -) # load address of type
		:load(u,u 1 +) # load expression type
		:load(x,v) # load address of cast type
		:load(y,x 1 +) # load type1 type
		# y = bool,void,array,struct or u = bool,void,array,struct
		:if(y 2 == y 3 == | y 4 == | y 6 == | u 2 == | u 3 == | u 4 == | u 6 == |){
			:throw("Cast expression can contain types int, char and pointer. ")
			x = l
			:call(errorPrintLine)
		}
		h = 0
		:store(x,m)
		m = m 1 +
	} elif(u 31 ==){ # pointer component
		v = x 3 +
		:load(x,x 2 +)
		:call(semantics_typeResolver_resolveExpression)
		:load(x,m 1 -) # load address of type2
		:load(y,x 1 +) # load type2 type
		:load(x,x 2 +) # basetype
		:load(s,x 1 +) # type type
		:if(y 5 == s 6 == &){ # struct pointer
			:load(x,x 2 +) # struct declaration
			:load(u,v) # load address of ident
			w = 1
			j = x 5 +
			:load(x,j)
			:while(x 12 =!){ # struct
				:if(x 4 ==){ # parameter
					:load(x,j 2 +)
					y = u
					:call(identEquals)
					:if(y){
						w = 0
						:load(x,j 1 +)
						:store(x,m)
						:store(j,v)
						m = m 1 +
					}
				}
				j = j 5 +
				:load(x,j)
			}
			:if(w){
				:throw("Struct does not contain component ")
				x = u
				:call(errorIdent)
				:throw(". ")
				x = l
				:call(errorPrintLine)
			}
			h = 1
		} else {
			:throw("Base expression must be type struct pointer. ")
			x = l
			:call(errorPrintLine)
		}		
	} elif(u 32 ==){ # sizeof
		x = 0 # int
		y = 0
		:call(semantics_typeResolver_createType)
		:store(m 5 -,m)
		m = m 1 +
	}
}
:fun(semantics_typeResolver_assignments){
	:load(x,i 2 +) # expr1
	:call(semantics_typeResolver_resolveExpression)
	:load(s,m 1 -)
	:call(push)
	:if(h 0 ==){
		:throw("Left side of assignment must be an Lvalue. ")
		x = l
		:call(errorPrintLine)
	}
	h = 0 # reset addrresolver flag
	:load(x,i 3 +) # expr2
	:call(semantics_typeResolver_resolveExpression)
	:load(x,i 1 +) # type of assignment
	:if(x 0 ==){ # =
		:call(pop)
		x = s
		:load(y,m 1 -)
		:call(semantics_typeResolver_equals)
		:if(y 0 ==){
			:throw("[ = ] Expressions in assignment need to have equal types. ")
			x = l
			:call(errorPrintLine)
		}
	} else if(x 1 == x 2 == |){ # +=,-=
		:call(pop)
		:load(x,s 1 +)
		:if(x 0 ==){ # int
			:load(y,m 1 -)
			:load(x,y 1 +)
			:if(x 0 =! x 1 =! &){ # x not int or char
				:throw("[ +=,-= ] Right side must be int or char. ")
				x = l
				:call(errorPrintLine)
			}
		} elif(x 5 ==){ # pointer
			:load(y,m 1 -)
			:load(y,y 1 +)
			:if(y 0 =!){
				:throw("[ +=,-= ] Right side must be int. ")
				x = l
				:call(errorPrintLine)
			}
		} elif(x 1 =!){ # char
			:throw("[ +=,-= ] Left side must be int, char or ptr. ")
			x = l
			:call(errorPrintLine)
		}
	} else { # *=,/=
		:load(y,m 1 -)
		:load(y,y 1 +)
		:call(pop)
		:load(x,s 1 +)
		:if(y 0 =! x 0 =! |){
			:throw("[ /=,*= ] Both expressions have to be integers. ")
			x = l
			:call(errorPrintLine)
		}
	}
}
# input: x,y
:fun(semantics_typeResolver_equals){
	s = u
	:call(push)
	s = v
	:call(push)
	s = x
	:call(push)
	:load(u,x)
	:load(v,y)
	:if(u 1 =! v 1 =! |){
		:throw("[TypeEquals] Invalid input")
		x = l
		:call(errorPrintLine)
	}
	:load(u,x 1 +)
	:load(v,y 1 +)
	:if(u v ==){ # are equal
		:if(v 4 ==){ # array
			:load(u,x 3 +) # load length token
			:load(u,u 2 +) # value
			:load(v,y 3 +) # load length token
			:load(v,v 2 +) # value
			:if(u v =!){
				y = 0
			} else {
				:load(x,x 2 +) # basetype
				:load(y,y 2 +) # basetype
				:call(semantics_typeResolver_equals)
			}
		} elif(v 5 ==){ # ptr
			:load(x,x 2 +) # basetype
			:load(y,y 2 +) # basetype
			:call(semantics_typeResolver_equals)
		} elif(v 6 ==){ # name type
			:load(x,x 2 +) # basetype
			:load(y,y 2 +) # basetype
			y = x y ==
		} else {
			y = 1
		}
	} else {
		y = 0
	}
	:call(pop)
	x = s
	:call(pop)
	v = s
	:call(pop)
	u = s
}
:fun(semantics_typeResolver_checkVoid){
	v = 0 # TODO: move parameter ident into offset 3
	:if(x 0 ==){ # declaration
		v = 3 # offset
	}
	:if(x 4 ==){ # parameter
		v = 2 # offset
	}
	:if(v){
		:load(u,i 1 +) # load type address
		:load(u,u 1 +) # load type
		:if(u 3 ==){ # void
			:throw("Variable or field ")
			:load(x,i v +) # ident
			:call(errorIdent)
			:throw(" cannot be void. ")
			:load(x,x 3 +) # line no.
			:call(errorPrintLine)
		}
	}
}
:fun(semantics_typeResolver_recursiveType){
	:load(u,x)
	:if(u 1 =!){ # type
		x = 0 20 -
		:call(errorPrintLine)
	}
	:load(u,x 1 +)
	:while(u 4 ==){ # resolve type as long as its an array
		:load(x,x 2 +)
		:load(u,x 1 +)
	}
	:if(u 6 ==){ # nametype
		:load(u,x 2 +) # basetype should be address of struct declaration
		j = g
		:while(j m <){
			:load(x,j)
			:if(x u ==){
				:throw("Struct ")
				:load(x,x 2 +) # ident
				:call(errorIdent)
				:throw(" cannot be recursive (use pointers!). ")
				:load(x,x 3 +) # line no.
				:call(errorPrintLine)
			}
			j = j 1 +
		}
		:store(u,m)
		m = m 1 +
		y = 1
		:while(y){
			u = u 5 +
			:load(x,u)
			:if(x 4 ==){ # parameter
				:load(x,u 1 +) # parameter type
				s = u
				:call(push)
				:call(semantics_typeResolver_recursiveType)
				:call(pop)
				u = s
				y = 1
			} else {
				y = x 12 =! # end of struct
			}
		}
	}
}
:fun(semantics_typeResolver_validateStructsAndArrays){
	i = e
	:while(i g <){
		:load(x,i)
		:load(u,i 1 +)
		:if(x 12 == u 0 == &){ # x == struct & u == start
			:store(i,m)
			m = m 1 +
			f = 1 # parameter flag
			z = i
			y = 1
			:while(y){
				z = z 5 +
				:load(x,z)
				:if(x 4 ==){ # parameter (struct component)
					f = 0
					:load(x,z 1 +) # parameter type
					:call(semantics_typeResolver_recursiveType)
					y = 1
				} else {
					y = x 12 =! # end of struct
				}
			}
			:if(f){
				:throw("Struct ")
				:load(x,m 1 -)
				:load(x,x 2 +) # ident
				x = x 3 + # line no.
				:call(errorIdent)
				:throw(" cannot be empty. ")
				:load(x,x)
				:call(errorPrintLine)
			}
			m = m 1 -
		} elif(x 3 ==){ # function
			:load(x,i 1 +) # type
			:load(x,x 1 +) # type type
			:if(x 4 == x 6 == |){ # array or struct
				:throw("Function return type cannot be array or struct. ")
				:load(x,i 2 +) # ident
				:load(x,x 3 +) # line no
				:call(errorPrintLine)
			} 
		} else {
			:load(u,i 1 +)
			:if(x 1 == u 4 == &){ # x == type & u == array
				:load(x,i 3 +) # const
				:load(u,x 1 +) # const id
				:if(u 0 =!){ # int
					:throw("Array length must be an int. ")
					:load(x,x 3 +)
					:call(errorPrintLine)
				}
				:load(u,x 2 +) # value
				:if(u 0 ==){
					:throw("Array length cannot be 0. ")
					:load(x,x 3 +)
					:call(errorPrintLine)
				}
				:load(u,i 2 +) # basetype
				:load(u,u 1 +) # basetype type
				:if(u 3 ==){ # void
					:throw("Array basetype cannot be void. ")
					:load(x,x 3 +)
					:call(errorPrintLine)
				}
			}
		}
		i = i 5 +
	}
}
:fun(semantics_nameResolver){
	i = e
	t = 0
	# First pass - global declarations
	:while(i g <){
		:load(x,i)
		:if(x 3 ==){ # function
			:load(x,i 2 +) # ident
			p = x
			:call(semantics_nameResolver_getDeclaration)
			:if(y 0 1 - =!){
				:throw("Name ")
				x = p
				:call(errorIdent)
				:throw(" already declared. ")
				:load(x,p 3 +) # ident token line no.
				:call(errorPrintLine)
			}
			:store(i,m)
			m = m 1 +
			:store(t,m)
			m = m 1 +
			y = 1
			:while(y){
				i = i 5 +
				:load(x,i)
				y = x 3 =! # skip function bodies on first pass
			}
		} else {
			:load(u,i 1 +) # expression id
			# x == expr & u != const | u == call
			:if(x 2 == u 23 =! & x 10 == |){
				:throw("Only constants allowed in global context. ")
				# TODO: doesn't work for expressions
				:load(u,i 2 +)
				:load(x,u 3 +)
				:call(errorPrintLine)
			}
			:call(semantics_nameResolver_handleDeclaration)
		}
		i = i 5 +
	}
	i = e
	t = 0
	:while(i g <){
		:load(x,i)
		:if(x 3 ==){ # function
			c = i # flag: function reachable return ; in theory this could cause trouble if i = 0, but i think thats impossible
			:load(x,i 3 +)
			:if(x 2 ==){# is declaration?
				c = 0
			}
			t = t 1 +
			s = m
			:call(push)
			i = i 5 +
			:load(x,i)
			:while(x 3 =!){ # function end
				:if(x 0 == x 12 == | x 4 == |){ # declaration, type declaration, parameter
					:call(semantics_nameResolver_handleDeclaration)
				} elif(x 8 == x 9 == |){ # if,while
					:call(semantics_nameResolver_recursive)
				} else {
					:if(x 5 ==){ # return
						c = 0 # reachable return; unset flag
					}
					:call(semantics_nameResolver_resolveNames)
				}
				i = i 5 +
				:load(x,i)
			}
			:if(c){
				:load(x,i 3 +) # function end/decl ?
				:load(y,c 1 +) # function type
				:load(y,y 1 +) # type type
				:if(x 1 == y 3 =! &){ # x == function end (ignore decl) and y != void
					:load(x,c 2 +) # function ident
					:call(errorIdent)
					:throw(" doesn't have a reachable return statement.\n")
					:exit(1)
				}
			}
			:call(pop)
			m = s
			t = t 1 -
		} else {
			:load(u,i 1 +)
			:if(x 1 == u 6 == &){ # x == type & u == name (type)
				:load(x,i 2 +) # ident
				p = x
				:call(semantics_nameResolver_getTypeDeclaration)
				:if(r 0 1 - ==){
					:throw("Undeclared type ")
					x = p
					:call(errorIdent)
					:throw(". ")
					:load(x,p 3 +)
					:call(errorPrintLine)
				}
				:store(r,i 2 +)
			}
		}
		i = i 5 +
	}
}
:fun(semantics_nameResolver_resolveNames){
	:load(u,i 1 +)
	:if(x 2 == u 22 == &){ # ident expression
		:load(x,i 2 +) # ident
		p = x
		:call(semantics_nameResolver_getDeclaration)
		:if(r 0 1 - ==){
			:throw("Undeclared name ")
			x = p
			:call(errorIdent)
			:throw(". ")
			:load(x,p 3 +)
			:call(errorPrintLine)
		}
		:store(r,i 3 +) # declaration is in place of expr2
	} else {
		:load(u,i 1 +) # type id
		:if(x 1 == u 6 == &){ # named type
			:load(x,i 2 +) # ident
			p = x
			:call(semantics_nameResolver_getTypeDeclaration)
			:if(r 0 1 - ==){
				:throw("Undeclared type ")
				x = p
				:call(errorIdent)
				:throw(". ")
				:load(x,p 3 +)
				:call(errorPrintLine)
			}
			:store(r,i 2 +)
		} else {
			:load(u,i 1 +) # start/end
			:if(x 10 == u 0 == &){ # call & start of call
				:load(x,i 2 +) # ident
				p = x
				:call(semantics_nameResolver_getDeclaration)
				:if(r 0 1 - ==){
					:throw("Undeclared name1 ")
					x = p
					:call(errorIdent)
					:throw(". ")
					:load(x,p 3 +)
					:call(errorPrintLine)
				}
				:store(r,i 2 +)
			}
		}
	}
}
:fun(semantics_nameResolver_recursive){
	t = t 1 +
	s = m
	:call(push)
	:if(x 8 ==){ # if/else
		:load(y,i 1 +)
		i = i 5 +
		:load(x,i)
		:if(y 0 ==){ # if
			:load(u,i 1 +)
			y = x 8 =! u 1 =! | # else
			:while(y){
				:if(x 0 == x 12 == |){ # declaration,type declaration
					:call(semantics_nameResolver_handleDeclaration)
				} elif(x 8 == x 9 == |){ # if, while
					:call(semantics_nameResolver_recursive)
				} else {
					:call(semantics_nameResolver_resolveNames)
				}
				i = i 5 +
				:load(x,i)
				:load(u,i 1 +)
				y = x 8 =! u 0 == | # not if/else or another start of if
			}
			:load(m,a 1 +)
			:if(u 1 ==){ # else
				i = i 5 +
				:load(x,i)
				:load(u,i 1 +)
				:while(x 8 =! u 2 =! |){ # not if else or not end
					:if(x 0 == x 12 == |){ # declaration, type declaration
						:call(semantics_nameResolver_handleDeclaration)
					} elif(x 8 == x 9 == |){ # if, while
						:call(semantics_nameResolver_recursive)
					} else {
						:call(semantics_nameResolver_resolveNames)
					}
					i = i 5 +
					:load(x,i)
					:load(u,i 1 +)
				}
			}
		}
	} else { # while
		i = i 5 +
		:load(x,i)
		:load(u,i 1 +)
		:while(x 9 =! u 1 =! |){ # not while or not end
			:if(x 0 == x 12 == |){ # declaration, type declaration
				:call(semantics_nameResolver_handleDeclaration)
			} elif(x 8 == x 9 == |){ # if,while
				:call(semantics_nameResolver_recursive)
			} else {
				:call(semantics_nameResolver_resolveNames)
			}
			i = i 5 +
			:load(x,i)
			:load(u,i 1 +)
		}
	}
	:call(pop)
	m = s
	t = t 1 -
}
:fun(semantics_nameResolver_handleDeclaration){
	:if(x 0 ==){ # declaration
		:load(x,i 3 +) # ident
		p = x
		:call(semantics_nameResolver_getDeclaration)
		:if(y 0 1 - =! q t == &){ # found declaration on same level
			:throw("Name ")
			x = p
			:call(errorIdent)
			:throw(" already declared. ")
			:load(x,p 3 +)
			:call(errorPrintLine)
		}
		:store(i,m) # declaration
		m = m 1 +
		:store(t,m) # level
		m = m 1 +
	} elif(x 12 ==){ # struct
		:load(x,i 2 +)
		p = x
		:call(semantics_nameResolver_getTypeDeclaration)
		:if(y 0 1 - =! q t == &){ # found declaration on same level
			:throw("Type ")
			x = p
			:call(errorIdent)
			:throw(" already declared. ")
			:load(x,p 3 +)
			:call(errorPrintLine)
		}
		:store(i,m)
		m = m 1 +
		:store(t,m)
		m = m 1 +
		i = i 5 +
		:load(x,i)
		t = t 1 +
		s = m
		:call(push)
		:while(x 12 =!){ # loop through struct components
			:call(semantics_nameResolver_resolveNames)
			:call(semantics_nameResolver_handleDeclaration)
			i = i 5 +
			:load(x,i)
		}
		t = t 1 -
		:call(pop)
		m = s
	} elif(x 4 ==){# parameter
		:load(x,i 2 +)
		p = x
		:call(semantics_nameResolver_getDeclaration)
		:if(y 0 1 - =! q t == &){ # found declaration on same level
			:throw("Parameter ")
			x = p
			:call(errorIdent)
			:throw(" already declared. ")
			:load(x,p 3 +)
			:call(errorPrintLine)
		}
		:store(i,m)
		m = m 1 +
		:store(t,m)
		m = m 1 +
	}
}
:fun(semantics_nameResolver_getDeclaration){
	j = m 2 -
	r = 0 1 -
	q = 0 1 -
	z = x # save search ident
	:while(j g => r 0 1 - == &){
		:load(u,j) # load declaration address
		:load(v,u) # load declaration type
		:if(v 0 ==){ # variable
			:load(y,u 3 +)
			x = z
			:call(identEquals)
			:if(y){
				r = u
				:load(q,j 1 +)
			}
		} elif(v 3 == v 4 == |){ # function, parameter
			:load(y,u 2 +)
			x = z
			:call(identEquals)
			:if(y){
				r = u
				:load(q,j 1 +)
			}
		}
		j = j 2 -
	}
	y = r
}
:fun(semantics_nameResolver_getTypeDeclaration){
	j = m 2 -
	r = 0 1 -
	q = 0 1 -
	z = x # save search ident
	:while(j g => r 0 1 - == &){
		:load(u,j) # load declaration address
		:load(v,u) # load declaration type
		:if(v 12 ==){ # struct
			:load(y,u 2 +)
			x = z
			:call(identEquals)
			:if(y){
				r = u
				:load(q,j 1 +)
			}
		}
		j = j 2 -
	}
	y = r
}
#
# Phase 2 - Syntax analisys
#
:fun(syntax){
	:if(d){
		:raw("\nPhase 2 - Syntax analisys\n")
	}
	i = b
	g = e 4 - # dont count safety token
	:while(i g <){
		f = 1
		w = i # save old place of token parsing
		o = m # save old memory pointer
		:call(syntax_isDeclaration)
		:if(f){
			# restore if matching changed anything
			i = w
			m = o
			:call(syntax_isTypeDeclaration)
			:if(f){
				i = w
				m = o
				:call(syntax_isFunction)
				:if(f){
					:call(errorUnmatchedToken)
				}
			}
		}
	}
}
:fun(syntax_isParameter){
	:call(syntax_isType)
	:load(x,i)
	:if(f 0 == x 2 == &){ # match found & x == ID
		:store(4,m) # parameter
		:store(m 5 -,m 1 +) # type was written in last cell
		:store(i,m 2 +) # identifier is current token
		:store(0 1 -,m 4 +)
		m = m 5 + # move token index
		i = i 4 +
		:if(d){
			:raw("PAR ")
		}
	} else {
		f = 1
	}
}
:fun(syntax_isFunction){
	:call(syntax_isType)
	:load(x,i)
	:if(f 0 == x 2 == &){ # <type> <ident>
		:store(3,m) # function
		:store(m 5 -,m 1 +) # type was written in last cell
		:store(i,m 2 +) # identifier is current token
		:store(0,m 3 +) # start of function block
		s = m 3 + # save start of function memory location
		:call(push)
		m = m 5 +
		i = i 4 +
		:load(x,i)
		:if(x 14 ==){ # (
			i = i 4 +
			:load(x,i)
			y = x 15 =! # x != ')'
			:if(y){ # undo first increment of while loop
				i = i 4 -
			}
			:while(y){
				i = i 4 +
				f = 1
				:call(syntax_isParameter)
				:if(f){
					:call(errorUnmatchedToken)
				}
				:load(x,i)
				y = x 21 == # ,
			}
			:if(x 15 =!){ # expect ')'
				x = 41  # )
				:call(errorExpectedX)
			}
			i = i 4 +
			:load(x,i)
			:if(x 22 ==){ # x == ';' ; function declaration
				:load(y,a 1 +)
				:store(2,y) # overwrite memory as function declaration start
				:if(d){
					:raw("FUNDECL ")
				} 
			} else {
				:if(x 16 =!){ # x != '{'
					x = 123 # {
					:call(errorExpectedX)
				}
				i = i 4 +
				:load(x,i)
				:while(x 17 =!){ # x != '}'
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
				}
				:if(d){
					:raw("FUN ")
				} 
			}
			i = i 4 +
			:load(y,a 1 +)
			:store(m,y 1 +)
			:store(3,m) # function
			:store(1,m 3 +) # function end block
			m = m 5 +
			f = 0 # set match flag
		} else {
			f = 1
		}
		:call(pop)
	} else {
		f = 1
	}
}
:fun(syntax_isStatement){
	s = w
	:call(push)
	s = o
	:call(push)
	w = i
	o = m
	:call(syntax_isDeclaration)
	:if(f){
		i = w
		m = o
		:call(syntax_isReturn)
		:if(f){
			i = w
			m = o
			:call(syntax_isAssign)
			:if(f){
				i = w
				m = o
				:call(syntax_isIf)
				:if(f){
					i = w
					m = o
					:call(syntax_isWhile)
					:if(f){
						i = w
						m = o
						:call(syntax_isExprStmt)
						:if(f){
							i = w
							m = o
							:call(syntax_isTypeDeclaration)
						}
					}
				}
			}
		}
	}
	:call(pop)
	o = s
	:call(pop)
	w = s
}
:fun(syntax_isReturn){
	:load(x,i)
	:if(x 27 ==){ # return
		i = i 4 +
		:load(x,i)
		:if(x 22 ==){ # ;
			i = i 4 +
			:store(5,m) # return
			:store(0 1 -,m 1 +) # expression
			m = m 5 +
			f = 0 # set match flag
			:if(d){
				:raw("RET ")
			}
		} else {
			:call(syntax_isExpression)
			:load(x,i)
			:if(f 0 == x 22 == &){ # x == ;
				i = i 4 +
				:store(5,m) # return
				:store(m 5 -,m 1 +) # expression
				m = m 5 +
				f = 0 # set match flag
				:if(d){
					:raw("RET ")
				}
			} else {
				f = 1
			}
		}
	}
}
:fun(syntax_isAssign){
	:call(syntax_isExpression)
	:load(x,i)
	:if(f 0 == x 1 == &){ # any of the assignments
		:load(s,i 1 +)
		:call(push)
		s = m 5 -
		:call(push)
		i = i 4 +
		:call(syntax_isExpression)
		:load(x,i)
		:call(pop) # expr1 mem
		z = s
		:call(pop) # assignment op
		:if(f 0 == x 22 == &){ # x == ;
			i = i 4 +
			:store(7,m) # assignment
			:store(s,m 1 +) # assignment op
			:store(z,m 2 +) # expression1
			:store(m 5 -,m 3 +) # expression 2
			m = m 5 +
			# match flag already 0
			:if(d){
				:raw("ASS ")
			}
		} else {
			f = 1
		}
	} else {
		f = 1
	}
}
:fun(syntax_isIf){
	:load(x,i)
	:if(x 11 ==){ # if
		i = i 4 +
		:load(x,i)
		:if(x 14 ==){ # (
			i = i 4 +
			f = 1
			:call(syntax_isExpression)
			:load(x,i)
			:if(f 0 == x 15 == &){ # x == )
				i = i 4 +
				:store(8,m) # if/else
				:store(0,m 1 +) # if
				:store(m 5 -,m 2 +) # expression is last cell
				m = m 5 +
				:load(x,i)
				:if(x 16 ==){ # {
					i = i 4 +
					:load(x,i)
					:while(x 17 =!){ # }
						f = 1
						:call(syntax_isStatement)
						:if(f){
							:call(errorUnmatchedToken)
						}
						:load(x,i)
					}
					i = i 4 +
				} else {
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
				}
				:load(x,i)
				:if(x 12 ==){ # else
					:if(d){
						:raw("IF ")
					}
					:store(8,m) # if/else
					:store(1,m 1 +) # else
					m = m 5 +
					i = i 4 +
					:load(x,i)
					:if(x 16 ==){ # {
						i = i 4 +
						:load(x,i)
						:while(x 17 =!){ # }
							f = 1
							:call(syntax_isStatement)
							:if(f){
								:call(errorUnmatchedToken)
							}
							:load(x,i)
						}
						i = i 4 +
					} else {
						f = 1
						:call(syntax_isStatement)
						:if(f){
							:call(errorUnmatchedToken)
						}
					}
					:store(8,m) # if/else
					:store(2,m 1 +) # end
					m = m 5 +
					:if(d){
						:raw("ELSE ")
					}
				} else {
					:store(8,m) # if/else
					:store(2,m 1 +) # end
					m = m 5 +
					:if(d){
						:raw("IF ")
					}
				}
			} else {
				f = 1
			}
		}
	}
}
:fun(syntax_isWhile){
	:load(x,i)
	:load(u,i 4 +)
	:if(x 13 == u 14 == &){ # x == while & u == (
		i = i 8 + # move 2 tokens ahead
		:call(syntax_isExpression)
		:load(x,i)
		:if(f 0 == x 15 == &){ # <expr> & x == )
			i = i 4 +
			:store(9,m) # while
			:store(0,m 1 +) # start
			:store(m 5 -,m 2 +) # expression is last cell
			m = m 5 +
			:load(x,i)
			:if(x 16 ==){ # {
				i = i 4 +
				:load(x,i)
				:while(x 17 =!){ # }
					f = 1
					:call(syntax_isStatement)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
				}
				i = i 4 +
			} else {
				f = 1
				:call(syntax_isStatement)
				:if(f){
					:call(errorUnmatchedToken)
				}
			}
			:store(9,m) # while
			:store(1,m 1 +) # end
			m = m 5 +
			:if(d){
				:raw("WHILE ")
			}
		}
	}
}
:fun(syntax_isExprStmt){
	:call(syntax_isExpression)
	:load(x,i)
	:if(f 0 == x 22 == &){ # <expr> & x == ;
		i = i 4 +
		:store(6,m) # expr stmt
		:store(m 5 -,m 1 +) # expression
		m = m 5 +
		f = 0 # set match flag
		:if(d){
			:raw("EXP ")
		}
	} else {
		f = 1
	}
}
:fun(syntax_isExpression){
	:call(syntax_isExpression_f)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_ee)
	}
}
:fun(syntax_isExpression_ee){
	:load(x,i)
	:if(x 42 ==){ # ||
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_f)
		:store(2,m) # expression
		:store(21,m 1 +) # ||
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop|| ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_ee)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_f){
	:call(syntax_isExpression_g)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_ff)
	}
}
:fun(syntax_isExpression_ff){
	:load(x,i)
	:if(x 41 ==){ # &&
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_g)
		:store(2,m) # expression
		:store(20,m 1 +) # &&
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop&& ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_ff)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_g){
	:call(syntax_isExpression_x)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_gg)
	}
}
:fun(syntax_isExpression_gg){
	:load(x,i)
	:if(x 29 ==){ # |
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_x)
		:store(2,m) # expression
		:store(19,m 1 +) # |
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop| ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_gg)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_x){
	:call(syntax_isExpression_h)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_xx)
	}
}
:fun(syntax_isExpression_xx){
	:load(x,i)
	:if(x 44 ==){ # ^
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_h)
		:store(2,m) # expression
		:store(26,m 1 +) # ^
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop^ ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_xx)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_h){
	:call(syntax_isExpression_i)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_hh)
	}
}
:fun(syntax_isExpression_hh){
	:load(x,i)
	:if(x 28 ==){ # &
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:call(syntax_isExpression_i)
		:store(2,m) # expression
		:store(18,m 1 +) # &
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop& ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_hh)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_i){
	:call(syntax_isExpression_j)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_ii)
	}
}
:fun(syntax_isExpression_ii){
	:load(x,i)
	:if(x 30 == x 31 == |){ # x == '==' | x == '!='
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		:if(x 30 ==){
			s = 16 # ==
		} else {
			s = 17 # !=
		}
		:call(push) # op
		:call(syntax_isExpression_j)
		:store(2,m) # expression
		:call(pop) # op
		:store(s,m 1 +) # type
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop!== ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_ii)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_j){
	:call(syntax_isExpression_k)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_jj)
	}
}
:fun(syntax_isExpression_jj){
	:load(x,i)
	# x == '<' | x == '>' | x == '<=' | x == '>='
	:if(x 32 == x 33 == | x 34 == | x 35 == |){
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		s = x 20 - # offset of new codes
		:call(push) # op
		:call(syntax_isExpression_k)
		:store(2,m) # expression
		:call(pop) # op
		:store(s,m 1 +) # type
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop>< ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_jj)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_k){
	:call(syntax_isExpression_l)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_kk)
	}
}
:fun(syntax_isExpression_kk){
	:load(x,i)
	:if(x 39 == x 40 == |){ # x == '+' | x == '-'
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		s = x 29 -
		:call(push) # op
		:call(syntax_isExpression_l)
		:store(2,m) # expression
		:call(pop) # op
		:store(s,m 1 +) # type
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop+- ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_kk)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_l){
	:call(syntax_isExpression_m)
	:if(f 0 ==){
		f = 1
		:call(syntax_isExpression_ll)
	}
}
:fun(syntax_isExpression_ll){
	:load(x,i)
	:if(x 36 == x 37 == | x 38 == |){ # x == '*' | x == '/' | x == '%'
		i = i 4 +
		s = m 5 -
		:call(push) # expr1
		s = x 29 -
		:call(push) # op
		:call(syntax_isExpression_m)
		:store(2,m) # expression
		:call(pop)
		:store(s,m 1 +) # op
		:call(pop) # expr1
		:store(s,m 2 +) # expr1
		:store(m 5 -,m 3 +) #expr2
		m = m 5 +
		:if(d){
			:raw("binop/*% ")
		}
		:if(f 0 ==){
			f = 1
			:call(syntax_isExpression_ll)
		}
	} else {
		f = 0
	}
}
:fun(syntax_isExpression_m){
	:load(x,i)
	s = 0
	:if(x 25 ==){ # ++
		s = 2 # pref ++
	} elif(x 26 ==){ # --
		s = 3 # pref --
	} elif(x 39 ==){ # +
		s = 4 # pref +
	} elif(x 40 ==){ # -
		s = 5 # pref -
	} elif(x 24 ==){ # !
		s = 6 # pref !
	} elif(x 43 ==){ # ~
		s = 27 # pref ~
	} elif(x 28 ==){ # &
		s = 28 # &
	} elif(x 36 ==){ # *
		s = 29 # *
	}
	:if(x 14 ==){ # x == '(' ; cast expression
		s = i
		:call(push)
		s = m
		:call(push)
		i = i 4 +
		f = 1
		:call(syntax_isType)
		:load(x,i)
		:if(f 0 == x 15 == &){ # <type> & x == ')'
			:call(pop)
			:call(pop)
			s = m 5 -
			:call(push)
			s = 30
			y = 1
		} else {
			:call(pop)
			m = s
			:call(pop)
			i = s
			f = 1
			s = 0 # make sure s is 0 because we didn't match
		}
	}
	:if(s){
		:if(d){
			:raw("prefix ")
		}
		i = i 4 +
		:call(push)
		:call(syntax_isExpression_m)
		:store(2,m) # expression
		:call(pop)
		:store(s,m 1 +) # type
		:store(m 5 -,m 2 +) # inner expression
		:if(s 30 ==){ # cast expression
			:call(pop)
			:store(s, m 3 +) # type is in expr2
		}
		m = m 5 +
	} else {
		:call(syntax_isExpression_n)
	}
}
:fun(syntax_isExpression_n){
	:call(syntax_isExpression_o)
	:call(syntax_isExpression_nn)
}
:fun(syntax_isExpression_nn){
	:load(x,i)
	:if(x 25 == x 26 == |){ # x == '++' | x == '--'
		:if(x 25 ==){
			x = 0 # ++
		} else {
			x = 1 # --
		}
		:store(2,m) # expression
		:store(x,m 1 +) # id
		:store(m 5 -,m 2 +) # expr is in previous cell
		m = m 5 +
		i = i 4 +
		:if(d){
			:raw("postinc ")
		}
		:call(syntax_isExpression_nn)
	} elif(x 18 ==){ # [
		s = m 5 -
		:call(push)
		i = i 4 +
		f = 1
		:call(syntax_isExpression)
		:call(pop)
		:load(x,i)
		:if(f 0 == x 19 == &){ # <expr> & x == ']'
			:store(2,m) # expression
			:store(24,m 1 +) # array access id
			:store(s,m 2 +) # base expression
			:store(m 5 -,m 3 +) # expression in previous cell
			m = m 5 +
			i = i 4 +
			:if(d){
				:raw("arr ")
			}
			:call(syntax_isExpression_nn)
		}
	} elif(x 20 ==){ # .
		i = i 4 +
		:load(x,i)
		:if(x 2 ==){ # ident
			:store(2,m) # expression
			:store(25,m 1 +) # comp acess
			:store(m 5 -,m 2 +) # base expression in previous cell
			:store(i,m 3 +) # token (component)
			m = m 5 +
			i = i 4 +
			:if(d){
				:raw("comp ")
			}
			:call(syntax_isExpression_nn)
		} else {
			f = 1
		}
	} elif(x 46 ==){ # ->
		i = i 4 +
		:load(x,i)
		:if(x 2 ==){ # ident
			:store(2,m) # expression
			:store(31,m 1 +) # comp acess (from pointer)
			:store(m 5 -,m 2 +) # base expression
			:store(i,m 3 +) # token (component)
			m = m 5 +
			i = i 4 +
			:if(d){
				:raw("ptrcomp ")
			}
			:call(syntax_isExpression_nn)
		} else {
			f = 1
		}
	}
}
:fun(syntax_isExpression_o){
	:load(x,i)
	:if(x 2 ==){ # ident
		:load(x,i 4 +)
		:if(x 14 ==){ # x == '(' function call
			# Starting memory entry for call
			s = m
			:call(push)
			:store(10,m) # call
			:store(0,m 1 +) # start
			:store(i,m 2 +) # ident
			m = m 5 +
			# Finish writing memory
			i = i 8 + # consume 2 tokens
			:load(x,i)
			y = x 15 =! # x != ')'
			:if(y){ # undo first increment of while loop
				i = i 4 -
			}
			:while(y){
				i = i 4 +
				f = 1
				:call(syntax_isExpression)
				:if(f){
					:call(errorUnmatchedToken)
				}
				:store(11,m) # argument
				:store(m 5 -,m 1 +)
				m = m 5 +
				:load(x,i)
				y = x 21 == # ,
			}
			:if(x 15 =!){ # )
				x = 41 # )
				:call(errorExpectedX)
			}
			:if(d){
				:raw("call ")
			}
			# Ending memory entry for call
			:store(10,m) # call
			:store(1,m 1 +) # end
			:call(pop)
			:store(s,m 3 +)
			m = m 5 +
		} else { # ident
			x = 2
			:store(2,m) # expression
			:store(22,m 1 +) # type = ident
			:store(i,m 2 +) # token
			m = m 5 +
			:if(d){
				:raw("ident ")
			}
		}
		i = i 4 +
		f = 0
	} elif(x 3 ==){ # const
		:store(2,m) # expression
		:store(23,m 1 +) # type
		:store(i,m 2 +) # token
		m = m 5 +
		i = i 4 +
		f = 0
		:if(d){
			:raw("const ")
		}
	} elif(x 14 ==){ # (
		:if(d){
			:raw("startencl ")
		}
		i = i 4 +
		:call(syntax_isExpression)
		:load(x,i)
		:if(x 15 =!){ # )
			x = 41 # )
			:call(errorExpectedX)
		}
		:raw("enclxpr ")
		i = i 4 +
	} elif(x 47 ==){ # sizeof
		i = i 4 +
		:load(x,i)
		:if(x 14 ==){ # (
			i = i 4 +
			f = 1
			:call(syntax_isType)
			:load(x,i)
			:if(f){
				:throw("Expected type, found ")
				:call(errint)
				:throw(".\n")
				:exit(1)
			} else {
				:if(x 15 =!){ # )
					x = 15 # )
					:call(errorExpectedX)
				}
			}
		} else {
			x = 14 # (
			:call(errorExpectedX)
		}
		:store(2,m) # expression
		:store(32,m 1 +) # expr id = typeof
		:store(m 5 -,m 2 +) # type cell
		m = m 5 +
		i = i 4 +
		:if(d){
			:raw("sizeof ")
		}
	}
}
:fun(syntax_isType){
	:load(x,i)
	f = 1
	:if(x 0 ==){ # type token
		:store(1,m) # type
		:load(x,i 1 +)
		:store(x,m 1 +) # type id
		m = m 5 +
		i = i 4 +
		:load(x,i)
		f = 0 # set match flag
	} elif(x 2 ==){ # ident token
		:store(1,m) # type
		:store(6,m 1 +) # type id = name type 
		:store(i,m 2 +) # basetype is the ident
		m = m 5 +
		i = i 4 +
		f = 0 # set match flag
	}
	y = f 0 ==
	:while(y){
		:load(x,i)
		:if(x 36 ==){ # *
			:store(1,m) # type
			:store(5,m 1 +) # type id = pointer type
			:store(m 5 -,m 2 +) # basetype is last type
			m = m 5 +
			i = i 4 +
		} else {
			:load(u,i 4 +)
			:load(v,i 8 +)
			:if(x 18 == u 3 == & v 19 == &){ # x == '[' && u == <const> && v == ']'
				:store(1,m) # type
				:store(4,m 1 +) # type id = array type
				:store(m 5 -,m 2 +) # basetype is last type
				:store(i 4 +,m 3 +) # length is the const token
				m = m 5 +
				i = i 12 +
			} else {
				y = 0
			}
		}
	}
}
:fun(syntax_isDeclaration){
	:call(syntax_isType)
	:load(x,i)
	l = i # save identifier location
	:if(f 0 == x 2 == &){ # <type> <ident>
		i = i 4 +
		:load(x,i)
		:if(x 22 ==){ # x = ';' ; <type> <ident>;
			:store(0,m) # declaration
			:store(m 5 -,m 1 +) # type was written in previous cell
			:store(0 1 -,m 2 +) # no expression
			:store(l,m 3 +) # identifier
			:store(0 1 -,m 4 +)
			m = m 5 +
			i = i 4 +
			f = 0 # set match flag
			:if(d){
				:raw("DECL ")
			}
		} else {
			:load(z,i 1 +) # load id
			:if(x 1 == z 0 == &){ # x == assignment & z == '=' ; <type> <ident> = 
				i = i 4 +
				n = m 5 - # save type location
				f = 1
				:call(syntax_isExpression)
				:load(x,i)
				:if(f 0 == x 22 == &){ # expr matched & x == ';' ; type ident = expr ;
					i = i 4 +
					:store(0,m)
					:store(n,m 1 +) # type location was saved in n
					:store(m 5 -,m 2 +) # expression in previous cell
					:store(l,m 3 +)
					:store(0 1 -,m 4 +)
					m = m 5 +
					:if(d){
						:raw("INIT ")
					}
				} else {
					f = 1 # no match
				}
			} else {
				f = 1 # no match
			}
		}
	} else {
		f = 1 # no match
	}
}
:fun(syntax_isTypeDeclaration){
	:load(x,i)
	:if(x 45 ==){ # struct
		i = i 4 +
		:load(x,i)
		:if(x 2 ==){ # ident
			:store(12,m) # struct
			:store(0,m 1 +) # start
			:store(i,m 2 +)
			:store(0 1 -,m 3 +)
			m = m 5 +
			i = i 4 +
			:load(x,i)
			:if(x 16 ==){ # {
				i = i 4 +
				:load(x,i)
				:while(x 17 =!){ # }
					f = 1
					:call(syntax_isParameter)
					:if(f){
						:call(errorUnmatchedToken)
					}
					:load(x,i)
					:if(x 22 =!){ # ;
						x = 59 # ;
						:call(errorExpectedX)
					}
					:if(x 0 1 - ==){ # EOF
						:raw("End of file reached while parsing struct.")
						x = 1
						:exit(x)
					}
					i = i 4 +
					:load(x,i)
				}
				:store(12,m) # struct
				:store(1,m 1 +) # end
				m = m 5 +
				i = i 4 +
				:load(x,i)
				:if(x 22 =!){ # ;
					x = 59 # ;
					:call(errorExpectedX)
				} 
				i = i 4 +
				f = 0
				:if(d){
					:raw("TYPEDECL ")
				}
			} else {
				x = 123 # {
				:call(errorExpectedX)
			}
		} else {
			:throw("Expected identifier. ")
			:load(x,i 3 +)
			:call(errorPrintLine)
		}
	}
}
#
# Phase 1 - Tokenize
#
:fun(tokenize){
	:if(d){
		:raw("Phase 1 - Tokenization\n")
	}
	l = 1 # line count
	i = 0 # file index
	:while(i b <){ # read through the file
		f = 1 # flag for matches ( 0 => stop trying to match)
		:call(tokenize_isComment)
		:if(f){
			:call(tokenize_isWhitespace)
			:if(f){
				:call(tokenize_isKeyword)
				:if(f){
					:call(tokenize_isConstant)
					:if(f){
						:call(tokenize_isSymbol)
						:if(f){
							:call(tokenize_isIdentifier)
							:if(f){
								:call(errorUnmatchedChar)
							}
						}
					}
				}
			}
		}
		c = i b < # Update condition
	}
	# End of tokens
	x = 0 1 -
	:store(x,m)
	:store(x,m 1 +)
	:store(x,m 2 +)
	:store(x,m 3 +)
	m = m 4 +
}
# Match comment
:fun(tokenize_isComment){
	:load(x,i)
	:if(x 47 == i 1 + b < &){ # '/' & i+1 < b
		:load(x,i 1 +)
		:if(x 47 ==){ # x == '/'
			f = 0 # set match flag
			i = i 2 + # increment file index
			:load(x,i)
			:while(x 10 =! i b < &){ # skip characters until end of line
				i = i 1 + # increment file index
				:load(x,i)
			}
		} elif(x 42 ==){ # '*' ; multiline comment
			v = 0
			i = i 1 +
			y = 1
			:while(y){
				:if(i b =>){
					:call(errorEOFcomment)
				}
				:load(x,i)
				i = i 1 +
				:if(x 42 ==){ # '*'
					v = 1
				} else {
					:if(x 47 == v &){ # /
						y = 0
					}
					v = 0
					:if(x 10 ==){# \n
						l = l 1 +
					}
				}
			}
		}
	}
}
# Match whitespace
:fun(tokenize_isWhitespace){
	:load(x,i)
	:while(x 10 == x 9 == | x 32 == | x 13 == |){ # x == '\n' | x == '\t' | x == ' ' | x == '\r'
		:if(x 10 ==){ # \n
			l = l 1 + # increment line counter
		}
		f = 0
		i = i 1 +
		:load(x,i)
	}
}
# Match keywords
:fun(tokenize_isKeyword){
	# Preload 4 characters in p,q,r,s,t
	:load(p,i)
	:load(q,i 1 +)
	:load(r,i 2 +)
	f = 0 # set match flag preemptively
	x = r # 3rd character should be non-identifier
	:call(tokenize_isKeyword_helper) # y contains result
	:if(p 105 == q 102 == & y &){ # if_
		:store(11,m) # type 11
		i = i 2 + # consume 2 characters
		:if(d){
			:raw("IF ")
		}
	} else { # keywords of length >= 3
		:load(s,i 3 +)
		x = s # 4th character should be non-identifier
		:call(tokenize_isKeyword_helper) # y contains result
		:if(p 105 == q 110 == & r 116 == & y &){ # int_
			:store(0,m) # type 0
			:store(0,m 1 +) # id 0 (int)
			i = i 3 + # consume 3 characters
			:if(d){
				:raw("INT ")
			}
		} else { # keywords of length >= 4
			:load(t,i 4 +)
			x = t # 5th character should be non-identifier
			:call(tokenize_isKeyword_helper) # y contains result
			:if(p 98 == q 111 == & r 111 == & s 108 == & y &){ # bool_
				:store(0,m) # type 0
				:store(2,m 1 +) # id 2 (bool)
				i = i 4 + # consume 4 characters
				:if(d){
					:raw("BOOL ")
				}
			} elif(p 99 == q 104 == & r 97 == & s 114 == & y &){ # char_
				:store(0,m) # type 0
				:store(1,m 1 +) # id 1 (char)
				i = i 4 +
				:if(d){
					:raw("CHAR ")
				}
			} elif(p 118 == q 111 == & r 105 == & s 100 == & y &){ # void_
				:store(0,m) # type 0
				:store(3,m 1 +) # id 3 (void)
				:store(0,m 2 +) # TODO: check if this is necessary
				i = i 4 + # consume 4 characters
				:if(d){
					:raw("VOID ")
				}
			} elif(p 101 == q 108 == & r 115 == & s 101 == & y &){ # else_
				:store(12,m) # type 1
				i = i 4 + # consume 4 characters
				:if(d){
					:raw("ELSE ")
				}
			} elif(p 116 == q 114 == & r 117 == & s 101 == & y &){ # true_
				:store(3,m) # type 3 (constant)
				:store(2,m 1 +) # id 2 (constant(bool))
				:store(1,m 2 +) # value
				i = i 4 +
				:if(d){
					:raw("CBOOL(1) ")
				}
			} elif(p 110 == q 117 == & r 108 == & s 108 == & y &){ # null_
				:store(3,m) # type 3 (constant)
				:store(4,m 1 +) # id 4 (constant(voidptr))
				:store(0,m 2 +) # value
				i = i 4 +
				:if(d){
					:raw("NULL ")
				}
			} else { # keywords of length >= 5
				:load(u,i 5 +)
				x = u
				:call(tokenize_isKeyword_helper) # y contains result
				:if(y p 119 == & q 104 == & r 105 == & s 108 == & t 101 == &){ # while_
					:store(13,m) # while
					i = i 5 + # consume 5 characters
					:if(d){
						:raw("WHILE ")
					}
				} elif(p 102 == q 97 == & r 108 == & s 115 == & t 101 == & y &){ # false_
					:store(3,m) # type 3 (constant)
					:store(2,m 1 +) # id 2 (constant(bool))
					:store(0,m 2 +) # value
					i = i 5 +
					:if(d){
						:raw("CBOOL(0) ")
					}
				} else { # keywords of length >= 6
					:load(x,i 6 +)
					:call(tokenize_isKeyword_helper) # y contains result
					:if(y p 114 == & q 101 == & r 116 == & s 117 == & t 114 == & u 110 == &){ # return_
						:store(27,m) # return
						i = i 6 + # consume 6 characters
						:if(d){
							:raw("RETURN ")
						}
					} elif(y p 115 == & q 116 == & r 114 == & s 117 == & t 99 == & u 116 == &){ # struct_
						:store(45,m) # struct
						i = i 6 + # consume 6 characters
						:if(d){
							:raw("STRUCT ")
						}
					} elif(y p 115 == & q 105 == & r 122 == & s 101 == & t 111 == & u 102 == &){ # sizeof_
						:store(47,m) # sizeof
						i = i 6 + # consume 6 characters
						:if(d){
							:raw("SIZEOF ")
						}
					} else {
						f = 1 # we didn't match
					}
				}
			}
		}
	}
	:if(f 0 == ){
		:store(l,m 3 +)
		m = m 4 +
	}
}
# input x
# output y
:fun(tokenize_isKeyword_helper){ # check if char is not identifier
	# !(x >= '0' & x <= '9' | x >= 'A' & x <= 'Z' | x == '_' | x >= 'a' & x <= 'z')
	y = 1 x 48 => x 57 =< & x 65 => x 90 =< & | x 95 == | x 97 => x 122 =< & | -
}
:fun(tokenize_isSymbol){
	:load(x,i)
	:load(z,i 1 +)
	f = 0 # set match flag
	:if(x 43 == z 61 == &){ # +=
		:store(1,m) # token type
		:store(1,m 1 +) # id 1 (+=)
		i = i 2 +
		:if(d){
			:raw("ADDEQ ")
		}
	} elif(x 45 == z 61 == &){ # -=
		:store(1,m) # token type
		:store(2,m 1 +) # id 2 (-=)
		i = i 2 +
		:if(d){
			:raw("SUBEQ ")
		}
	} elif(x 47 == z 61 == &){ # /=
		:store(1,m) # token type
		:store(3,m 1 +) # id 3 (/=)
		i = i 2 +
		:if(d){
			:raw("DIVEQ ")
		}
	} elif(x 42 == z 61 == &){ # *=
		:store(1,m) # token type
		:store(4,m 1 +) # id 4 (*=)
		i = i 2 +
		:if(d){
			:raw("MULEQ ")
		}
	} elif(x 43 == z 43 == &){ # ++
		:store(25,m) # token type
		i = i 2 +
		:if(d){
			:raw("INC ")
		}
	} elif(x 45 == z 45 == &){ # -=
		:store(26,m) # token type
		i = i 2 +
		:if(d){
			:raw("DEC ")
		}
	} elif(x 61 == z 61 == &){ # ==
		:store(30,m) # token type
		i = i 2 +
		:if(d){
			:raw("EQ ")
		}
	} elif(x 33 == z 61 == &){ # !=
		:store(31,m) # token type
		i = i 2 +
		:if(d){
			:raw("NEQ ")
		}
	} elif(x 60 == z 61 == &){ # <=
		:store(34,m) # token type
		i = i 2 +
		:if(d){
			:raw("LEQ ")
		}
	} elif(x 62 == z 61 == &){
		:store(35,m) # token type
		i = i 2 +
		:if(d){
			:raw("GEQ ")
		}
	} elif(x 38 == z 38 == &){ # &&
		:store(41,m) # token type
		i = i 2 +
		:if(d){
			:raw("AND ")
		}
	} elif(x 124 == z 124 == &){ # ||
		:store(42,m) # token type
		i = i 2 +
		:if(d){
			:raw("OR ")
		}
	} elif(x 45 == z 62 == &){ # ->
		:store(46,m) # token type
		i = i 2 +
		:if(d){
			:raw("ARROW ")
		}
	} elif(x 40 ==){ # (
		:store(14,m) # token type
		i = i 1 +
		:if(d){
			:raw("LPARENT ")
		}
	} elif(x 41 == ){ # )
		:store(15,m) # token type
		i = i 1 +
		:if(d){
			:raw("RPARENT ")
		}
	} elif(x 123 ==){ # {
		:store(16,m) # token type
		i = i 1 +
		:if(d){
			:raw("LCURLY ")
		}
	} elif(x 125 ==){ # {
		:store(17,m) # token type
		i = i 1 +
		:if(d){
			:raw("RCURLY ")
		}
	} elif(x 91 ==){ # [
		:store(18,m) # token type
		i = i 1 +
		:if(d){
			:raw("LBRACK ")
		}
	} elif(x 93 ==){ # ]
		:store(19,m) # token type
		i = i 1 +
		:if(d){
			:raw("RBRACK ")
		}
	} elif(x 46 ==){ # .
		:store(20,m) # token type
		i = i 1 +
		:if(d){
			:raw("PERIOD ")
		}
	} elif(x 44 ==){ # ,
		:store(21,m)
		i = i 1 +
		:if(d){
			:raw("COMMA ")
		}
	} elif(x 59 ==){ # ;
		:store(22,m)
		i = i 1 +
		:if(d){
			:raw("SEMICOLON ")
		}
	} elif(x 58 ==){ # :
		:store(23,m)
		i = i 1 +
		:if(d){
			:raw("COLON ")
		}
	} elif(x 61 ==){ # =
		:store(1,m) # type 1
		:store(0, m 1 +) # id 0
		i = i 1 +
		:if(d){
			:raw("ASSIGN ")
		}
	} elif(x 33 ==){ # !
		:store(24,m)
		i = i 1 +
		:if(d){
			:raw("EXCL ")
		}
	} elif(x 38 ==){ # &
		:store(28,m)
		i = i 1 +
		:if(d){
			:raw("BITAND ")
		}
	} elif(x 124 ==){ # |
		:store(29,m)
		i = i 1 +
		:if(d){
			:raw("BITOR ")
		}
	} elif(x 60 ==){ # <
		:store(32,m)
		i = i 1 +
		:if(d){
			:raw("LT ")
		}
	} elif(x 62 ==){ # >
		:store(33,m)
		i = i 1 +
		:if(d){
			:raw("GT ")
		}
	} elif(x 42 ==){ # *
		:store(36,m)
		i = i 1 +
		:if(d){
			:raw("MUL ")
		}
	} elif(x 47 ==){ # /
		:store(37,m)
		i = i 1 +
		:if(d){
			:raw("DIV ")
		}
	} elif(x 37 ==){ # %
		:store(38,m)
		i = i 1 +
		:if(d){
			:raw("MOD ")
		}
	} elif(x 43 ==){ # +
		:store(39,m)
		i = i 1 +
		:if(d){
			:raw("ADD ")
		}
	} elif(x 45 ==){ # -
		:store(40,m)
		i = i 1 +
		:if(d){
			:raw("SUB ")
		}
	} elif(x 126 ==){ # ~
		:store(43,m)
		i = i 1 +
		:if(d){
			:raw("BITNOT ")
		}
	} elif(x 94 ==){ # ^
		:store(44,m)
		i = i 1 +
		:if(d){
			:raw("BITXOR ")
		}
	} else {
		f = 1 # we didn't match
	}
	# Shared code for writing the line number and moving the memory index
	:if(f 0 ==) {
		:store(l,m 3 +)
		m = m 4 +
	}
}
:fun(tokenize_isConstant){
	:call(tokenize_isConstant_char)
	:if(f){
		:call(tokenize_isConstant_int)
		:if(f){
			:call(tokenize_isConstant_string)
		}
	}
	:if(f 0 ==){
		:store(l,m 3 +)
		m = m 4 +
	}
}

:fun(tokenize_isConstant_char){
	:load(p,i)
	:load(q,i 1 +)
	x = q
	:call(isValidChar)
	:if(y p 39 == &){ # p == ' & q == char
		:if(q 92 ==){ # \
			:load(x,i 2 +)
			:call(convertEscapableChar) # result in y
			q = y
			:load(p,i 3 +)
			r = 4 # shruld consume 4 characters
		} else {
			:load(p,i 2 +)
			r = 3 # shruld consume 3 characters
		}
		:if(p 39 ==){ # '
			f = 0 # set match flag
			:store(3,m) # type 3 (constant)
			:store(1,m 1 +) # id 1 (constant(char))
			:store(q,m 2 +) # value
			i = i r +
			:if(d){
				:raw("CCHAR(")
				:call(putint)
				:raw(") ")
			}
		} else {
			:call(errorInvalidCharConstant)
		}
	}
}
:fun(tokenize_isConstant_int){
	w = i
	:load(x,i)
	v = x 48 == # 0
	:if(x 48 => x 57 =< &){ # x >= '0' & x <= '9'
		z = 0
		:while(x 48 => x 57 =< &){ # x >= '0' & x <= '9'
			z = z 10 *
			:if(z 0 <){
				:call(errorConstantTooBig)
			}
			z = z x 48 - +
			i = i 1 +
			:load(x,i)
		}
		:if(z 0 > v &){
			:call(errorLeadingZero)
		}
		f = 0 # set flag
		:store(3,m) # type 3
		:store(0,m 1 +) # id 0 (constant(int))
		:store(z,m 2 +) # value
		:if(d){
			:raw("CINT(")
			x = z
			:call(putint)
			:raw(") ")
		}
	} else {
		i = w
	}
}
:fun(tokenize_isConstant_string){
	:load(x,i)
	:if(x 34 ==){ # "
		z = i
		y = 1
		:while(y){
			i = i 1 +
			:load(x,i)
			:if(x 92 ==){ # \
				i = i 1 +
				:load(x,i)
				:call(convertEscapableChar)
				y = 1
			} else {
				:call(isValidChar)
				:if(1 y -){
					:call(errorInvalidCharInString)
				}
				y = x 34 =! # "
			}
		}
		i = i 1 + # move past "
		f = 0 # set flag
		:store(3,m) # type 3 (constant)
		:store(3,m 1 +) # id 3 (constant(string))
		:store(z,m 2 +) # start
		:if(d){
			:raw("CSTRING(")
			y = 1
			:while(y){
				:load(x,z)
				z = z 1 +
				:putchar(x)
				:if(x 92 ==){ # \
					:load(x,z)
					z = z 1 +
					:putchar(x)
				} else {
					y = x 34 =! # "
				}
			}
			:raw(") ")
		}
	}
}
:fun(tokenize_isIdentifier){
	:load(x,i)
	z = i
	w = 0 # length
	# x == '_' | x >= 'A' & x <= 'Z' | x >= 'a' & x <= 'z'
	y = x 95 == x 65 => x 90 =< & | x 97 => x 122 =< & |
	:if(y){
		f = 0 # set match flag
		:while(y){
			w = w 1 +
			i = i 1 +
			:load(x,i)
			:call(tokenize_isKeyword_helper) # returns 1 in y if its NOT an identifier char
			y = 1 y -
		}
		f = 0 # set flag
		:store(2,m) # type 2
		:store(z,m 1 +) # start of identifier
		:store(w,m 2 +) # length
		:store(l,m 3 +) # line number
		m = m 4 +
		:if(d){
			:raw("IDENT(")
			w = z w + # end
			:while(z w <){
				:load(x,z)
				:putchar(x)
				z = z 1 +
			}
			:raw(") ")
		}
	}
}
#
# Phase 0 - Read file
#
:fun(readFile){
	:getchar(x)
	:while(x){
		:store(x,m)
		m = m 1 +
		:getchar(x)
	}
}
#
# Utility functions
#
# breakpoint
:fun(break){
}
:fun(push){
	:store(s,a)
	a = a 1 -
}
:fun(pop){
	a = a 1 +
	:load(s,a)
}
:fun(putint){
	s = y
	:call(push) # save y
	s = w
	:call(push) # save w
	s = x
	:call(push) # save x
	:if(x 0 <){
		:raw("-")
		w = x 0 1 - *
	} else {
		w = x
	}
	y = 10
	:while(w y / 0 >){
		y = y 10 *
	}
	y = y 10 /
	:while(y){
		x = w y / 10 % 48 +
		:putchar(x)
		y = y 10 /
	}
	:call(pop) # restore x
	x = s
	:call(pop) # restore w
	w = s
	:call(pop) # restore y
	y = s
}
:fun(errint){
	s = y
	:call(push) # save y
	s = w
	:call(push) # save w
	s = x
	:call(push) # save x
	y = x 0 <
	:if(y){
		:raw("-")
		w = x 0 1 - *
	} else {
		w = x
	}
	y = 10
	:while(w y / 0 >){
		y = y 10 *
	}
	y = y 10 /
	:while(y){
		x = w y / 10 % 48 +
		:uchar(x)
		y = y 10 /
	}
	:call(pop) # restore x
	x = s
	:call(pop) # restore w
	w = s
	:call(pop) # restore y
	y = s
}
# input: x
# writes: y
:fun(convertEscapableChar){
	:if(x 110 ==){ # n
		y = 10 # newline
	} elif(x 116 ==){ # t
		y = 9 # tab
	} elif(x 39 == x 34 == | x 92 == |){ # ' " \
		y = x
	} else {
		:throw("Invalid escape sequence. Line ")
		x = l
		:call(errint)
		:throw("\n")
		:exit(1)
	}
}
:fun(isValidChar){
	y = x 32 => x 126 =< & # x >= ' ' & x <= '~'
}
:fun(debug_printType){
	:load(u,x)
	:if(u 1 =!){
		x = u
		:call(putint)
		x = 0 30 -
		:call(errorPrintLine)
	}
	:load(u,x 1 +)
	:if(u 0 ==){ # int
		:raw("int")
	} elif(u 1 ==){ # char
		:raw("char")
	} elif(u 2 ==){ # bool
		:raw("bool")
	} elif(u 3 ==){ # void
		:raw("void")
	} elif(u 4 ==){ # array
		:raw("arr(")
		:load(u,x 3 +) # load token addr
		:load(u,u 2 +) # load const value
		v = x
		x = u
		:call(putint)
		:raw(", ")
		x = v
		:load(x,x 2 +) # basetype
		:call(debug_printType)
		:raw(")")
	} elif(u 5 ==){ # pointer
		:raw("ptr(")
		:load(x,x 2 +) # basetype
		:call(debug_printType)
		:raw(")")
	} elif(u 6 ==){ # nametype
		:load(u,x 2 +) # basetype
		:load(v,u 2 +) # length
		:load(u,u 1 +) # start
		v = u v +
		:while(u v <){
			:load(x,u)
			:putchar(x)
			u = u 1 +
		}
	}
}
:fun(debug_printTypes){
	:raw("\nTypes:\n")
	i = e
	:while(i g <){
		:load(x,i)
		y = 0
		:if(x 0 ==){ # declaration
			:raw("DECL [ ")
			:load(x,i 1 +)
			y = 1
		} elif(x 3 ==){ # function
			:load(v,i 3 +)
			:if(v 1 =!){ # end
				:raw("FUN [ ")
				:load(x,i 1 +)
				y = 1
			}
		} elif(x 4 ==){ # parameter
			:raw("PAR [ ")
			:load(x,i 1 +)
			y = 1
		} elif(x 2 ==){ # expression
			:load(z,i 1 +)
			:if(z 30 ==){ # cast expression
				:raw("CAST [ ")
				:load(x,i 3 +)
				y = 1
			}
		}
		:if(y){
			:call(debug_printType)
			:raw(" ] ")
		}
		i = i 5 +
	}
}
:fun(debug_printExpressions){
	:raw("\nExpressions:\n")
	i = e
	:while(i g <){
		:load(x,i)
		:if(x 0 ==){ # declaration
			:load(x,i 2 +)
			:if(x 0 1 - =!){
				:raw("INIT[ ")
				:call(debug_printExpression)
				:raw(" ] ")
			}
		} elif(x 5 ==){ # return
			:load(x,i 1 +)
			:raw("RET[ ")
			:if(x 0 1 - =!){
				:call(debug_printExpression)
			}
			:raw(" ] ")
		} elif(x 6 ==){ # expression stmt
			:load(x,i 1 +)
			:raw("EXP[ ")
			:call(debug_printExpression)
			:raw(" ] ")
		} elif(x 7 ==){ # assign
			:load(x,i 2 +)
			:raw("ASS[ ")
			:call(debug_printExpression)
			:raw(" ]=[ ")
			:load(x,i 3 +)
			:call(debug_printExpression)
			:raw(" ] ")
		} elif(x 8 ==){
			:load(x,i 1 +)
			:if(x 0 ==){ # if
				:load(x,i 2 +)
				:raw("IF[ ")
				:call(debug_printExpression)
				:raw(" ] ")
			}
		} elif(x 9 ==){
			:load(x,i 1 +)
			:if(x 0 ==){ # start
				:load(x,i 2 +)
				:raw("WHILE[ ")
				:call(debug_printExpression)
				:raw(" ] ")
			}
		}
		i = i 5 +
	}
}
:fun(debug_printExpressionExtra){
	:if(u 10 ==){ # call expression
		u = 1
		:while(u){
			x = x 5 -
			:load(y,x)
			:if(y 10 ==){
				:load(y,x 1 +)
				:if(y){ # y : 0start, 1end
					u = u 1 +
				} else {
					u = u 1 -
				}
			}
		}
		:raw("CALL(")
		:load(u,x 2 +) # ident
		:load(y,u) # check if its an ident
		:if(y 2 =!){
			x = 0 44 -
			:call(errorPrintLine)
		}
		v = x
		x = u
		:call(printIdent)
		x = v
		:raw(")[ ")
		u = 1
		v = 0
		:while(u){
			x = x 5 +
			:load(z,x)
			:if(z 10 ==){
				:load(y,x 1 +)
				:if(y){ # y : 0start, 1end
					:if(v){
						v = v 1 -
					} else {
						u = 0
					}
				} else {
					v = v 1 +
				}
			} elif(z 11 == v 0 == &){ # argument of current call
				s = x
				:call(push)
				:load(x,x 1 +)
				:call(debug_printExpression)
				:call(pop)
				x = s
				:raw(", ")
			}
		}
		:raw(" ]")
	}
}
:fun(debug_printExpression){
	:load(u,x)
	:if(u 2 =!){ # check if its an expression
		:call(debug_printExpressionExtra)
	} else {
		:load(u,x 1 +)
		:if(u 0 ==){ # postfix ++
			:raw("(")
			:load(x,x 2 +) # expr1
			:call(debug_printExpression)
			:raw("++")
			:raw(")")
		} elif(u 1 ==){ # postfix --
			:raw("(")
			:load(x,x 2 +) # expr1
			:call(debug_printExpression)
			:raw("--")
			:raw(")")
		} elif(u 2 => u 6 =< & u 27 => u 30 =< & |){ # prefix
			:raw("(")
			:load(x,x 2 +) # expr1
			:if(u 2 ==){
				:raw("++")
			} elif(u 3 ==){
				:raw("--")
			} elif(u 4 ==){
				:raw("+")
			} elif(u 5 ==){
				:raw("-")
			} elif(u 27 ==){
				:raw("~")
			} elif(u 28 ==){
				:raw("&")
			} elif(u 29 ==){
				:raw("*")
			} elif(u 30 ==){
				:raw("cast")
			} else {
				:raw("!")
			}
			:call(debug_printExpression)
			:raw(")")
		} else {
			:if(u 7 => u 21 =< & u 26 == |){ # binop
				:raw("(")
				x = x 2 + # expr1
				s = x 1 + # expr2
				:call(push) # push expr2
				s = u # op
				:call(push) # push op
				:load(x,x)
				:call(debug_printExpression)
				:call(pop) # pop op
				:if(s 7 ==){
					:raw("*")
				} elif(s 8 ==){
					:raw("/")
				} elif(s 9 ==){
					:raw("%")
				} elif(s 10 ==){
					:raw("+")
				} elif(s 11 ==){
					:raw("-")
				} elif(s 12 ==){
					:raw("<")
				} elif(s 13 ==){
					:raw(">")
				} elif(s 14 ==){
					:raw("<=")
				} elif(s 15 ==){
					:raw(">=")
				} elif(s 16 ==){
					:raw("==")
				} elif(s 17 ==){
					:raw("!=")
				} elif(s 18 ==){
					:raw("&")
				} elif(s 19 ==){
					:raw("|")
				} elif(s 20 ==){
					:raw("&&")
				} elif(s 26 ==){
					:raw("^")
				} else {
					:raw("||")
				}
				:call(pop) # pop expr2
				:load(x,s)
				:call(debug_printExpression)
				:raw(")")
			} elif(u 22 ==){ # ident
				:load(x,x 2 +) # expr1 (identifier token)
				:load(u,x)
				:if(u 2 =!){ # Sanity check
					x = 0 42 -
					:call(errorPrintLine)
				}
				:call(printIdent)
			} elif(u 23 ==){ # const
				:load(x,x 2 +) # expr1 (const token)
				:load(u,x)
				:if(u 3 =!){ # Sanity check
					x = 0 43 -
					:call(errorPrintLine)
				}
				:load(u,x 1 +) # constant id
				:load(x,x 2 +)
				:if(u 3 ==) {
					:raw("\"")
					z = x 1 +
					y = 1
					:while(y){
						:load(x,z)
						z = z 1 +
						:putchar(x)
						:if(x 92 ==){ # \
							:load(x,z)
							z = z 1 +
							:putchar(x)
						} else {
							y = x 34 =! # "
						}
					}
				} else {
					:call(putint)
				}
			} elif(u 24 ==){ # array
				:raw("(")
				x = x 2 + # expr1
				s = x 1 + # expr2
				:call(push)
				:load(x,x)
				:call(debug_printExpression)
				:raw("[")
				:call(pop)
				:load(x,s)
				:call(debug_printExpression)
				:raw("])")
			} elif(u 25 ==){ # component
				:raw("(")
				x = x 2 + # expr1
				s = x 1 + # expr2
				:call(push)
				:load(x,x)
				:call(debug_printExpression)
				:raw(".")
				:call(pop)
				:load(x,s)
				:call(printIdent)
				:raw(")")
			} elif(u 31 ==){ # pointer component
				:raw("(")
				x = x 2 + # expr1
				s = x 1 + # expr2
				:call(push)
				:load(x,x)
				:call(debug_printExpression)
				:raw("->")
				:call(pop)
				:load(x,s)
				:call(printIdent)
				:raw(")")
			}
		}
	}
}
:fun(printIdent){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	:load(u,x 1 +) # start
	:load(v,x 2 +) # length
	v = u v +
	:while(u v <){
		:load(x,u)
		:putchar(x)
		u = u 1 +
	}
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
:fun(errorIdent){
	s = x
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	:load(u,x 1 +) # start
	:load(v,x 2 +) # length
	v = u v +
	:while(u v <){
		:load(x,u)
		:uchar(x)
		u = u 1 +
	}
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	x = s
}
# input: x,y
# output: y
:fun(identEquals){
	s = t
	:call(push)
	s = u
	:call(push)
	s = v
	:call(push)
	s = z
	:call(push)
	:load(u,x 2 +) # ident1 length
	:load(v,y 2 +) # ident2 length
	:load(x,x 1 +) # ident1 start
	:load(y,y 1 +) # ident2 start
	t = 0 1 - # counter
	z = u # length
	:while(u v == t z < &){
		t = t 1 +
		:load(u,x t +)
		:load(v,y t +)
	}
	y = t z ==
	:call(pop)
	z = s
	:call(pop)
	v = s
	:call(pop)
	u = s
	:call(pop)
	t = s
}
#
# Errors
#
:fun(errorInternal){
	:throw("Internal error\n")
	:exit(1)
}
:fun(errorExpectedX){
	:throw("Expected ")
	:putchar(x)
	:throw(", found token type ")
	:load(x,i)
	:call(errint)
	:throw(". ")
	:load(x,i 3 +)
	:call(errorPrintLine)
}
:fun(errorUnmatchedToken){
	:throw("Unmatched token (type ")
	:load(x,i)
	:call(errint)
	:throw("). ")
	:load(x,i 3 +)
	:call(errorPrintLine)
}
:fun(errorEOFcomment){
	:throw("EOF reached while parsing comment.")
	:exit(1)
}
:fun(errorInvalidCharConstant){
	:throw("Invalid char constant. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorLeadingZero){
	:throw("Invalid int constant (leading zeros). ")
	x = l
	:call(errorPrintLine)
}
:fun(errorConstantTooBig){
	:throw("Invalid int constant (too big). ")
	x = l
	:call(errorPrintLine)
}
:fun(errorInvalidCharInString){
	:throw("Invalid char encountered in string literal. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorUnmatchedChar){
	:throw("Unmatched char '")
	:load(x,i)
	:uchar(x)
	:throw("'. ")
	x = l
	:call(errorPrintLine)
}
:fun(errorPrintLine){
	:throw("Line ")
	:call(errint)
	:throw("\n")
	:exit(1)
}
